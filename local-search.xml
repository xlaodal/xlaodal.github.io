<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day07--%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6%EF%BC%88Set%E3%80%81Map%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <url>/2023/12/01/day07--%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6%EF%BC%88Set%E3%80%81Map%E9%9B%86%E5%90%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="day07——集合进阶（Set、Map集合）"><a href="#day07——集合进阶（Set、Map集合）" class="headerlink" title="day07——集合进阶（Set、Map集合）"></a>day07——集合进阶（Set、Map集合）</h1><h2 id="一、Set系列集合"><a href="#一、Set系列集合" class="headerlink" title="一、Set系列集合"></a>一、Set系列集合</h2><h3 id="1-1-认识Set集合的特点"><a href="#1-1-认识Set集合的特点" class="headerlink" title="1.1 认识Set集合的特点"></a>1.1 认识Set集合的特点</h3><p>Set集合是属于Collection体系下的另一个分支，它的特点如下图所示</p><p><img src="/assets/1666169984705-1667311908041.png" alt="1666169984705"></p><p>下面我们用代码简单演示一下，每一种Set集合的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Set&lt;Integer&gt; set = new HashSet&lt;&gt;();//无序、无索引、不重复</span><br><span class="hljs-comment">//Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); //有序、无索引、不重复</span><br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(); <span class="hljs-comment">//可排序(升序)、无索引、不重复</span><br>set.add(<span class="hljs-number">666</span>);<br>set.add(<span class="hljs-number">555</span>);<br>set.add(<span class="hljs-number">555</span>);<br>set.add(<span class="hljs-number">888</span>);<br>set.add(<span class="hljs-number">888</span>);<br>set.add(<span class="hljs-number">777</span>);<br>set.add(<span class="hljs-number">777</span>);<br>System.out.println(set); <span class="hljs-comment">//[555, 666, 777, 888]</span><br></code></pre></td></tr></table></figure><h3 id="1-2-HashSet集合底层原理"><a href="#1-2-HashSet集合底层原理" class="headerlink" title="1.2 HashSet集合底层原理"></a>1.2 HashSet集合底层原理</h3><p>接下来，为了让同学们更加透彻的理解HashSet为什么可以去重，我们来看一下它的底层原理。</p><p>HashSet集合底层是基于哈希表实现的，哈希表根据JDK版本的不同，也是有点区别的</p><ul><li>JDK8以前：哈希表 &#x3D; 数组+链表</li><li>JDK8以后：哈希表 &#x3D; 数组+链表+红黑树</li></ul><p><img src="/assets/1666170451762-1667311904484.png" alt="1666170451762"></p><p>我们发现往HashSet集合中存储元素时，底层调用了元素的两个方法：一个是hashCode方法获取元素的hashCode值（哈希值）；另一个是调用了元素的equals方法，用来比较新添加的元素和集合中已有的元素是否相同。 </p><ul><li>只有新添加元素的hashCode值和集合中以后元素的hashCode值相同、新添加的元素调用equals方法和集合中已有元素比较结果为true, 才认为元素重复。</li><li>如果hashCode值相同，equals比较不同，则以链表的形式连接在数组的同一个索引为位置（如上图所示）</li></ul><p>在JDK8开始后，为了提高性能，当链表的长度超过8时，就会把链表转换为红黑树，如下图所示：</p><p><img src="/assets/1666171011761-1667311900100.png" alt="1666171011761"></p><h3 id="1-3-HashSet去重原理"><a href="#1-3-HashSet去重原理" class="headerlink" title="1.3 HashSet去重原理"></a>1.3 HashSet去重原理</h3><p>前面我们学习了HashSet存储元素的原理，依赖于两个方法：一个是hashCode方法用来确定在底层数组中存储的位置，另一个是用equals方法判断新添加的元素是否和集合中已有的元素相同。</p><p>要想保证在HashSet集合中没有重复元素，我们需要重写元素类的hashCode和equals方法。比如以下面的Student类为例，假设把Student类的对象作为HashSet集合的元素，想要让学生的姓名和年龄相同，就认为元素重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height; <span class="hljs-comment">//身高</span><br> <br>    <span class="hljs-comment">//无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//全参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">double</span> height)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>        <span class="hljs-built_in">this</span>.height=height;<br>    &#125;<br>    <span class="hljs-comment">//...get、set、toString()方法自己补上..</span><br>    <br>    <span class="hljs-comment">//按快捷键生成hashCode和equals方法</span><br>    <span class="hljs-comment">//alt+insert 选择 hashCode and equals</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;<br><br>        <span class="hljs-keyword">if</span> (age != student.age) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (Double.compare(student.height, height) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> name != <span class="hljs-literal">null</span> ? name.equals(student.name) : student.name == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> result;<br>        <span class="hljs-type">long</span> temp;<br>        result = name != <span class="hljs-literal">null</span> ? name.hashCode() : <span class="hljs-number">0</span>;<br>        result = <span class="hljs-number">31</span> * result + age;<br>        temp = Double.doubleToLongBits(height);<br>        result = <span class="hljs-number">31</span> * result + (<span class="hljs-type">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="hljs-number">32</span>));<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，写一个测试类，往HashSet集合中存储Student对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Set&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>,<span class="hljs-number">20</span>, <span class="hljs-number">169.6</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.6</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.6</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;牛魔王&quot;</span>,<span class="hljs-number">48</span>, <span class="hljs-number">169.6</span>);<br>        <br>        students.add(s1);<br>        students.add(s2);<br>        students.add(s3);<br>        students.add(s4);<br>        <br>        <span class="hljs-keyword">for</span>(Student s : students)&#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果如下，我们发现存了两个蜘蛛精，当时实际打印出来只有一个，而且是无序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Student&#123;name=<span class="hljs-string">&#x27;牛魔王&#x27;</span>, age=<span class="hljs-number">48</span>, height=<span class="hljs-number">169.6</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;至尊宝&#x27;</span>, age=<span class="hljs-number">20</span>, height=<span class="hljs-number">169.6</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;蜘蛛精&#x27;</span>, age=<span class="hljs-number">23</span>, height=<span class="hljs-number">169.6</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-LinkedHashSet底层原理"><a href="#1-4-LinkedHashSet底层原理" class="headerlink" title="1.4 LinkedHashSet底层原理"></a>1.4 LinkedHashSet底层原理</h3><p>接下来，我们再学习一个HashSet的子类LinkedHashSet类。LinkedHashSet它底层采用的是也是哈希表结构，只不过额外新增了一个双向链表来维护元素的存取顺序。如下下图所示：</p><p><img src="/assets/1666171776819-1667311894748.png" alt="1666171776819"></p><p>每次添加元素，就和上一个元素用双向链表连接一下。第一个添加的元素是双向链表的头节点，最后一个添加的元素是双向链表的尾节点。</p><p>把上个案例中的集合改成LinkedList集合，我们观察效果怎样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Set&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>,<span class="hljs-number">20</span>, <span class="hljs-number">169.6</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.6</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.6</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;牛魔王&quot;</span>,<span class="hljs-number">48</span>, <span class="hljs-number">169.6</span>);<br>        <br>        students.add(s1);<br>        students.add(s2);<br>        students.add(s3);<br>        students.add(s4);<br>        <br>        <span class="hljs-keyword">for</span>(Student s : students)&#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Student&#123;name=<span class="hljs-string">&#x27;至尊宝&#x27;</span>, age=<span class="hljs-number">20</span>, height=<span class="hljs-number">169.6</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;蜘蛛精&#x27;</span>, age=<span class="hljs-number">23</span>, height=<span class="hljs-number">169.6</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;牛魔王&#x27;</span>, age=<span class="hljs-number">48</span>, height=<span class="hljs-number">169.6</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-TreeSet集合"><a href="#1-5-TreeSet集合" class="headerlink" title="1.5 TreeSet集合"></a>1.5 TreeSet集合</h3><p>最后，我们学习一下TreeSet集合。TreeSet集合的特点是可以对元素进行排序，但是必须指定元素的排序规则。</p><p>如果往集合中存储String类型的元素，或者Integer类型的元素，它们本身就具备排序规则，所以直接就可以排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; set1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>set1.add(<span class="hljs-number">8</span>);<br>set1.add(<span class="hljs-number">6</span>);<br>set1.add(<span class="hljs-number">4</span>);<br>set1.add(<span class="hljs-number">3</span>);<br>set1.add(<span class="hljs-number">7</span>);<br>set1.add(<span class="hljs-number">1</span>);<br>set1.add(<span class="hljs-number">5</span>);<br>set1.add(<span class="hljs-number">2</span>);<br>System.out.println(set1); <span class="hljs-comment">//[1,2,3,4,5,6,7,8]</span><br><br>Set&lt;Integer&gt; set2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>set2.add(<span class="hljs-string">&quot;a&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;c&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;e&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;b&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;d&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;f&quot;</span>);<br>set2.add(<span class="hljs-string">&quot;g&quot;</span>);<br>System.out.println(set1); <span class="hljs-comment">//[a,b,c,d,e,f,g]</span><br></code></pre></td></tr></table></figure><p>如果往TreeSet集合中存储自定义类型的元素，比如说Student类型，则需要我们自己指定排序规则，否则会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建TreeSet集合，元素为Student类型</span><br>Set&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br><br><span class="hljs-comment">//创建4个Student对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>,<span class="hljs-number">20</span>, <span class="hljs-number">169.6</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.8</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.6</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;牛魔王&quot;</span>,<span class="hljs-number">48</span>, <span class="hljs-number">169.6</span>);<br><br><span class="hljs-comment">//添加Studnet对象到集合</span><br>students.add(s1);<br>students.add(s2);<br>students.add(s3);<br>students.add(s4);<br>System.out.println(students); <br></code></pre></td></tr></table></figure><p>此时运行代码，会直接报错。原因是TreeSet不知道按照什么条件对Student对象来排序。</p><p><img src="/assets/1666172629095-1667311889347.png" alt="1666172629095"></p><p>我们想要告诉TreeSet集合按照指定的规则排序，有两种办法：</p><blockquote><p>第一种：让元素的类实现Comparable接口，重写compareTo方法</p></blockquote><blockquote><p>第二种：在创建TreeSet集合时，通过构造方法传递Compartor比较器对象</p></blockquote><ul><li><strong>排序方式1：</strong>我们先来演示第一种排序方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一步：先让Student类，实现Comparable接口</span><br><span class="hljs-comment">//注意：Student类的对象是作为TreeSet集合的元素的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br><span class="hljs-comment">//无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//全参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">double</span> height)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>        <span class="hljs-built_in">this</span>.height=height;<br>    &#125;<br>    <span class="hljs-comment">//...get、set、toString()方法自己补上..</span><br>    <br>    <span class="hljs-comment">//第二步：重写compareTo方法</span><br>    <span class="hljs-comment">//按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    原理：</span><br><span class="hljs-comment">    在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的</span><br><span class="hljs-comment">    结果是正数、负数、还是零，决定元素放在后面、前面还是不存。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>        <span class="hljs-comment">//this：表示将要添加进去的Student对象</span><br>        <span class="hljs-comment">//o: 表示集合中已有的Student对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age-o.age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，再运行测试类，结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Student&#123;name=<span class="hljs-string">&#x27;至尊宝&#x27;</span>, age=<span class="hljs-number">20</span>, height=<span class="hljs-number">169.6</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;紫霞&#x27;</span>, age=<span class="hljs-number">20</span>, height=<span class="hljs-number">169.8</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;蜘蛛精&#x27;</span>, age=<span class="hljs-number">23</span>, height=<span class="hljs-number">169.6</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;牛魔王&#x27;</span>, age=<span class="hljs-number">48</span>, height=<span class="hljs-number">169.6</span>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>排序方式2：</strong>接下来演示第二种排序方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建TreeSet集合时，传递比较器对象排序</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">原理：当调用add方法时，底层会先用比较器，根据Comparator的compare方是正数、负数、还是零，决定谁在后，谁在前，谁不存。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//下面代码中是按照学生的年龄升序排序</span><br>Set&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span>&#123;<br>        <span class="hljs-comment">//需求：按照学生的身高排序</span><br>        <span class="hljs-keyword">return</span> Double.compare(o1,o2); <br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//创建4个Student对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>,<span class="hljs-number">20</span>, <span class="hljs-number">169.6</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.8</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>,<span class="hljs-number">23</span>, <span class="hljs-number">169.6</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;牛魔王&quot;</span>,<span class="hljs-number">48</span>, <span class="hljs-number">169.6</span>);<br><br><span class="hljs-comment">//添加Studnet对象到集合</span><br>students.add(s1);<br>students.add(s2);<br>students.add(s3);<br>students.add(s4);<br>System.out.println(students); <br></code></pre></td></tr></table></figure><h3 id="1-6-总结Collection集合"><a href="#1-6-总结Collection集合" class="headerlink" title="1.6 总结Collection集合"></a>1.6 总结Collection集合</h3><p>最后，将所有的Collection集合总结一下，要求大家掌握每一种集合的特点，以及他们的体系结构。</p><p><img src="/assets/1666174020172-1667311882030.png" alt="1666174020172"></p><p>好了，关于Collection集合，到这里就学习完了。</p><h3 id="1-7-并发修改异常"><a href="#1-7-并发修改异常" class="headerlink" title="1.7 并发修改异常"></a>1.7 并发修改异常</h3><p>学完Collection集合后，还有一个小问题需要给同学们补充说明一下，那就是在使用迭代器遍历集合时，可能存在并发修改异常。</p><p>我们先把这个异常用代码演示出来，再解释一下为什么会有这个异常产生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;王麻子&quot;</span>);<br>list.add(<span class="hljs-string">&quot;小李子&quot;</span>);<br>list.add(<span class="hljs-string">&quot;李爱花&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张全蛋&quot;</span>);<br>list.add(<span class="hljs-string">&quot;晓李&quot;</span>);<br>list.add(<span class="hljs-string">&quot;李玉刚&quot;</span>);<br>System.out.println(list); <span class="hljs-comment">// [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</span><br><br><span class="hljs-comment">//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除</span><br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> it.next();<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;李&quot;</span>))&#123;<br>        list.remove(name);<br>    &#125;<br>&#125;<br>System.out.println(list);<br></code></pre></td></tr></table></figure><p>运行上面的代码，会出现下面的异常。这就是并发修改异常</p><p><img src="/assets/1666174432223-1667311876805.png" alt="1666174432223"></p><p>为什么会出现这个异常呢？那是因为迭代器遍历机制，规定迭代器遍历集合的同时，不允许集合自己去增删元素，否则就会出现这个异常。</p><p>怎么解决这个问题呢？不使用集合的删除方法，而是使用迭代器的删除方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;王麻子&quot;</span>);<br>list.add(<span class="hljs-string">&quot;小李子&quot;</span>);<br>list.add(<span class="hljs-string">&quot;李爱花&quot;</span>);<br>list.add(<span class="hljs-string">&quot;张全蛋&quot;</span>);<br>list.add(<span class="hljs-string">&quot;晓李&quot;</span>);<br>list.add(<span class="hljs-string">&quot;李玉刚&quot;</span>);<br>System.out.println(list); <span class="hljs-comment">// [王麻子, 小李子, 李爱花, 张全蛋, 晓李, 李玉刚]</span><br><br><span class="hljs-comment">//需求：找出集合中带&quot;李&quot;字的姓名，并从集合中删除</span><br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> it.next();<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;李&quot;</span>))&#123;<br>        <span class="hljs-comment">//list.remove(name);</span><br>        it.remove(); <span class="hljs-comment">//当前迭代器指向谁，就删除谁</span><br>    &#125;<br>&#125;<br>System.out.println(list);<br></code></pre></td></tr></table></figure><h2 id="二、Collection的其他操作"><a href="#二、Collection的其他操作" class="headerlink" title="二、Collection的其他操作"></a>二、Collection的其他操作</h2><p>各位同学，前面我们已经把Collection家族的集合都学习完了。为了更加方便的对Collection集合进行操作，今天我们还要学习一个操作Collection集合的工具类，叫做Collections。但是Collections工具类中需要用到一个没有学过的小知识点，叫做可变参数，所以必须先学习这个前置知识可变参数，再学习Collections工具类，最后再利用这个工具类做一个综合案例。</p><h3 id="2-1-可变参数"><a href="#2-1-可变参数" class="headerlink" title="2.1 可变参数"></a>2.1 可变参数</h3><p>首先，我们来学习一下可变参数。关于可变参数我们首先要知道它是什么，然后要知道它的本质。搞清楚这两个问题，可变参数就算你学明白了。</p><blockquote><ul><li><p><strong>可变参数是一种特殊的形式参数，定义在方法、构造器的形参列表处，它可以让方法接收多个同类型的实际参数。</strong></p></li><li><p><strong>可变参数在方法内部，本质上是一个数组</strong></p></li></ul></blockquote><p>接下来，我们编写代码来演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParamTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//不传递参数，下面的nums长度则为0, 打印元素是[]</span><br>        test();<br>        <br>        <span class="hljs-comment">//传递3个参数，下面的nums长度为3，打印元素是[10, 20, 30]</span><br>        test(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>); <br>        <br>        <span class="hljs-comment">//传递一个数组，下面数组长度为4，打印元素是[10,20,30,40] </span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>&#125;<br>        test(arr); <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span>...nums)</span>&#123;<br>        <span class="hljs-comment">//可变参数在方法内部，本质上是一个数组</span><br>        System.out.println(nums.length);<br>        System.out.println(Arrays.toString(nums));<br>        System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后还有一些错误写法，需要让大家写代码时注意一下，不要这么写哦！！！</p><blockquote><ul><li><p><strong>一个形参列表中，只能有一个可变参数；否则会报错</strong></p></li><li><p><strong>一个形参列表中如果多个参数，可变参数需要写在最后；否则会报错</strong></p></li></ul></blockquote><p><img src="/assets/1667194652653.png" alt="1667194652653"></p><p><img src="/assets/1667194696892.png" alt="1667194696892"></p><h3 id="2-2-Collections工具类"><a href="#2-2-Collections工具类" class="headerlink" title="2.2 Collections工具类"></a>2.2 Collections工具类</h3><p>有了可变参数的基础，我们再学习Collections这个工具类就好理解了，因为这个工具类的方法中会用到可变参数。</p><p>注意Collections并不是集合，它比Collection多了一个s，一般后缀为s的类很多都是工具类。这里的Collections是用来操作Collection的工具类。它提供了一些好用的静态方法，如下</p><p><img src="/assets/1667195108724.png" alt="1667195108724"></p><p>我们把这些方法用代码来演示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T...e)</span><br>        List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(names, <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;张麻子&quot;</span>);<br>        System.out.println(names);<br>        <br>        <span class="hljs-comment">//2.public static void shuffle(List&lt;?&gt; list)：对集合打乱顺序</span><br>        Collections.shuffle(names);<br>        System.out.println(names);<br>        <br>        <span class="hljs-comment">//3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">5</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面我们往集合中存储的元素要么是Stirng类型，要么是Integer类型，他们本来就有一种自然顺序所以可以直接排序。但是如果我们往List集合中存储Student对象，这个时候想要对List集合进行排序自定义比较规则的。指定排序规则有两种方式，如下：</p><blockquote><p><strong>排序方式1：让元素实现Comparable接口，重写compareTo方法</strong></p></blockquote><p>比如现在想要往集合中存储Studdent对象，首先需要准备一个Student类，实现Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br>    <br>     <span class="hljs-comment">//排序时：底层会自动调用此方法，this和o表示需要比较的两个对象</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span>&#123;<br>        <span class="hljs-comment">//需求：按照年龄升序排序</span><br>        <span class="hljs-comment">//如果返回正数：说明左边对象的年龄&gt;右边对象的年龄</span><br>        <span class="hljs-comment">//如果返回负数：说明左边对象的年龄&lt;右边对象的年龄，</span><br>        <span class="hljs-comment">//如果返回0：说明左边对象的年龄和右边对象的年龄相同</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - o.age;<br>    &#125;<br>    <br>    <span class="hljs-comment">//...getter、setter、constructor..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后再使用<code>Collections.sort(list集合)</code>对List集合排序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序</span><br>List&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-number">169.7</span>));<br>students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>,<span class="hljs-number">22</span>,<span class="hljs-number">169.8</span>));<br>students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>,<span class="hljs-number">22</span>,<span class="hljs-number">169.8</span>));<br>students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>,<span class="hljs-number">26</span>,<span class="hljs-number">169.5</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较；</span><br><span class="hljs-comment">每次比较时，会用一个Student对象调用compareTo方法和另一个Student对象进行比较；</span><br><span class="hljs-comment">根据compareTo方法返回的结果是正数、负数，零来决定谁大，谁小，谁相等，重新排序元素的位置</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意：这些都是sort方法底层自动完成的，想要完全理解，必须要懂排序算法才行；</span><br><span class="hljs-comment">*/</span><br>Collections.sort(students);<br>System.out.println(students);<br></code></pre></td></tr></table></figure><blockquote><p><strong>排序方式2：使用调用sort方法是，传递比较器</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较；</span><br><span class="hljs-comment">每次比较，会将比较的两个元素传递给Comparator比较器对象的compare方法的两个参数o1和o2,</span><br><span class="hljs-comment">根据compare方法的返回结果是正数，负数，或者0来决定谁大，谁小，谁相等，重新排序元素的位置</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意：这些都是sort方法底层自动完成的，不需要我们完全理解，想要理解它必须要懂排序算法才行.</span><br><span class="hljs-comment">*/</span><br>Collections.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span>&#123;<br>        <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>    &#125;<br>&#125;);<br>System.out.println(students);<br></code></pre></td></tr></table></figure><h3 id="2-3-斗地主案例"><a href="#2-3-斗地主案例" class="headerlink" title="2.3 斗地主案例"></a>2.3 斗地主案例</h3><p><img src="/assets/1667306432458.png" alt="1667306432458"></p><p>我们先分析一下业务需求：</p><ul><li>总共有54张牌，每一张牌有花色和点数两个属性、为了排序还可以再加一个序号</li><li>点数可以是：<code>“3”,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;</code></li><li>花色可以是：<code>“♣”,&quot;♠&quot;,&quot;♥&quot;,&quot;♦&quot;</code></li><li>斗地主时：三个玩家没人手里17张牌，剩余3张牌作为底牌</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">第一步：为了表示每一张牌有哪些属性，首先应该新建一个扑克牌的类<br>第二步：启动游戏时，就应该提前准备好<span class="hljs-number">54</span>张牌<br>第三步：接着再完全洗牌、发牌、捋牌、看牌的业务逻辑<br></code></pre></td></tr></table></figure><blockquote><p><strong>先来完成第一步，定义一个扑克类Card</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span> &#123;<br>    <span class="hljs-keyword">private</span> String number;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-comment">// 每张牌是存在大小的。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// 0 1 2 ....</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Card</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Card</span><span class="hljs-params">(String number, String color, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumber</span><span class="hljs-params">(String number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> color + number ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>再完成第二步，定义一个房间类，初始化房间时准备好54张牌</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-comment">// 必须有一副牌。</span><br>    <span class="hljs-keyword">private</span> List&lt;Card&gt; allCards = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Room</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 1、做出54张牌，存入到集合allCards</span><br>        <span class="hljs-comment">// a、点数：个数确定了，类型确定。</span><br>        String[] numbers = &#123;<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>&#125;;<br>        <span class="hljs-comment">// b、花色：个数确定了，类型确定。</span><br>        String[] colors = &#123;<span class="hljs-string">&quot;♠&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♦&quot;</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示每张牌的大小</span><br>        <span class="hljs-comment">// c、遍历点数，再遍历花色，组织牌</span><br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-comment">// number = &quot;3&quot;</span><br>            size++; <span class="hljs-comment">// 1 2 ....</span><br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                <span class="hljs-comment">// 得到一张牌</span><br>                <span class="hljs-type">Card</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(number, color, size);<br>                allCards.add(c); <span class="hljs-comment">// 存入了牌</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 单独存入小大王的。</span><br>        <span class="hljs-type">Card</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&quot;&quot;</span>,  <span class="hljs-string">&quot;🃏&quot;</span> , ++size);<br>        <span class="hljs-type">Card</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;👲&quot;</span> , ++size);<br>        Collections.addAll(allCards, c1, c2);<br>        System.out.println(<span class="hljs-string">&quot;新牌：&quot;</span> + allCards);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>最后完成第三步，定义一个启动游戏的方法，完成洗牌、发牌、捋牌、看牌的业务逻辑</strong></p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 游戏启动</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1、洗牌： allCards</span><br>    Collections.shuffle(allCards);<br>    System.out.println(<span class="hljs-string">&quot;洗牌后：&quot;</span> + allCards);<br><br>    <span class="hljs-comment">// 2、发牌，首先肯定要定义 三个玩家。 List(ArrayList)  Set(TreeSet)</span><br>    List&lt;Card&gt; linHuChong = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Card&gt; jiuMoZhi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Card&gt; renYingYing = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 正式发牌给这三个玩家，依次发出51张牌，剩余3张做为底牌。</span><br>    <span class="hljs-comment">// allCards = [♥3, ♣10, ♣4, ♥K, ♦Q, ♣2, 🃏, ♣8, ....</span><br>    <span class="hljs-comment">//             0     1   2   3   4   5   6 ...   % 3</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; allCards.size() - <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-type">Card</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> allCards.get(i);<br>        <span class="hljs-comment">// 判断牌发给谁</span><br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 请啊冲接牌</span><br>            linHuChong.add(c);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 请啊鸠来接牌</span><br>            jiuMoZhi.add(c);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">// 请盈盈接牌</span><br>            renYingYing.add(c);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3、对3个玩家的牌进行排序</span><br>    sortCards(linHuChong);<br>    sortCards(jiuMoZhi);<br>    sortCards(renYingYing);<br>    <span class="hljs-comment">// 4、看牌</span><br>    System.out.println(<span class="hljs-string">&quot;啊冲：&quot;</span> + linHuChong);<br>    System.out.println(<span class="hljs-string">&quot;啊鸠：&quot;</span> + jiuMoZhi);<br>    System.out.println(<span class="hljs-string">&quot;盈盈：&quot;</span> + renYingYing);<br>    List&lt;Card&gt; lastThreeCards = allCards.subList(allCards.size() - <span class="hljs-number">3</span>, allCards.size()); <span class="hljs-comment">// 51 52 53</span><br>    System.out.println(<span class="hljs-string">&quot;底牌：&quot;</span> + lastThreeCards);<br>    jiuMoZhi.addAll(lastThreeCards);<br>    sortCards(jiuMoZhi);<br>    System.out.println(<span class="hljs-string">&quot;啊鸠抢到地主后：&quot;</span> + jiuMoZhi);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 集中进行排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cards</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortCards</span><span class="hljs-params">(List&lt;Card&gt; cards)</span> &#123;<br>    Collections.sort(cards, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Card&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Card o1, Card o2)</span> &#123;<br>            <span class="hljs-comment">// return o1.getSize() - o2.getSize(); // 升序排序</span><br>            <span class="hljs-keyword">return</span> o2.getSize() - o1.getSize(); <span class="hljs-comment">// 降序排序</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>不要忘记了写测试类了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//  1、牌类。</span><br>        <span class="hljs-comment">//  2、房间</span><br>        <span class="hljs-type">Room</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-comment">//  3、启动游戏</span><br>        m.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、Map集合"><a href="#三、Map集合" class="headerlink" title="三、Map集合"></a>三、Map集合</h2><h3 id="3-1-Map概述体系"><a href="#3-1-Map概述体系" class="headerlink" title="3.1 Map概述体系"></a>3.1 Map概述体系</h3><p>各位同学，前面我们已经把单列集合学习完了，接下来我们要学习的是双列集合。首先我们还是先认识一下什么是双列集合。</p><p>所谓双列集合，就是说集合中的元素是一对一对的。Map集合中的每一个元素是以<code>key=value</code>的形式存在的，一个<code>key=value</code>就称之为一个键值对，而且在Java中有一个类叫Entry类，Entry的对象用来表示键值对对象。</p><p>所有的Map集合有如下的特点：<strong>键不能重复，值可以重复，每一个键只能找到自己对应的值。</strong></p><p><img src="/assets/1667308368751.png" alt="1667308368751"></p><p>下面我们先写一个Map集合，保存几个键值对，体验一下Map集合的特点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 一行经典代码。 按照键 无序，不重复，无索引。</span><br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(); <span class="hljs-comment">// 有序，不重复，无索引。</span><br>        map.put(<span class="hljs-string">&quot;手表&quot;</span>, <span class="hljs-number">100</span>);<br>        map.put(<span class="hljs-string">&quot;手表&quot;</span>, <span class="hljs-number">220</span>); <span class="hljs-comment">// 后面重复的数据会覆盖前面的数据（键）</span><br>        map.put(<span class="hljs-string">&quot;手机&quot;</span>, <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        System.out.println(map);<br><br>        Map&lt;Integer, String&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(); <span class="hljs-comment">// 可排序，不重复，无索引</span><br>        map1.put(<span class="hljs-number">23</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        map1.put(<span class="hljs-number">23</span>, <span class="hljs-string">&quot;MySQL&quot;</span>);<br>        map1.put(<span class="hljs-number">19</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        map1.put(<span class="hljs-number">20</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>        System.out.println(map1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Map集合也有很多种，在Java中使用不同的类来表示的，每一种Map集合其键的特点是有些差异的，值是键的一个附属值，所以我们只关注键的特点就可以了。</p><p><img src="/assets/1667308506610.png" alt="1667308506610"></p><p>关于Map集合是什么，以及Map集合的体系我们先了解到这里，接下来就具体学习一下Map集合的通用方法。</p><h3 id="3-2-Map集合的常用方法"><a href="#3-2-Map集合的常用方法" class="headerlink" title="3.2 Map集合的常用方法"></a>3.2 Map集合的常用方法</h3><p>各位同学，上节课我们已经认识了Map集合，接下来我们学习一下Map集合提供了那些方法供我们使用。由于Map是所有双列集合的父接口，所以我们只需要学习Map接口中每一个方法是什么含义，那么所有的Map集合方法你就都会用了。</p><p><img src="/assets/1667308854001.png" alt="1667308854001"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.添加元素: 无序，不重复，无索引。</span><br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;手表&quot;</span>, <span class="hljs-number">100</span>);<br>        map.put(<span class="hljs-string">&quot;手表&quot;</span>, <span class="hljs-number">220</span>);<br>        map.put(<span class="hljs-string">&quot;手机&quot;</span>, <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// map = &#123;null=null, 手表=220, Java=2, 手机=2&#125;</span><br><br>        <span class="hljs-comment">// 2.public int size():获取集合的大小</span><br>        System.out.println(map.size());<br><br>        <span class="hljs-comment">// 3、public void clear():清空集合</span><br>        <span class="hljs-comment">//map.clear();</span><br>        <span class="hljs-comment">//System.out.println(map);</span><br><br>        <span class="hljs-comment">// 4.public boolean isEmpty(): 判断集合是否为空，为空返回true ,反之！</span><br>        System.out.println(map.isEmpty());<br><br>        <span class="hljs-comment">// 5.public V get(Object key)：根据键获取对应值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;手表&quot;</span>);<br>        System.out.println(v1);<br>        System.out.println(map.get(<span class="hljs-string">&quot;手机&quot;</span>)); <span class="hljs-comment">// 2</span><br>        System.out.println(map.get(<span class="hljs-string">&quot;张三&quot;</span>)); <span class="hljs-comment">// null</span><br><br>        <span class="hljs-comment">// 6. public V remove(Object key)：根据键删除整个元素(删除键会返回键的值)</span><br>        System.out.println(map.remove(<span class="hljs-string">&quot;手表&quot;</span>));<br>        System.out.println(map);<br><br>        <span class="hljs-comment">// 7.public  boolean containsKey(Object key): 判断是否包含某个键 ，包含返回true ,反之</span><br>        System.out.println(map.containsKey(<span class="hljs-string">&quot;手表&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(map.containsKey(<span class="hljs-string">&quot;手机&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(map.containsKey(<span class="hljs-string">&quot;java&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(map.containsKey(<span class="hljs-string">&quot;Java&quot;</span>)); <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// 8.public boolean containsValue(Object value): 判断是否包含某个值。</span><br>        System.out.println(map.containsValue(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(map.containsValue(<span class="hljs-string">&quot;2&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// 9.public Set&lt;K&gt; keySet(): 获取Map集合的全部键。</span><br>        Set&lt;String&gt; keys = map.keySet();<br>        System.out.println(keys);<br><br>        <span class="hljs-comment">// 10.public Collection&lt;V&gt; values(); 获取Map集合的全部值。</span><br>        Collection&lt;Integer&gt; values = map.values();<br>        System.out.println(values);<br><br>        <span class="hljs-comment">// 11.把其他Map集合的数据倒入到自己集合中来。(拓展)</span><br>        Map&lt;String, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map1.put(<span class="hljs-string">&quot;java1&quot;</span>,  <span class="hljs-number">10</span>);<br>        map1.put(<span class="hljs-string">&quot;java2&quot;</span>,  <span class="hljs-number">20</span>);<br>        Map&lt;String, Integer&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(<span class="hljs-string">&quot;java3&quot;</span>,  <span class="hljs-number">10</span>);<br>        map2.put(<span class="hljs-string">&quot;java2&quot;</span>,  <span class="hljs-number">222</span>);<br>        map1.putAll(map2); <span class="hljs-comment">// putAll：把map2集合中的元素全部倒入一份到map1集合中去。</span><br>        System.out.println(map1);<br>        System.out.println(map2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Map集合遍历方式1"><a href="#3-3-Map集合遍历方式1" class="headerlink" title="3.3 Map集合遍历方式1"></a>3.3 Map集合遍历方式1</h3><p>Map集合一共有三种遍历方式，我们先来学习第一种，他需要用到下面的两个方法</p><p><img src="/assets/1667308962740.png" alt="1667308962740"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标：掌握Map集合的遍历方式1：键找值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 准备一个Map集合。</span><br>        Map&lt;String, Double&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">162.5</span>);<br>        map.put(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">169.8</span>);<br>        map.put(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">165.8</span>);<br>        map.put(<span class="hljs-string">&quot;至尊宝&quot;</span>, <span class="hljs-number">169.5</span>);<br>        map.put(<span class="hljs-string">&quot;牛魔王&quot;</span>, <span class="hljs-number">183.6</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span><br><br>        <span class="hljs-comment">// 1、获取Map集合的全部键</span><br>        Set&lt;String&gt; keys = map.keySet();<br>        <span class="hljs-comment">// System.out.println(keys);</span><br>        <span class="hljs-comment">// [蜘蛛精, 牛魔王, 至尊宝, 紫霞]</span><br>        <span class="hljs-comment">//         key</span><br>        <span class="hljs-comment">// 2、遍历全部的键，根据键获取其对应的值</span><br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            <span class="hljs-comment">// 根据键获取对应的值</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>            System.out.println(key + <span class="hljs-string">&quot;=====&gt;&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-Map集合遍历方式2"><a href="#3-4-Map集合遍历方式2" class="headerlink" title="3.4 Map集合遍历方式2"></a>3.4 Map集合遍历方式2</h3><p>各位同学，接下来我们学习Map集合的第二种遍历方式，这种遍历方式更加符合面向对象的思维。</p><p>前面我们给大家介绍过，Map集合是用来存储键值对的，而每一个键值对实际上是一个Entry对象。</p><p><strong>这里Map集合的第二种方式，是直接获取每一个Entry对象，把Entry存储扫Set集合中去，再通过Entry对象获取键和值。</strong></p><p><img src="/assets/1667309587178.png" alt="1667309587178"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握Map集合的第二种遍历方式：键值对。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Double&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">169.8</span>);<br>        map.put(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">165.8</span>);<br>        map.put(<span class="hljs-string">&quot;至尊宝&quot;</span>, <span class="hljs-number">169.5</span>);<br>        map.put(<span class="hljs-string">&quot;牛魔王&quot;</span>, <span class="hljs-number">183.6</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span><br>        <span class="hljs-comment">// entries = [(蜘蛛精=169.8), (牛魔王=183.6), (至尊宝=169.5), (紫霞=165.8)]</span><br>        <span class="hljs-comment">// entry = (蜘蛛精=169.8)</span><br>        <span class="hljs-comment">// entry = (牛魔王=183.6)</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合</span><br>        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : entries) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>            System.out.println(key + <span class="hljs-string">&quot;----&gt;&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-Map集合遍历方式3"><a href="#3-5-Map集合遍历方式3" class="headerlink" title="3.5 Map集合遍历方式3"></a>3.5 Map集合遍历方式3</h3><p>Map集合的第三种遍历方式，需要用到下面的一个方法forEach，而这个方法是JDK8版本以后才有的。调用起来非常简单，最好是结合的lambda表达式一起使用。</p><p><img src="/assets/1667309230571.png" alt="1667309230571"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握Map集合的第二种遍历方式：键值对。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Double&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">169.8</span>);<br>        map.put(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">165.8</span>);<br>        map.put(<span class="hljs-string">&quot;至尊宝&quot;</span>, <span class="hljs-number">169.5</span>);<br>        map.put(<span class="hljs-string">&quot;牛魔王&quot;</span>, <span class="hljs-number">183.6</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span><br><br><br><span class="hljs-comment">//遍历map集合，传递匿名内部类</span><br>        map.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BiConsumer</span>&lt;String, Double&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String k, Double v)</span> &#123;<br>                System.out.println(k + <span class="hljs-string">&quot;----&gt;&quot;</span> + v);<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//遍历map集合，传递Lambda表达式</span><br>        map.forEach(( k,  v) -&gt; &#123;<br>            System.out.println(k + <span class="hljs-string">&quot;----&gt;&quot;</span> + v);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-Map集合案例"><a href="#3-6-Map集合案例" class="headerlink" title="3.6 Map集合案例"></a>3.6 Map集合案例</h3><p>学习完Map集合的基本用法之后，接下来我们做一个综合案例，将Map集合运用一下。</p><p><img src="/assets/1667311182716.png" alt="1667311182716"></p><p>先分析需求，再考虑怎么用代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先可以将<span class="hljs-number">80</span>个学生选择的景点放到一个集合中去（也就是说，集合中的元素是<span class="hljs-number">80</span>个任意的ABCD元素）<br><span class="hljs-number">2.</span>准备一个Map集合用来存储景点，以及景点被选择的次数<br><span class="hljs-number">3.</span>遍历<span class="hljs-number">80</span>个学生选择景点的集合，得到每一个景点，判断Map集合中是否包含该景点<br>如果不包含，则存储<span class="hljs-string">&quot;景点=1&quot;</span><br>    如果包含，则存获取该景点原先的值，再存储<span class="hljs-string">&quot;景点=原来的值+1&quot;</span>; 此时新值会覆盖旧值<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：完成Map集合的案例：统计投票人数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、把80个学生选择的景点数据拿到程序中来。</span><br>        List&lt;String&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        String[] selects = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">80</span>; i++) &#123;<br>            <span class="hljs-comment">// 每次模拟一个学生选择一个景点，存入到集合中去。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">4</span>); <span class="hljs-comment">// 0 1 2 3</span><br>            data.add(selects[index]);<br>        &#125;<br>        System.out.println(data);<br><br>        <span class="hljs-comment">// 2、开始统计每个景点的投票人数</span><br>        <span class="hljs-comment">// 准备一个Map集合用于统计最终的结果</span><br>        Map&lt;String, Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 3、开始遍历80个景点数据</span><br>        <span class="hljs-keyword">for</span> (String s : data) &#123;<br>            <span class="hljs-comment">// 问问Map集合中是否存在该景点</span><br>            <span class="hljs-keyword">if</span>(result.containsKey(s))&#123;<br>                <span class="hljs-comment">// 说明这个景点之前统计过。其值+1. 存入到Map集合中去</span><br>                result.put(s, result.get(s) + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 说明这个景点是第一次统计，存入&quot;景点=1&quot;</span><br>                result.put(s, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day06--%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/"/>
    <url>/2023/12/01/day06--%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="day06—集合进阶（异常、集合）"><a href="#day06—集合进阶（异常、集合）" class="headerlink" title="day06—集合进阶（异常、集合）"></a>day06—集合进阶（异常、集合）</h1><h2 id="一、异常"><a href="#一、异常" class="headerlink" title="一、异常"></a>一、异常</h2><h3 id="1-1-认识异常"><a href="#1-1-认识异常" class="headerlink" title="1.1 认识异常"></a>1.1 认识异常</h3><p>接下来，我们学习一下异常，学习异常有利于我们处理程序中可能出现的问题。我先带着同学们认识一下，什么是异常？</p><p>我们阅读下面的代码，通过这段代码来认识异常。 我们调用一个方法时，经常一部小心就出异常了，然后在控制台打印一些异常信息。其实打印的这些异常信息，就叫做异常。</p><p>那肯定有同学就纳闷了，我写代码天天出异常，我知道这是异常啊！我们这里学习异常，其实是为了告诉你异常是怎么产生的？只有你知道异常是如何产生的，才能避免出现异常。以及产生异常之后如何处理。</p><p><img src="/assets/1667312695257.png" alt="1667312695257"></p><p>因为写代码时经常会出现问题，Java的设计者们早就为我们写好了很多个异常类，来描述不同场景下的问题。而有些类是有共性的所以就有了异常的继承体系</p><p><img src="/assets/1667313423356.png" alt="1667313423356"></p><blockquote><p><strong>先来演示一个运行时异常产生</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>&#125;;<br><span class="hljs-comment">//5是一个不存在的索引，所以此时产生ArrayIndexOutOfBoundsExcpetion</span><br>System.out.println(arr[<span class="hljs-number">5</span>]); <br></code></pre></td></tr></table></figure><p>下图是API中对ArrayIndexOutOfBoundsExcpetion类的继承体系，以及告诉我们它在什么情况下产生。</p><p><img src="/assets/1667313567748.png" alt="1667313567748"></p><blockquote><p><strong>再来演示一个编译时异常</strong></p></blockquote><p>我们在调用SimpleDateFormat对象的parse方法时，要求传递的参数必须和指定的日期格式一致，否则就会出现异常。 Java比较贴心，它为了更加强烈的提醒方法的调用者，设计了编译时异常，它把异常的提醒提前了，你调用方法是否真的有问题，只要可能有问题就给你报出异常提示（红色波浪线）。</p><p> <strong>编译时异常的目的：意思就是告诉你，你小子注意了！！，这里小心点容易出错，仔细检查一下</strong></p><p><img src="/assets/1667313705048.png" alt="1667313705048"></p><p>有人说，我检查过了，我确认我的代码没问题，为了让它不报错，继续将代码写下去。我们这里有两种解决方案。</p><ul><li>第一种：使用throws在方法上声明，意思就是告诉下一个调用者，这里面可能有异常啊，你调用时注意一下。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：认识异常。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException&#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;2028-11-11 10:24&quot;</span>);<br>        System.out.println(d);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二种：使用try…catch语句块异常进行处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>            <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;2028-11-11 10:24&quot;</span>);<br>            System.out.println(d);<br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，关于什么是异常，我们就先认识到这里。</p><h3 id="1-2-自定义异常"><a href="#1-2-自定义异常" class="headerlink" title="1.2 自定义异常"></a>1.2 自定义异常</h3><p>同学们经过刚才的学习已经认识了什么是异常了，但是无法为这个世界上的全部问题都提供异常类，如果企业自己的某种问题，想通过异常来表示，那就需要自己来定义异常类了。</p><p>我们通过一个实际场景，来给大家演示自定义异常。</p><blockquote><p>需求：写一个saveAge(int age)方法，在方法中对参数age进行判断，如果age&lt;0或者&gt;&#x3D;150就认为年龄不合法，如果年龄不合法，就给调用者抛出一个年龄非法异常。</p><p>分析：Java的API中是没有年龄非常这个异常的，所以我们可以自定义一个异常类，用来表示年龄非法异常，然后再方法中抛出自定义异常即可。</p></blockquote><ul><li>先写一个异常类AgeIllegalException（这是自己取的名字，名字取得很奈斯），继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、必须让这个类继承自Exception，才能成为一个编译时异常类。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>再写一个测试类，在测试类中定义一个saveAge(int age)方法，对age判断如果年龄不在0~150之间，就抛出一个AgeIllegalException异常对象给调用者。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 需求：保存一个合法的年</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            saveAge2(<span class="hljs-number">225</span>);<br>            System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是成功的！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (AgeIllegalException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是出现bug的！&quot;</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//2、在方法中对age进行判断，不合法则抛出AgeIllegalException</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt; <span class="hljs-number">150</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;年龄被成功保存： &quot;</span> + age);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 用一个异常对象封装这个问题</span><br>            <span class="hljs-comment">// throw 抛出去这个异常对象</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeIllegalRuntimeException</span>(<span class="hljs-string">&quot;/age is illegal, your age is &quot;</span> + age);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意咯，自定义异常可能是编译时异常，也可以是运行时异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>如果自定义异常类继承Excpetion，则是编译时异常。<br>特点：方法中抛出的是编译时异常，必须在方法上使用<span class="hljs-keyword">throws</span>声明，强制调用者处理。<br><br><span class="hljs-number">2.</span>如果自定义异常类继承RuntimeException，则运行时异常。<br>特点：方法中抛出的是运行时异常，不需要在方法上用<span class="hljs-keyword">throws</span>声明。<br></code></pre></td></tr></table></figure><h3 id="1-3-异常处理"><a href="#1-3-异常处理" class="headerlink" title="1.3 异常处理"></a>1.3 异常处理</h3><p>同学们，通过前面两小节的学习，我们已经认识了什么是异常，以及异常的产生过程。接下来就需要告诉同学们，出现异常该如何处理了。</p><p>比如有如下的场景：A调用用B，B调用C；C中有异常产生抛给B，B中有异常产生又抛给A；异常到了A这里就不建议再抛出了，因为最终抛出被JVM处理程序就会异常终止，并且给用户看异常信息，用户也看不懂，体验很不好。</p><p>此时比较好的做法就是：1.将异常捕获，将比较友好的信息显示给用户看；2.尝试重新执行，看是是否能修复这个问题。</p><p><img src="/assets/1667315686041.png" alt="1667315686041"></p><p>我们看一个代码，main方法调用test1方法，test1方法调用test2方法，test1和test2方法中多有扔异常。</p><ul><li>第一种处理方式是，在main方法中对异常进行try…catch捕获处理了，给出友好提示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            test1();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;您要找的文件不存在！！&quot;</span>);<br>            e.printStackTrace(); <span class="hljs-comment">// 打印出这个异常对象的信息。记录下来。</span><br>        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;您要解析的时间有问题了！&quot;</span>);<br>            e.printStackTrace(); <span class="hljs-comment">// 打印出这个异常对象的信息。记录下来。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException, ParseException &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;2028-11-11 10:24:11&quot;</span>);<br>        System.out.println(d);<br>        test2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">// 读取文件的。</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:/meinv.png&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二种处理方式是：在main方法中对异常进行捕获，并尝试修复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握异常的处理方式：捕获异常，尝试修复。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionTest4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 需求：调用一个方法，让用户输入一个合适的价格返回为止。</span><br>        <span class="hljs-comment">// 尝试修复</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(getMoney());<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请您输入合法的数字！！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请您输入合适的价格：&quot;</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> sc.nextDouble();<br>            <span class="hljs-keyword">if</span>(money &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> money;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;您输入的价格是不合适的！&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，到此我们关于异常的知识就全部学习完了</p><h2 id="二、集合概述和分类"><a href="#二、集合概述和分类" class="headerlink" title="二、集合概述和分类"></a>二、集合概述和分类</h2><h3 id="2-1-集合的分类"><a href="#2-1-集合的分类" class="headerlink" title="2.1 集合的分类"></a>2.1 集合的分类</h3><p>同学们，前面我们已经学习过了ArrayList集合，但是除了ArrayList集合，Java还提供了很多种其他的集合，如下图所示：</p><p><img src="/assets/1666154871520.png" alt="1666154871520"></p><p>我想你的第一感觉是这些集合好多呀！但是，我们学习时会对这些集合进行分类学习，如下图所示：一类是单列集合元素是一个一个的，另一类是双列集合元素是一对一对的。</p><p><img src="/assets/1666154948620.png" alt="1666154948620"></p><p>在今天的课程中，主要学习Collection单列集合。Collection是单列集合的根接口，Collection接口下面又有两个子接口List接口、Set接口，List和Set下面分别有不同的实现类，如下图所示：</p><p><img src="/assets/1666155169359.png" alt="1666155169359"></p><p>上图中各种集合的特点如下图所示：</p><p><img src="/assets/1666155218956.png" alt="1666155218956"></p><p>可以自己写代码验证一下，各种集合的特点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简单确认一下Collection集合的特点</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//存取顺序一致，可以重复，有索引</span><br>list.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>System.out.println(list); <span class="hljs-comment">//[java1, java2, java1, java2] </span><br><br>HashSet&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">//存取顺序不一致，不重复，无索引</span><br>list.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>list.add(<span class="hljs-string">&quot;java3&quot;</span>);<br>System.out.println(list); <span class="hljs-comment">//[java3, java2, java1] </span><br></code></pre></td></tr></table></figure><h3 id="2-2-Collection集合的常用方法"><a href="#2-2-Collection集合的常用方法" class="headerlink" title="2.2 Collection集合的常用方法"></a>2.2 Collection集合的常用方法</h3><p>接下来，我们学习一下Collection集合的一些常用方法，这些方法所有Collection实现类都可以使用。 这里我们以创建ArrayList为例，来演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//1.public boolean add(E e): 添加元素到集合</span><br>c.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>c.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>c.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>c.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>c.add(<span class="hljs-string">&quot;java3&quot;</span>);<br>System.out.println(c); <span class="hljs-comment">//打印: [java1, java1, java2, java2, java3]</span><br><br><span class="hljs-comment">//2.public int size(): 获取集合的大小</span><br>System.out.println(c.size()); <span class="hljs-comment">//5</span><br><br><span class="hljs-comment">//3.public boolean contains(Object obj): 判断集合中是否包含某个元素</span><br>System.out.println(c.contains(<span class="hljs-string">&quot;java1&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(c.contains(<span class="hljs-string">&quot;Java1&quot;</span>)); <span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//4.pubilc boolean remove(E e): 删除某个元素，如果有多个重复元素只能删除第一个</span><br>System.out.println(c.remove(<span class="hljs-string">&quot;java1&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(c); <span class="hljs-comment">//打印: [java1,java2, java2, java3]</span><br><br><span class="hljs-comment">//5.public void clear(): 清空集合的元素</span><br>c.clear(); <br>System.out.println(c); <span class="hljs-comment">//打印：[]</span><br><br><span class="hljs-comment">//6.public boolean isEmpty(): 判断集合是否为空 是空返回true 反之返回false</span><br>System.out.println(c.isEmpty()); <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//7.public Object[] toArray(): 把集合转换为数组</span><br>Object[] array = c.toArray();<br>System.out.println(Arrays.toString(array)); <span class="hljs-comment">//[java1,java2, java2, java3]</span><br><br><span class="hljs-comment">//8.如果想把集合转换为指定类型的数组，可以使用下面的代码</span><br>String[] array1 = c.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[c.size()]);<br>System.out.println(Arrays.toString(array1)); <span class="hljs-comment">//[java1,java2, java2, java3]</span><br><br><span class="hljs-comment">//9.还可以把一个集合中的元素，添加到另一个集合中</span><br>Collection&lt;String&gt; c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>c1.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>c1.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>Collection&lt;String&gt; c2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>c2.add(<span class="hljs-string">&quot;java3&quot;</span>);<br>c2.add(<span class="hljs-string">&quot;java4&quot;</span>);<br>c1.addAll(c2); <span class="hljs-comment">//把c2集合中的全部元素，添加到c1集合中去</span><br>System.out.println(c1); <span class="hljs-comment">//[java1, java2, java3, java4]</span><br></code></pre></td></tr></table></figure><p>最后，我们总结一下Collection集合的常用功能有哪些，ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet集合都可以调用下面的方法。</p><p><img src="/assets/1666158266534.png" alt="1666158266534"></p><h2 id="三、Collection遍历方式"><a href="#三、Collection遍历方式" class="headerlink" title="三、Collection遍历方式"></a>三、Collection遍历方式</h2><p>各位同学，接下来我们学习一下Collection集合的遍历方式。有同学说：“集合的遍历之前不是学过吗？就用普通的for循环啊? “  没错！之前是学过集合遍历，但是之前学习过的遍历方式，只能遍历List集合，不能遍历Set集合，因为以前的普通for循环遍历需要索引，只有List集合有索引，而Set集合没有索引。</p><p>所以我们需要有一种通用的遍历方式，能够遍历所有集合。</p><h3 id="3-1-迭代器遍历集合"><a href="#3-1-迭代器遍历集合" class="headerlink" title="3.1 迭代器遍历集合"></a>3.1 迭代器遍历集合</h3><p> 接下来学习的迭代器就是一种集合的通用遍历方式。</p><p>代码写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>c.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>c.add(<span class="hljs-string">&quot;小昭&quot;</span>);<br>c.add(<span class="hljs-string">&quot;素素&quot;</span>);<br>c.add(<span class="hljs-string">&quot;灭绝&quot;</span>);<br>System.out.println(c); <span class="hljs-comment">//[赵敏, 小昭, 素素, 灭绝]</span><br><br><span class="hljs-comment">//第一步：先获取迭代器对象</span><br><span class="hljs-comment">//解释：Iterator就是迭代器对象，用于遍历集合的工具)</span><br>Iterator&lt;String&gt; it = c.iterator();<br><br><span class="hljs-comment">//第二步：用于判断当前位置是否有元素可以获取</span><br><span class="hljs-comment">//解释：hasNext()方法返回true，说明有元素可以获取；反之没有</span><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-comment">//第三步：获取当前位置的元素，然后自动指向下一个元素.</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> it.next();<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器代码的原理如下：</p><ul><li>当调用iterator()方法获取迭代器时，当前指向第一个元素</li><li>hasNext()方法则判断这个位置是否有元素，如果有则返回true，进入循环</li><li>调用next()方法获取元素，并将当月元素指向下一个位置，</li><li>等下次循环时，则获取下一个元素，依此内推</li></ul><p><img src="/assets/1666162606524.png" alt="1666162606524"></p><p>最后，我们再总结一下，使用迭代器遍历集合用到哪些方法</p><p><img src="/assets/1666162899638.png" alt="1666162899638"></p><h3 id="3-2-增强for遍历集合"><a href="#3-2-增强for遍历集合" class="headerlink" title="3.2 增强for遍历集合"></a>3.2 增强for遍历集合</h3><p>同学们刚才我们学习了迭代器遍历集合，但是这个代码其实还有一种更加简化的写法，叫做增强for循环。</p><p>格式如下：</p><p><img src="/assets/1666163065998.png" alt="1666163065998"></p><p>需要注意的是，增强for不光可以遍历集合，还可以遍历数组。接下来我们用代码演示一em.o下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>c.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>c.add(<span class="hljs-string">&quot;小昭&quot;</span>);<br>c.add(<span class="hljs-string">&quot;素素&quot;</span>);<br>c.add(<span class="hljs-string">&quot;灭绝&quot;</span>);<br><br><span class="hljs-comment">//1.使用增强for遍历集合</span><br><span class="hljs-keyword">for</span>(String s: c)&#123;<br>    System.out.println(s); <br>&#125;<br><br><span class="hljs-comment">//2.再尝试使用增强for遍历数组</span><br>String[] arr = &#123;<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-string">&quot;稀奇哈哈&quot;</span>&#125;;<br><span class="hljs-keyword">for</span>(String name: arr)&#123;<br>    System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-forEach遍历集合"><a href="#3-3-forEach遍历集合" class="headerlink" title="3.3 forEach遍历集合"></a>3.3 forEach遍历集合</h3><p>在JDK8版本以后还提供了一个forEach方法也可以遍历集合，如果下图所示：</p><p><img src="/assets/1666163351517.png" alt="1666163351517"></p><p>我们发现forEach方法的参数是一个Consumer接口，而Consumer是一个函数式接口，所以可以传递Lambda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>c.add(<span class="hljs-string">&quot;赵敏&quot;</span>);<br>c.add(<span class="hljs-string">&quot;小昭&quot;</span>);<br>c.add(<span class="hljs-string">&quot;素素&quot;</span>);<br>c.add(<span class="hljs-string">&quot;灭绝&quot;</span>);<br><br><span class="hljs-comment">//调用forEach方法</span><br><span class="hljs-comment">//由于参数是一个Consumer接口，所以可以传递匿名内部类</span><br>c.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span>&#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;);<br><br><br><span class="hljs-comment">//也可以使用lambda表达式对匿名内部类进行简化</span><br>c.forEach(s-&gt;System.out.println(s)); <span class="hljs-comment">//[赵敏, 小昭, 素素, 灭绝]</span><br></code></pre></td></tr></table></figure><h3 id="3-4-遍历集合案例"><a href="#3-4-遍历集合案例" class="headerlink" title="3.4 遍历集合案例"></a>3.4 遍历集合案例</h3><p>接下来，我们看一个案例，在集合中存储自定义的对象，并遍历。具体要求如下</p><p><img src="/assets/1666164331639.png" alt="1666164331639"></p><p>首先，我们得写一个电影类，用来描述每一步电影应该有哪些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Movie</span>&#123;<br>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//电影名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> score; <span class="hljs-comment">//评分</span><br>    <span class="hljs-keyword">private</span> String actor; <span class="hljs-comment">//演员</span><br>    <span class="hljs-comment">//无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Movie</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//全参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Movie</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> score, String actor)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.score=score;<br>        <span class="hljs-built_in">this</span>.actor=actor;<br>    &#125;<br>    <span class="hljs-comment">//...get、set、toString()方法自己补上..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着，再创建一个测试类，完成上面的需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Collection&lt;Movie&gt; movies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        movies.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MOvie</span>(<span class="hljs-string">&quot;《肖申克的救赎》&quot;</span>, <span class="hljs-number">9.7</span>, <span class="hljs-string">&quot;罗宾斯&quot;</span>));<br>        movies.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MOvie</span>(<span class="hljs-string">&quot;《霸王别姬》&quot;</span>, <span class="hljs-number">9.6</span>, <span class="hljs-string">&quot;张国荣、张丰毅&quot;</span>));<br>        movies.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MOvie</span>(<span class="hljs-string">&quot;《阿甘正传》&quot;</span>, <span class="hljs-number">9.5</span>, <span class="hljs-string">&quot;汤姆汉克斯&quot;</span>));<br>        <br>        <span class="hljs-keyword">for</span>(Movie movie : movies)&#123;<br>            System.out.println(<span class="hljs-string">&quot;电影名：&quot;</span> + movie.getName());<br>            System.out.println(<span class="hljs-string">&quot;评分：&quot;</span> + movie.getScore());<br>            System.out.println(<span class="hljs-string">&quot;主演：&quot;</span> + movie.getActor());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的内存原理如下图所示：当往集合中存对象时，实际上存储的是对象的地址值</p><p><img src="/assets/1666165033103.png" alt="1666165033103"></p><h2 id="四、List系列集合"><a href="#四、List系列集合" class="headerlink" title="四、List系列集合"></a>四、List系列集合</h2><p>前面我们已经把Collection通用的功能学习完了，接下来我们学习Collection下面的一个子体系List集合。如下图所示：</p><p><img src="/assets/1666165150752.png" alt="1666165150752"></p><h3 id="4-1-List集合的常用方法"><a href="#4-1-List集合的常用方法" class="headerlink" title="4.1 List集合的常用方法"></a>4.1 List集合的常用方法</h3><p>List集合是索引的，所以多了一些有索引操作的方法，如下图所示：</p><p><img src="/assets/1666165187815.png" alt="1666165187815"></p><p>接下来，我们用代码演示一下这几个方法的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建一个ArrayList集合对象（有序、有索引、可以重复）</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;蜘蛛精&quot;</span>);<br>list.add(<span class="hljs-string">&quot;至尊宝&quot;</span>);<br>list.add(<span class="hljs-string">&quot;至尊宝&quot;</span>);<br>list.add(<span class="hljs-string">&quot;牛夫人&quot;</span>); <br>System.out.println(list); <span class="hljs-comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]</span><br><br><span class="hljs-comment">//2.public void add(int index, E element): 在某个索引位置插入元素</span><br>list.add(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;紫霞仙子&quot;</span>);<br>System.out.println(list); <span class="hljs-comment">//[蜘蛛精, 至尊宝, 紫霞仙子, 至尊宝, 牛夫人]</span><br><br><span class="hljs-comment">//3.public E remove(int index): 根据索引删除元素, 返回被删除的元素</span><br>System.out.println(list.remove(<span class="hljs-number">2</span>)); <span class="hljs-comment">//紫霞仙子</span><br>System.out.println(list);<span class="hljs-comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]</span><br><br><span class="hljs-comment">//4.public E get(int index): 返回集合中指定位置的元素</span><br>System.out.println(list.get(<span class="hljs-number">3</span>));<br><br><span class="hljs-comment">//5.public E set(int index, E e): 修改索引位置处的元素，修改后，会返回原数据</span><br>System.out.println(list.set(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;牛魔王&quot;</span>)); <span class="hljs-comment">//牛夫人</span><br>System.out.println(list); <span class="hljs-comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛魔王]</span><br></code></pre></td></tr></table></figure><h3 id="4-2-List集合的遍历方式"><a href="#4-2-List集合的遍历方式" class="headerlink" title="4.2 List集合的遍历方式"></a>4.2 List集合的遍历方式</h3><p>List集合相比于前面的Collection多了一种可以通过索引遍历的方式，所以List集合遍历方式一共有四种：</p><ul><li>普通for循环（只因为List有索引）</li><li>迭代器</li><li>增强for</li><li>Lambda表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;蜘蛛精&quot;</span>);<br>list.add(<span class="hljs-string">&quot;至尊宝&quot;</span>);<br>list.add(<span class="hljs-string">&quot;糖宝宝&quot;</span>);<br><br><span class="hljs-comment">//1.普通for循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; list.size(); i++)&#123;<br>    <span class="hljs-comment">//i = 0, 1, 2</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> list.get(i);<br>    System.out.println(e);<br>&#125;<br><br><span class="hljs-comment">//2.增强for遍历</span><br><span class="hljs-keyword">for</span>(String s : list)&#123;<br>    System.out.println(s);<br>&#125;<br><br><span class="hljs-comment">//3.迭代器遍历</span><br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>    System.out.println(s);<br>&#125;<br><br><span class="hljs-comment">//4.lambda表达式遍历</span><br>list.forEach(s-&gt;System.out.println(s));<br></code></pre></td></tr></table></figure><h3 id="4-3-ArrayList底层的原理"><a href="#4-3-ArrayList底层的原理" class="headerlink" title="4.3 ArrayList底层的原理"></a>4.3 ArrayList底层的原理</h3><p>为了让同学们更加透彻的理解ArrayList集合，接下来，学习一下ArrayList集合的底层原理。</p><p>ArrayList集合底层是基于数组结构实现的，也就是说当你往集合容器中存储元素时，底层本质上是往数组中存储元素。 特点如下：</p><p><img src="/assets/1666166151267.png" alt="1666166151267"></p><p>我们知道数组的长度是固定的，但是集合的长度是可变的，这是怎么做到的呢？原理如下：</p><p><img src="/assets/1666166661149.png" alt="1666166661149"></p><p>数组扩容，并不是在原数组上扩容（原数组是不可以扩容的），底层是创建一个新数组，然后把原数组中的元素全部复制到新数组中去。</p><p><img src="/assets/1666166956907.png" alt="1666166956907"></p><h3 id="4-4-LinkedList底层原理"><a href="#4-4-LinkedList底层原理" class="headerlink" title="4.4 LinkedList底层原理"></a>4.4 LinkedList底层原理</h3><p>学习完ArrayList底层原理之后，接下来我们看一下LinkedList集合的底层原理。</p><p>LinkedList底层是链表结构，链表结构是由一个一个的节点组成，一个节点由数据值、下一个元素的地址组成。如下图所示</p><p><img src="/assets/1666167170415.png" alt="1666167170415"></p><p>假如，现在要在B节点和D节点中间插入一个元素，只需要把B节点指向D节点的地址断掉，重新指向新的节点地址就可以了。如下图所示：</p><p><img src="/assets/1666167298885.png" alt="1666167298885"></p><p>假如，现在想要把D节点删除，只需要让C节点指向E节点的地址，然后把D节点指向E节点的地址断掉。此时D节点就会变成垃圾，会把垃圾回收器清理掉。</p><p><img src="/assets/1666167419164.png" alt="1666167419164"></p><p>上面的链表是单向链表，它的方向是从头节点指向尾节点的，只能从左往右查找元素，这样查询效率比较慢；还有一种链表叫做双向链表，不光可以从做往右找，还可以从右往左找。如下图所示：</p><p><img src="/assets/1666167523139.png" alt="1666167523139"></p><p>LinkedList集合是基于双向链表实现了，所以相对于ArrayList新增了一些可以针对头尾进行操作的方法，如下图示所示：</p><p><img src="/assets/1666167572387.png" alt="1666167572387"></p><h3 id="4-5-LinkedList集合的应用场景"><a href="#4-5-LinkedList集合的应用场景" class="headerlink" title="4.5 LinkedList集合的应用场景"></a>4.5 LinkedList集合的应用场景</h3><p>刚才我们学习了LinkedList集合，那么LInkedList集合有什么用呢？可以用它来设计栈结构、队列结构。</p><ul><li>我们先来认识一下队列结构，队列结构你可以认为是一个上端开口，下端也开口的管子的形状。元素从上端入队列，从下端出队列。</li></ul><p><img src="/assets/1666167793391.png" alt="1666167793391"></p><p>入队列可以调用LinkedList集合的addLast方法，出队列可以调用removeFirst()方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建一个队列：先进先出、后进后出</span><br>LinkedList&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">//入对列</span><br>queue.addLast(<span class="hljs-string">&quot;第1号人&quot;</span>);<br>queue.addLast(<span class="hljs-string">&quot;第2号人&quot;</span>);<br>queue.addLast(<span class="hljs-string">&quot;第3号人&quot;</span>);<br>queue.addLast(<span class="hljs-string">&quot;第4号人&quot;</span>);<br>System.out.println(queue);<br><br><span class="hljs-comment">//出队列</span><br>System.out.println(queue.removeFirst());<span class="hljs-comment">//第4号人</span><br>System.out.println(queue.removeFirst());<span class="hljs-comment">//第3号人</span><br>System.out.println(queue.removeFirst());<span class="hljs-comment">//第2号人</span><br>System.out.println(queue.removeFirst());<span class="hljs-comment">//第1号人</span><br></code></pre></td></tr></table></figure><ul><li><p>接下来，我们再用LinkedList集合来模拟一下栈结构的效果。还是先来认识一下栈结构长什么样。栈结构可以看做是一个上端开头，下端闭口的水杯的形状。</p><p>元素永远是上端进，也从上端出，先进入的元素会压在最底下，所以<strong>栈结构的特点是先进后出，后进先出</strong></p></li></ul><p><img src="/assets/1666168222486.png" alt="1666168222486"></p><p>有没有感觉栈结构很像，手枪的子弹夹呀！！第一个压进入的子弹在最底下，最后一个才能打出来，最后一个压进入的子弹在最顶上，第一个打出来。</p><p><img src="/assets/1666168656191.png" alt="1666168656191"></p><p>接着，我们就用LinkedList来模拟下栈结构，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建一个栈对象</span><br>LinkedList&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//压栈(push) 等价于 addFirst()</span><br>stack.push(<span class="hljs-string">&quot;第1颗子弹&quot;</span>);<br>stack.push(<span class="hljs-string">&quot;第2颗子弹&quot;</span>);<br>stack.push(<span class="hljs-string">&quot;第3颗子弹&quot;</span>);<br>stack.push(<span class="hljs-string">&quot;第4颗子弹&quot;</span>);<br>System.out.println(stack); <span class="hljs-comment">//[第4颗子弹, 第3颗子弹, 第2颗子弹,第1颗子弹]</span><br><br><span class="hljs-comment">//弹栈(pop) 等价于 removeFirst()</span><br>System.out.println(statck.pop()); <span class="hljs-comment">//第4颗子弹</span><br>System.out.println(statck.pop()); <span class="hljs-comment">//第3颗子弹</span><br>System.out.println(statck.pop()); <span class="hljs-comment">//第2颗子弹</span><br>System.out.println(statck.pop()); <span class="hljs-comment">//第1颗子弹</span><br><br><span class="hljs-comment">//弹栈完了，集合中就没有元素了</span><br>System.out.println(list); <span class="hljs-comment">//[]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day05--Lambda%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/12/01/day05--Lambda%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="day05-算法和数据结构"><a href="#day05-算法和数据结构" class="headerlink" title="day05-算法和数据结构"></a>day05-算法和数据结构</h1><h2 id="一、Arrays类"><a href="#一、Arrays类" class="headerlink" title="一、Arrays类"></a>一、Arrays类</h2><p>接下来我们学习的类叫做Arrays，其实Arrays并不是重点，但是我们通过Arrays这个类的学习有助于我们理解下一个知识点Lambda的学习。所以我们这里先学习Arrays，再通过Arrays来学习Lamdba这样学习会更丝滑一些^_^.</p><h3 id="1-1-Arrays基本使用"><a href="#1-1-Arrays基本使用" class="headerlink" title="1.1 Arrays基本使用"></a>1.1 Arrays基本使用</h3><p>我们先认识一下Arrays是干什么用的，Arrays是操作数组的工具类，它可以很方便的对数组中的元素进行遍历、拷贝、排序等操作。</p><p>下面我们用代码来演示一下：<strong>遍历、拷贝、排序等操作</strong>。需要用到的方法如下</p><p><img src="/assets/1667458681721.png" alt="1667458681721"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握Arrays类的常用方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、public static String toString(类型[] arr): 返回数组的内容</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;;<br>        System.out.println(Arrays.toString(arr));<br><br>        <span class="hljs-comment">// 2、public static 类型[] copyOfRange(类型[] arr, 起始索引, 结束索引) ：拷贝数组（指定范围，包前不包后）</span><br>        <span class="hljs-type">int</span>[] arr2 = Arrays.copyOfRange(arr, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>        System.out.println(Arrays.toString(arr2));<br><br>        <span class="hljs-comment">// 3、public static copyOf(类型[] arr, int newLength)：拷贝数组，可以指定新数组的长度。</span><br>        <span class="hljs-type">int</span>[] arr3 = Arrays.copyOf(arr, <span class="hljs-number">10</span>);<br>        System.out.println(Arrays.toString(arr3));<br><br>        <span class="hljs-comment">// 4、public static setAll(double[] array, IntToDoubleFunction generator)：把数组中的原数据改为新数据又存进去。</span><br>        <span class="hljs-type">double</span>[] prices = &#123;<span class="hljs-number">99.8</span>, <span class="hljs-number">128</span>, <span class="hljs-number">100</span>&#125;;<br>        <span class="hljs-comment">//                  0     1    2</span><br>        <span class="hljs-comment">// 把所有的价格都打八折，然后又存进去。</span><br>        Arrays.setAll(prices, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntToDoubleFunction</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">applyAsDouble</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>                <span class="hljs-comment">// value = 0  1  2</span><br>                <span class="hljs-keyword">return</span> prices[value] * <span class="hljs-number">0.8</span>;<br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(prices));<br><br>        <span class="hljs-comment">// 5、public static void sort(类型[] arr)：对数组进行排序(默认是升序排序)</span><br>        Arrays.sort(prices);<br>        System.out.println(Arrays.toString(prices));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Arrays操作对象数组"><a href="#1-2-Arrays操作对象数组" class="headerlink" title="1.2 Arrays操作对象数组"></a>1.2 Arrays操作对象数组</h3><p>刚才我们使用Arrays操作数组时，数组中存储存储的元素是int类型、double类型，是可以直接排序的，而且默认是升序排列。</p><p>如果数组中存储的元素类型是自定义的对象，如何排序呢？接下来，我们就学习一下Arrays如何对对象数组进行排序。</p><p>首先我们要准备一个Student类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> height, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.height = height;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, height=&quot;</span> + height +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后再写一个测试类，往数组中存储4个学生对象，代码如下。此时，运行代码你会发现是会报错的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握如何对数组中的对象进行排序。</span><br>        Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">4</span>];<br>        students[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">169.5</span>, <span class="hljs-number">23</span>);<br>        students[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>, <span class="hljs-number">167.5</span>, <span class="hljs-number">24</span>);<br><br>        <span class="hljs-comment">// 1、public static void sort(类型[] arr)：对数组进行排序。</span><br>Arrays.sort(students);<br>System.out.println(Arrays.toString(students));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/1667459056681.png" alt="1667459056681"></p><p>上面的代码为什么会报错呢？因为Arrays根本就不知道按照什么规则进行排序。为了让Arrays知道按照什么规则排序，我们有如下的两种办法。</p><ul><li><strong>排序方式1：</strong>让Student类实现Comparable接口，同时重写compareTo方法。Arrays的sort方法底层会根据compareTo方法的返回值是正数、负数、还是0来确定谁大、谁小、谁相等。代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">//...get、set、空参数构造方法、有参数构造方法...自己补全</span><br><br>    <span class="hljs-comment">// 指定比较规则</span><br>    <span class="hljs-comment">// this  o</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>        <span class="hljs-comment">// 约定1：认为左边对象 大于 右边对象 请您返回正整数</span><br>        <span class="hljs-comment">// 约定2：认为左边对象 小于 右边对象 请您返回负整数</span><br>        <span class="hljs-comment">// 约定3：认为左边对象 等于 右边对象 请您一定返回0</span><br><span class="hljs-comment">/* if(this.age &gt; o.age)&#123;</span><br><span class="hljs-comment">            return 1;</span><br><span class="hljs-comment">        &#125;else if(this.age &lt; o.age)&#123;</span><br><span class="hljs-comment">            return -1;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return 0;*/</span><br><br>        <span class="hljs-comment">//上面的if语句，也可以简化为下面的一行代码</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - o.age; <span class="hljs-comment">// 按照年龄升序排列</span><br>        <span class="hljs-comment">// return o.age - this.age; // 按照年龄降序排列</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, height=&quot;</span> + height +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>排序方式2：</strong>在调用<code>Arrays.sort(数组,Comparator比较器);</code>时，除了传递数组之外，传递一个Comparator比较器对象。Arrays的sort方法底层会根据Comparator比较器对象的compare方法方法的返回值是正数、负数、还是0来确定谁大、谁小、谁相等。代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握如何对数组中的对象进行排序。</span><br>        Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">4</span>];<br>        students[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">169.5</span>, <span class="hljs-number">23</span>);<br>        students[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>, <span class="hljs-number">167.5</span>, <span class="hljs-number">24</span>);<br><br><span class="hljs-comment">// 2、public static &lt;T&gt; void sort(T[] arr, Comparator&lt;? super T&gt; c)</span><br>        <span class="hljs-comment">// 参数一：需要排序的数组</span><br>        <span class="hljs-comment">// 参数二：Comparator比较器对象（用来制定对象的比较规则）</span><br>        Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-comment">// 制定比较规则了：左边对象 o1   右边对象 o2</span><br>                <span class="hljs-comment">// 约定1：认为左边对象 大于 右边对象 请您返回正整数</span><br>                <span class="hljs-comment">// 约定2：认为左边对象 小于 右边对象 请您返回负整数</span><br>                <span class="hljs-comment">// 约定3：认为左边对象 等于 右边对象 请您一定返回0</span><br><span class="hljs-comment">//                if(o1.getHeight() &gt; o2.getHeight())&#123;</span><br><span class="hljs-comment">//                    return 1;</span><br><span class="hljs-comment">//                &#125;else if(o1.getHeight() &lt; o2.getHeight())&#123;</span><br><span class="hljs-comment">//                    return -1;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                return 0; // 升序</span><br>                 <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>                <span class="hljs-comment">// return Double.compare(o2.getHeight(), o1.getHeight()); // 降序</span><br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(students));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、Lambda表达式"><a href="#二、Lambda表达式" class="headerlink" title="二、Lambda表达式"></a>二、Lambda表达式</h2><p>接下来，我们学习一个JDK8新增的一种语法形式，叫做Lambda表达式。<strong>作用：用于简化匿名内部类代码的书写。</strong></p><h3 id="2-1-Lambda表达式基本使用"><a href="#2-1-Lambda表达式基本使用" class="headerlink" title="2.1 Lambda表达式基本使用"></a>2.1 Lambda表达式基本使用</h3><p>怎么去简化呢？Lamdba是有特有的格式的，按照下面的格式来编写Lamdba。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(被重写方法的形参列表) -&gt; &#123;<br>    被重写方法的方法体代码;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要给说明一下的是，在使用Lambda表达式之前，必须先有一个接口，而且接口中只能有一个抽象方法。<strong>（注意：不能是抽象类，只能是接口）</strong></p><p>像这样的接口，我们称之为函数式接口，只有基于函数式接口的匿名内部类才能被Lambda表达式简化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimming</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了以上的Swimming接口之后，接下来才能再演示，使用Lambda表达式，简化匿名内部类书写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：认识Lambda表达式.</span><br>        <span class="hljs-comment">//1.创建一个Swimming接口的匿名内部类对象</span><br><span class="hljs-type">Swimming</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swimming</span>()&#123;<br>             <span class="hljs-meta">@Override</span><br>             <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>                 System.out.println(<span class="hljs-string">&quot;学生快乐的游泳~~~~&quot;</span>);<br>             &#125;<br>         &#125;;<br>         s.swim();<br><br>        <span class="hljs-comment">//2.使用Lambda表达式对Swimming接口的匿名内部类进行简化</span><br>        <span class="hljs-type">Swimming</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>              System.out.println(<span class="hljs-string">&quot;学生快乐的游泳~~~~&quot;</span>);<br>        &#125;;<br>        s1.swim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，我们现在已经知道Lamdba表达式可以简化基于函数式接口的匿名内部类的书写。接下来，我们可以把刚才使用Arrays方法时的代码，使用Lambda表达式简化一下了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：使用Lambda简化函数式接口。</span><br>        <span class="hljs-type">double</span>[] prices = &#123;<span class="hljs-number">99.8</span>, <span class="hljs-number">128</span>, <span class="hljs-number">100</span>&#125;;<br><span class="hljs-comment">//1.把所有元素*0.8: 先用匿名内部类写法</span><br>        Arrays.setAll(prices, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntToDoubleFunction</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">applyAsDouble</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>                <span class="hljs-comment">// value = 0  1  2</span><br>                <span class="hljs-keyword">return</span> prices[value] * <span class="hljs-number">0.8</span>;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//2.把所有元素*0.8: 改用Lamdba表达式写法</span><br>        Arrays.setAll(prices, (<span class="hljs-type">int</span> value) -&gt; &#123;<br>                <span class="hljs-keyword">return</span> prices[value] * <span class="hljs-number">0.8</span>;<br>        &#125;);<br><br>        System.out.println(Arrays.toString(prices));<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br><br>        Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">4</span>];<br>        students[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">169.5</span>, <span class="hljs-number">23</span>);<br>        students[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>, <span class="hljs-number">167.5</span>, <span class="hljs-number">24</span>);<br><span class="hljs-comment">//3.对数组中的元素按照年龄升序排列: 先用匿名内部类写法</span><br>        Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//4.对数组中的元素按照年龄升序排列: 改用Lambda写法</span><br>        Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;<br>                <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>        &#125;);<br>        System.out.println(Arrays.toString(students));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，各位同学，恭喜大家！到这里，你已经学会了Lambda表达式的基本使用了。</p><h3 id="2-2-Lambda表达式省略规则"><a href="#2-2-Lambda表达式省略规则" class="headerlink" title="2.2 Lambda表达式省略规则"></a>2.2 Lambda表达式省略规则</h3><p>刚才我们学习了Lambda表达式的基本使用。Java觉得代码还不够简单，于是还提供了Lamdba表达式的几种简化写法。具体的简化规则如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>Lambda的标准格式<br>(参数类型<span class="hljs-number">1</span> 参数名<span class="hljs-number">1</span>, 参数类型<span class="hljs-number">2</span> 参数名<span class="hljs-number">2</span>)-&gt;&#123;<br>...方法体的代码...<br><span class="hljs-keyword">return</span> 返回值;<br>&#125;<br><br><span class="hljs-number">2.</span>在标准格式的基础上()中的参数类型可以直接省略<br>(参数名<span class="hljs-number">1</span>, 参数名<span class="hljs-number">2</span>)-&gt;&#123;<br>...方法体的代码...<br><span class="hljs-keyword">return</span> 返回值;<br>&#125;<br><br><span class="hljs-number">3.</span>如果&#123;&#125;总的语句只有一条语句，则&#123;&#125;可以省略、<span class="hljs-keyword">return</span>关键字、以及最后的“;”都可以省略<br>(参数名<span class="hljs-number">1</span>, 参数名<span class="hljs-number">2</span>)-&gt; 结果<br><br><span class="hljs-number">4.</span>如果()里面只有一个参数，则()可以省略<br>(参数名)-&gt;结果<br></code></pre></td></tr></table></figure><p>接下来从匿名内部类开始、到Lambda标准格式、再到Lambda简化格式，一步一步来简化一下。同学们体会一下简化的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：使用Lambda简化函数式接口。</span><br>        <span class="hljs-type">double</span>[] prices = &#123;<span class="hljs-number">99.8</span>, <span class="hljs-number">128</span>, <span class="hljs-number">100</span>&#125;;<br><span class="hljs-comment">//1.对数组中的每一个元素*0.8: 匿名内部类写法</span><br>        Arrays.setAll(prices, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntToDoubleFunction</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">applyAsDouble</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>                <span class="hljs-comment">// value = 0  1  2</span><br>                <span class="hljs-keyword">return</span> prices[value] * <span class="hljs-number">0.8</span>;<br>            &#125;<br>        &#125;);<br><span class="hljs-comment">//2.需求：对数组中的每一个元素*0.8,使用Lambda表达式标准写法</span><br>        Arrays.setAll(prices, (<span class="hljs-type">int</span> value) -&gt; &#123;<br>                <span class="hljs-keyword">return</span> prices[value] * <span class="hljs-number">0.8</span>;<br>        &#125;);<br><span class="hljs-comment">//3.使用Lambda表达式简化格式1——省略参数类型</span><br>        Arrays.setAll(prices, (value) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> prices[value] * <span class="hljs-number">0.8</span>;<br>        &#125;);<br><span class="hljs-comment">//4.使用Lambda表达式简化格式2——省略()</span><br>        Arrays.setAll(prices, value -&gt; &#123;<br>            <span class="hljs-keyword">return</span> prices[value] * <span class="hljs-number">0.8</span>;<br>        &#125;);<br>        <span class="hljs-comment">//5.使用Lambda表达式简化格式3——省略&#123;&#125;</span><br>        Arrays.setAll(prices, value -&gt; prices[value] * <span class="hljs-number">0.8</span> );<br><br>        System.out.println(Arrays.toString(prices));<br>        <br>        System.out.println(<span class="hljs-string">&quot;------------------------------------</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Student[] students = new Student[4];</span><br><span class="hljs-string">        students[0] = new Student(&quot;</span>蜘蛛精<span class="hljs-string">&quot;, 169.5, 23);</span><br><span class="hljs-string">        students[1] = new Student(&quot;</span>紫霞<span class="hljs-string">&quot;, 163.8, 26);</span><br><span class="hljs-string">        students[2] = new Student(&quot;</span>紫霞<span class="hljs-string">&quot;, 163.8, 26);</span><br><span class="hljs-string">        students[3] = new Student(&quot;</span>至尊宝<span class="hljs-string">&quot;, 167.5, 24);</span><br><span class="hljs-string"></span><br><span class="hljs-string">        //1.使用匿名内部类</span><br><span class="hljs-string">        Arrays.sort(students, new Comparator&lt;Student&gt;() &#123;</span><br><span class="hljs-string">            @Override</span><br><span class="hljs-string">            public int compare(Student o1, Student o2) &#123;</span><br><span class="hljs-string">                return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">//2.使用Lambda表达式表达式——标准格式</span><br><span class="hljs-string">        Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;</span><br><span class="hljs-string">                return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">//3.使用Lambda表达式表达式——省略参数类型</span><br><span class="hljs-string">        Arrays.sort(students, ( o1,  o2) -&gt; &#123;</span><br><span class="hljs-string">            return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">//4.使用Lambda表达式表达式——省略&#123;&#125;</span><br><span class="hljs-string">        Arrays.sort(students, ( o1,  o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight()));</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">        System.out.println(Arrays.toString(students));</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>到这里，恭喜你，对Lamdba表达式的所有写法，就学习完毕了。</p><h2 id="三、JDK8新特性（方法引用）"><a href="#三、JDK8新特性（方法引用）" class="headerlink" title="三、JDK8新特性（方法引用）"></a>三、JDK8新特性（方法引用）</h2><p>各位小伙伴，接下来我们学习JDK8的另一个新特性，叫做方法引用。我们知道Lambda是用来简化匿名代码的书写格式的，而方法引用是用来进一步简化Lambda表达式的，它简化的更加过分。</p><p>到这里有小伙伴可能就想慰问Java爸爸了：“之前的代码挺好的呀！好不容易学会，你又来搞这些，把我都搞晕了。“    说句大实话，确实有这样的问题，学习新的东西肯定会增加我们的学习成本，从心理上来说多少是有写抗拒的。但是从另一个角度想，一旦我们学会了，会大大简化我们的代码书写，提高我们编写代码的效率，而且这些新的语法都是有前提条件的，遇到的时候就简化得了。再退一步想，就算你没有学会，还是用以前的办法一点问题也没有。</p><p>给大家交代清楚了，学习方法引用可能存在的一些心理特点之后，接下来我们再正式学习方法引用的代码怎么编写。</p><h3 id="3-1-静态方法引用"><a href="#3-1-静态方法引用" class="headerlink" title="3.1 静态方法引用"></a>3.1 静态方法引用</h3><p>我们先学习静态方法的引用，还是用之前Arrays代码来做演示。现在准备好下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student[] students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">4</span>];<br>        students[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;蜘蛛精&quot;</span>, <span class="hljs-number">169.5</span>, <span class="hljs-number">23</span>);<br>        students[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;紫霞&quot;</span>, <span class="hljs-number">163.8</span>, <span class="hljs-number">26</span>);<br>        students[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;至尊宝&quot;</span>, <span class="hljs-number">167.5</span>, <span class="hljs-number">24</span>);<br><br>        <span class="hljs-comment">// 原始写法：对数组中的学生对象，按照年龄升序排序</span><br>        Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge(); <span class="hljs-comment">// 按照年龄升序排序</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 使用Lambda简化后的形式</span><br>        Arrays.sort(students, (o1, o2) -&gt; o1.getAge() - o2.getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我想要把下图中Lambda表达式的方法体，用一个静态方法代替</p><p><img src="/assets/1667464274934.png" alt="1667464274934"></p><p>准备另外一个类CompareByData类，用于封装Lambda表达式的方法体代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareByData</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareByAge</span><span class="hljs-params">(Student o1, Student o2)</span>&#123;<br>        <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge(); <span class="hljs-comment">// 升序排序的规则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以把Lambda表达式的方法体代码，改为下面的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, (o1, o2) -&gt; CompareByData.compareByAge(o1, o2));<br></code></pre></td></tr></table></figure><p>Java为了简化上面Lambda表达式的写法，利用方法引用可以改进为下面的样子。<strong>实际上就是用类名调用方法，但是把参数给省略了。</strong>这就是静态方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态方法引用：类名::方法名</span><br>Arrays.sort(students, CompareByData::compareByAge);<br></code></pre></td></tr></table></figure><h3 id="3-2-实例方法引用"><a href="#3-2-实例方法引用" class="headerlink" title="3.2 实例方法引用"></a>3.2 实例方法引用</h3><p>还是基于上面的案例，我们现在来学习一下实例方法的引用。现在，我想要把下图中Lambda表达式的方法体，用一个实例方法代替。</p><p><img src="/assets/1667464274934.png" alt="1667464274934"></p><p>在CompareByData类中，再添加一个实例方法，用于封装Lambda表达式的方法体</p><p><img src="/assets/1667464896645.png" alt="1667464896645"></p><p>接下来，我们把Lambda表达式的方法体，改用对象调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CompareByData</span> <span class="hljs-variable">compare</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompareByData</span>();<br>Arrays.sort(students, (o1, o2) -&gt; compare.compareByAgeDesc(o1, o2)); <span class="hljs-comment">// 降序</span><br></code></pre></td></tr></table></figure><p>最后，再将Lambda表达式的方法体，直接改成方法引用写法。<strong>实际上就是用类名调用方法，但是省略的参数</strong>。这就是实例方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CompareByData</span> <span class="hljs-variable">compare</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompareByData</span>();<br>Arrays.sort(students, compare::compareByAgeDesc); <span class="hljs-comment">// 降序</span><br></code></pre></td></tr></table></figure><blockquote><p>给小伙伴的寄语：一定要按照老师写的步骤，一步一步来做，你一定能学会的！！！ </p></blockquote><h3 id="3-2-特定类型的方法引用"><a href="#3-2-特定类型的方法引用" class="headerlink" title="3.2 特定类型的方法引用"></a>3.2 特定类型的方法引用</h3><p>各位小伙伴，我们继续学习特定类型的方法引用。在学习之前还是需要给大家说明一下，这种特定类型的方法引用是没有什么道理的，只是语法的一种约定，遇到这种场景，就可以这样用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Java约定：<br>    如果某个Lambda表达式里只是调用一个实例方法，并且前面参数列表中的第一个参数作为方法的主调，后面的所有参数都是作为该实例方法的入参时，则就可以使用特定类型的方法引用。<br>格式：<br>类型::方法名<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] names = &#123;<span class="hljs-string">&quot;boby&quot;</span>, <span class="hljs-string">&quot;angela&quot;</span>, <span class="hljs-string">&quot;Andy&quot;</span> ,<span class="hljs-string">&quot;dlei&quot;</span>, <span class="hljs-string">&quot;caocao&quot;</span>, <span class="hljs-string">&quot;Babo&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;Cici&quot;</span>&#125;;<br>        <br>        <span class="hljs-comment">// 要求忽略首字符大小写进行排序。</span><br>        Arrays.sort(names, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>                <span class="hljs-comment">// 制定比较规则。o1 = &quot;Andy&quot;  o2 = &quot;angela&quot;</span><br>                <span class="hljs-keyword">return</span> o1.compareToIgnoreCase(o2);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//lambda表达式写法</span><br>        Arrays.sort(names, ( o1,  o2) -&gt; o1.compareToIgnoreCase(o2) );<br>        <span class="hljs-comment">//特定类型的方法引用！</span><br>        Arrays.sort(names, String::compareToIgnoreCase);<br><br>        System.out.println(Arrays.toString(names));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-构造器引用"><a href="#3-3-构造器引用" class="headerlink" title="3.3 构造器引用"></a>3.3 构造器引用</h3><p>各位小伙伴，我们学习最后一种方法引用的形式，叫做构造器引用。还是先说明一下，构造器引用在实际开发中应用的并不多，目前还没有找到构造器的应用场景。所以大家在学习的时候，也只是关注语法就可以了。</p><p>现在，我们准备一个JavaBean类，Car类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&quot;</span> + price +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为方法引用是基于Lamdba表达式简化的，所以也要按照Lamdba表达式的使用前提来用，需要一个函数式接口，接口中代码的返回值类型是Car类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CreateCar</span>&#123;<br>    Car <span class="hljs-title function_">create</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，再准备一个测试类，在测试类中创建CreateCar接口的实现类对象，先用匿名内部类创建、再用Lambda表达式创建，最后改用方法引用创建。同学们只关注格式就可以，不要去想为什么（语法就是这么设计的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建这个接口的匿名内部类对象。</span><br>        <span class="hljs-type">CreateCar</span> <span class="hljs-variable">cc1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateCar</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Car <span class="hljs-title function_">create</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> price)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(name, price);<br>            &#125;<br>        &#125;;<br><span class="hljs-comment">//2、使用匿名内部类改进</span><br>        <span class="hljs-type">CreateCar</span> <span class="hljs-variable">cc2</span> <span class="hljs-operator">=</span> (name,  price) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(name, price);<br><br>        <span class="hljs-comment">//3、使用方法引用改进：构造器引用</span><br>        <span class="hljs-type">CreateCar</span> <span class="hljs-variable">cc3</span> <span class="hljs-operator">=</span> Car::<span class="hljs-keyword">new</span>;<br>        <br>        <span class="hljs-comment">//注意：以上是创建CreateCar接口实现类对象的几种形式而已，语法一步一步简化。</span><br>        <br>        <span class="hljs-comment">//4、对象调用方法</span><br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> cc3.create(<span class="hljs-string">&quot;奔驰&quot;</span>, <span class="hljs-number">49.9</span>);<br>        System.out.println(car);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、常见算法"><a href="#四、常见算法" class="headerlink" title="四、常见算法"></a>四、常见算法</h2><h3 id="1-1-认识算法"><a href="#1-1-认识算法" class="headerlink" title="1.1 认识算法"></a>1.1 认识算法</h3><p>接下来，我们认识一下什么是算法。算法其实是解决某个实际问题的过程和方法。比如百度地图给你规划路径，计算最优路径的过程就需要用到算法。再比如你在抖音上刷视频时，它会根据你的喜好给你推荐你喜欢看的视频，这里也需要用到算法。</p><p>我们为什么要学习算法呢？主要目的是训练我们的编程思维，还有就是面试的时候，面试官也喜欢问一下算法的问题来考察你的技术水平。最后一点，学习算法是成为一个高级程序员的必经之路。</p><p>当然我们现在并不会学习非常复杂的算法，万丈高楼平地起，我们现在只需要学习几种常见的基础算法就可以了。而且Java语言本身就内置了一些基础算法给我们使用，实际上自己也不会去写这些算法。</p><p><img src="/assets/1667402734025.png" alt="1667402734025"></p><h3 id="1-2-冒泡排序"><a href="#1-2-冒泡排序" class="headerlink" title="1.2 冒泡排序"></a>1.2 冒泡排序</h3><p>接下来，我们学习一种算法叫排序算法，它可以价格无序的整数，排列成从小到大的形式（升序），或者从大到小的形式（降序）</p><p>排序算法有很多种，我们这里只学习比较简单的两种，一种是冒泡排序，一种是选择排序。学习算法我们先要搞清楚算法的流程，然后再去“推敲“如何写代码。（<strong>注意，我这里用的次是推敲，也就是说算法这样的代码并不是一次成型的，是需要反复修改才能写好的</strong>）。</p><p><img src="/assets/1667403334232.png" alt="1667403334232"></p><p>先来学习冒泡排序，先来介绍一下，冒泡排序的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">冒泡排序核心思路：每次将相邻的两个元素继续比较<br>如下图所示：<br>   第一轮比较 <span class="hljs-number">3</span>次<br>   第二轮比较 <span class="hljs-number">2</span>次<br>   第三轮比较 <span class="hljs-number">1</span>次<br></code></pre></td></tr></table></figure><p><img src="/assets/1667403618904.png" alt="1667403618904"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、准备一个数组</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">// 2、定义一个循环控制排几轮</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">// i = 0  1  2           【5， 2， 3， 1】    次数</span><br>            <span class="hljs-comment">// i = 0 第一轮            0   1   2         3</span><br>            <span class="hljs-comment">// i = 1 第二轮            0   1             2</span><br>            <span class="hljs-comment">// i = 2 第三轮            0                 1</span><br><br>            <span class="hljs-comment">// 3、定义一个循环控制每轮比较几次。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - i - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-comment">// 判断当前位置的元素值，是否大于后一个位置处的元素值，如果大则交换。</span><br>                <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = arr[j];<br>                    arr[j] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><p>刚才我们学习了冒泡排序，接下来我们学习了另一种排序方法，叫做选择排序。按照我们刚才给大家介绍的算法的学习方式。先要搞清楚算法的流程，再去推敲代码怎么写。</p><p>所以我们先分析选择排序算法的流程：选择排序的核心思路是，每一轮选定一个固定的元素，和其他的每一个元素进行比较；经过几轮比较之后，每一个元素都能比较到了。</p><p><img src="/assets/1667467347586.png" alt="1667467347586"></p><p>接下来，按照选择排序的流程编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">ublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、准备好一个数组</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-comment">//           0  1  2  3</span><br><br>        <span class="hljs-comment">// 2、控制选择几轮</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">// i = 0 第一轮    j = 1 2 3</span><br>            <span class="hljs-comment">// i = 1 第二轮    j = 2 3</span><br>            <span class="hljs-comment">// i = 2 第三轮    j = 3</span><br>            <span class="hljs-comment">// 3、控制每轮选择几次。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-comment">// 判断当前位置是否大于后面位置处的元素值，若大于则交换。</span><br>                <span class="hljs-keyword">if</span>(arr[i] &gt; arr[j])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>                    arr[i] = arr[j];<br>                    arr[j] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-查找算法"><a href="#1-3-查找算法" class="headerlink" title="1.3 查找算法"></a>1.3 查找算法</h3><p>接下来，我们学习一个查找算法叫做二分查找。在学习二分查找之前，我们先来说一下基本查找，从基本查找的弊端，我们再引入二分查找，这样我们的学习也会更加丝滑一下。</p><p><strong>先聊一聊基本查找：</strong>假设我们要查找的元素是81，如果是基本查找的话，只能从0索引开始一个一个往后找，但是如果元素比较多，你要查找的元素比较靠后的话，这样查找的此处就比较多。性能比较差。</p><p><img src="/assets/1667467611576.png" alt="1667467611576"></p><p><strong>再讲二分查找</strong>：二分查找的主要特点是，每次查找能排除一般元素，这样效率明显提高。<strong>但是二分查找要求比较苛刻，它要求元素必须是有序的，否则不能进行二分查找。</strong></p><ul><li>二分查找的核心思路</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">第<span class="hljs-number">1</span>步：先定义两个变量，分别记录开始索引(left)和结束索引(right)<br>第<span class="hljs-number">2</span>步：计算中间位置的索引，mid = (left+right)/<span class="hljs-number">2</span>;<br>第<span class="hljs-number">3</span>步：每次查找中间mid位置的元素，和目标元素key进行比较<br>如果中间位置元素比目标元素小，那就说明mid前面的元素都比目标元素小<br>此时：left = mid+<span class="hljs-number">1</span><br>    如果中间位置元素比目标元素大，那说明mid后面的元素都比目标元素大<br>    此时：right = mid-<span class="hljs-number">1</span><br>如果中间位置元素和目标元素相等，那说明mid就是我们要找的位置<br>此时：把mid返回<br>注意：一搬查找一次肯定是不够的，所以需要把第<span class="hljs-number">1</span>步和第<span class="hljs-number">2</span>步循环来做，只到left&gt;end就结束，如果最后还没有找到目标元素，就返回-<span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure><p><img src="/assets/1667468412882.png" alt="1667468412882"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握二分查找算法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、准备好一个数组。</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">23</span>, <span class="hljs-number">79</span>, <span class="hljs-number">81</span>, <span class="hljs-number">103</span>, <span class="hljs-number">127</span>, <span class="hljs-number">131</span>, <span class="hljs-number">147</span>&#125;;<br><br>        System.out.println(binarySearch(arr, <span class="hljs-number">150</span>));<br><br>        System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">81</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> data)</span>&#123;<br>        <span class="hljs-comment">// 1、定义两个变量，一个站在左边位置，一个站在右边位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 2、定义一个循环控制折半。</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;<br>            <span class="hljs-comment">// 3、每次折半，都算出中间位置处的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 4、判断当前要找的元素值，与中间位置处的元素值的大小情况。</span><br>            <span class="hljs-keyword">if</span>(data &lt; arr[middle])&#123;<br>                <span class="hljs-comment">// 往左边找，截止位置（右边位置） = 中间位置 - 1</span><br>                right = middle - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data &gt; arr[middle])&#123;<br>                <span class="hljs-comment">// 往右边找，起始位置（左边位置） = 中间位置 + 1</span><br>                left = middle + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 中间位置处的元素值，正好等于我们要找的元素值</span><br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1特殊结果，就代表没有找到数据！数组中不存在该数据！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、正则表达式"><a href="#五、正则表达式" class="headerlink" title="五、正则表达式"></a>五、正则表达式</h2><p>接下来，我们学习一个全新的知识，叫做正则表达式。<strong>正则表达式其实是由一些特殊的符号组成的，它代表的是某种规则。</strong></p><blockquote><p>正则表达式的作用1：用来校验字符串数据是否合法</p><p>正则表达式的作用2：可以从一段文本中查找满足要求的内容</p></blockquote><p><img src="/assets/1667468712516.png" alt="1667468712516"></p><h3 id="5-1-正则表达式初体验"><a href="#5-1-正则表达式初体验" class="headerlink" title="5.1 正则表达式初体验"></a>5.1 正则表达式初体验</h3><p>现在，我们就以QQ号码为例，来体验一下正则表达式的用法。注意：现在仅仅只是体验而已，我们还没有讲正则表达式的具体写法。</p><ul><li>不使用正则表达式，校验QQ号码代码是这样的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkQQ</span><span class="hljs-params">(String qq)</span>&#123;<br>        <span class="hljs-comment">// 1、判断qq号码是否为null</span><br>        <span class="hljs-keyword">if</span>(qq == <span class="hljs-literal">null</span> || qq.startsWith(<span class="hljs-string">&quot;0&quot;</span>) || qq.length() &lt; <span class="hljs-number">6</span> || qq.length() &gt; <span class="hljs-number">20</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2、qq至少是不是null,不是以0开头的，满足6-20之间的长度。</span><br>        <span class="hljs-comment">// 判断qq号码中是否都是数字。</span><br>        <span class="hljs-comment">// qq = 2514ghd234</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; qq.length(); i++) &#123;<br>            <span class="hljs-comment">// 根据索引提取当前位置处的字符。</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> qq.charAt(i);<br>            <span class="hljs-comment">// 判断ch记住的字符，如果不是数字，qq号码不合法。</span><br>            <span class="hljs-keyword">if</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 3、说明qq号码肯定是合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>用正则表达式代码是这样的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkQQ1</span><span class="hljs-params">(String qq)</span>&#123;<br>    <span class="hljs-keyword">return</span> qq != <span class="hljs-literal">null</span> &amp;&amp; qq.matches(<span class="hljs-string">&quot;[1-9]\\d&#123;5,19&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，使用正则表达式，大大简化的了代码的写法。这个代码现在不用写，体验到正则表达式的优势就可以了。</p><h3 id="5-2-正则表达式书写规则"><a href="#5-2-正则表达式书写规则" class="headerlink" title="5.2 正则表达式书写规则"></a>5.2 正则表达式书写规则</h3><p>前面我们已经体验到了正则表达式，可以简化校验数据的代码书写。这里需要用到一个方法叫<code>matches(String regex)</code>。这个方法时属于String类的方法。</p><p><img src="/assets/1667469085970.png" alt="1667469085970"></p><p>这个方法是用来匹配一个字符串是否匹配正则表达式的规则，参数需要调用者传递一个正则表达式。但是正则表达式不能乱写，是有特定的规则的。</p><p>下面我们就学习一下，正则表达式的规则。从哪里学呢？在API中有一个类叫做Pattern，我们可以到API文档中搜索，关于正则表达式的规则，这个类都告诉我们了。我这里把常用的已经给大家整理好了。</p><p><img src="/assets/1667469259345.png" alt="1667469259345"></p><p>我们将这些规则，在代码中演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握正则表达式的书写规则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、字符类(只能匹配单个字符)</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>));    <span class="hljs-comment">// [abc]只能匹配a、b、c</span><br>        System.out.println(<span class="hljs-string">&quot;e&quot;</span>.matches(<span class="hljs-string">&quot;[abcd]&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;d&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>));   <span class="hljs-comment">// [^abc] 不能是abc</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>));  <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z]&quot;</span>)); <span class="hljs-comment">// [a-zA-Z] 只能是a-z A-Z的字符</span><br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z]&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;k&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="hljs-comment">// ： a到z，除了b和c</span><br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;ab&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&quot;</span>)); <span class="hljs-comment">// false 注意：以上带 [内容] 的规则都只能用于匹配单个字符</span><br><br>        <span class="hljs-comment">// 2、预定义字符(只能匹配单个字符)  .  \d  \D   \s  \S  \w  \W</span><br>        System.out.println(<span class="hljs-string">&quot;徐&quot;</span>.matches(<span class="hljs-string">&quot;.&quot;</span>)); <span class="hljs-comment">// .可以匹配任意字符</span><br>        System.out.println(<span class="hljs-string">&quot;徐徐&quot;</span>.matches(<span class="hljs-string">&quot;.&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// \转义</span><br>        System.out.println(<span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        <span class="hljs-comment">// \n \t</span><br>        System.out.println(<span class="hljs-string">&quot;3&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>));  <span class="hljs-comment">// \d: 0-9</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>));  <span class="hljs-comment">//false</span><br><br>        System.out.println(<span class="hljs-string">&quot; &quot;</span>.matches(<span class="hljs-string">&quot;\\s&quot;</span>));   <span class="hljs-comment">// \s: 代表一个空白字符</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\s&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\S&quot;</span>));  <span class="hljs-comment">// \S: 代表一个非空白字符</span><br>        System.out.println(<span class="hljs-string">&quot; &quot;</span>.matches(<span class="hljs-string">&quot;\\S&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>));  <span class="hljs-comment">// \w: [a-zA-Z_0-9]</span><br>        System.out.println(<span class="hljs-string">&quot;_&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;徐&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;徐&quot;</span>.matches(<span class="hljs-string">&quot;\\W&quot;</span>));  <span class="hljs-comment">// [^\w]不能是a-zA-Z_0-9</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\W&quot;</span>));  <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;23232&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// false 注意：以上预定义字符都只能匹配单个字符。</span><br><br>        <span class="hljs-comment">// 3、数量词： ?   *   +   &#123;n&#125;   &#123;n, &#125;  &#123;n, m&#125;</span><br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\w?&quot;</span>));   <span class="hljs-comment">// ? 代表0次或1次</span><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>.matches(<span class="hljs-string">&quot;\\w?&quot;</span>));    <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.matches(<span class="hljs-string">&quot;\\w?&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;abc12&quot;</span>.matches(<span class="hljs-string">&quot;\\w*&quot;</span>));   <span class="hljs-comment">// * 代表0次或多次</span><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>.matches(<span class="hljs-string">&quot;\\w*&quot;</span>));        <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;abc12张&quot;</span>.matches(<span class="hljs-string">&quot;\\w*&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;abc12&quot;</span>.matches(<span class="hljs-string">&quot;\\w+&quot;</span>));   <span class="hljs-comment">// + 代表1次或多次</span><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>.matches(<span class="hljs-string">&quot;\\w+&quot;</span>));       <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;abc12张&quot;</span>.matches(<span class="hljs-string">&quot;\\w+&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        System.out.println(<span class="hljs-string">&quot;a3c&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;3&#125;&quot;</span>));   <span class="hljs-comment">// &#123;3&#125; 代表要正好是n次</span><br>        System.out.println(<span class="hljs-string">&quot;abcd&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;3&#125;&quot;</span>));  <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;abcd&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="hljs-comment">// &#123;3,&#125; 代表是&gt;=3次</span><br>        System.out.println(<span class="hljs-string">&quot;ab&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;abcde徐&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;abc232d&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;3,9&#125;&quot;</span>));     <span class="hljs-comment">// &#123;3, 9&#125; 代表是  大于等于3次，小于等于9次</span><br><br>        <span class="hljs-comment">// 4、其他几个常用的符号：(?i)忽略大小写 、 或：| 、  分组：()</span><br>        System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.matches(<span class="hljs-string">&quot;(?i)abc&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;ABC&quot;</span>.matches(<span class="hljs-string">&quot;(?i)abc&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;aBc&quot;</span>.matches(<span class="hljs-string">&quot;a((?i)b)c&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;ABc&quot;</span>.matches(<span class="hljs-string">&quot;a((?i)b)c&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// 需求1：要求要么是3个小写字母，要么是3个数字。</span><br>        System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.matches(<span class="hljs-string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;ABC&quot;</span>.matches(<span class="hljs-string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;123&quot;</span>.matches(<span class="hljs-string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;A12&quot;</span>.matches(<span class="hljs-string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-comment">// 需求2：必须是”我爱“开头，中间可以是至少一个”编程“，最后至少是1个”666“</span><br>        System.out.println(<span class="hljs-string">&quot;我爱编程编程666666&quot;</span>.matches(<span class="hljs-string">&quot;我爱(编程)+(666)+&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;我爱编程编程66666&quot;</span>.matches(<span class="hljs-string">&quot;我爱(编程)+(666)+&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-正则表达式应用案例"><a href="#5-3-正则表达式应用案例" class="headerlink" title="5.3 正则表达式应用案例"></a>5.3 正则表达式应用案例</h3><p>学习完正则表达式的规则之后，接下来我们再利用正则表达式，去校验几个实际案例。</p><ul><li>正则表达式校验手机号码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：校验用户输入的电话、邮箱、时间是否合法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        checkPhone();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPhone</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请您输入您的电话号码(手机|座机): &quot;</span>);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> sc.nextLine();<br>            <span class="hljs-comment">// 18676769999  010-3424242424 0104644535</span><br>            <span class="hljs-keyword">if</span>(phone.matches(<span class="hljs-string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,7&#125;-?[1-9]\\d&#123;4,19&#125;)&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;您输入的号码格式正确~~~&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;您输入的号码格式不正确~~~&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用正则表达式校验邮箱是否正确</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        checkEmail();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkEmail</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请您输入您的邮箱： &quot;</span>);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> sc.nextLine();<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * dlei0009@163.com</span><br><span class="hljs-comment">             * 25143242@qq.com</span><br><span class="hljs-comment">             * itheima@itcast.com.cn</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span>(email.matches(<span class="hljs-string">&quot;\\w&#123;2,&#125;@\\w&#123;2,20&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;&quot;</span>))&#123;<br>                System.out.println(<span class="hljs-string">&quot;您输入的邮箱格式正确~~~&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;您输入的邮箱格式不正确~~~&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-4-正则表达式信息爬取"><a href="#5-4-正则表达式信息爬取" class="headerlink" title="5.4 正则表达式信息爬取"></a>5.4 正则表达式信息爬取</h3><p>各位小伙伴，在前面的课程中，我们学习了正则表达式的作用之一，用来校验数据格式的正确性。接下来我们学习<strong>正则表达式的第二个作用：在一段文本中查找满足要求的内容</strong></p><p>我们还是通过一个案例给大家做演示：案例需求如下</p><p><img src="/assets/1667469722842.png" alt="1667469722842"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握使用正则表达式查找内容。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexTest4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        method1();<br>    &#125;<br><br>    <span class="hljs-comment">// 需求1：从以下内容中爬取出，手机，邮箱，座机、400电话等信息。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; 来黑马程序员学习Java，\n&quot;</span> +<br>                <span class="hljs-string">&quot;        电话：1866668888，18699997777\n&quot;</span> +<br>                <span class="hljs-string">&quot;        或者联系邮箱：boniu@itcast.cn，\n&quot;</span> +<br>                <span class="hljs-string">&quot;        座机电话：01036517895，010-98951256\n&quot;</span> +<br>                <span class="hljs-string">&quot;        邮箱：bozai@itcast.cn，\n&quot;</span> +<br>                <span class="hljs-string">&quot;        邮箱：dlei0009@163.com，\n&quot;</span> +<br>                <span class="hljs-string">&quot;        热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090&quot;</span>;<br>        <span class="hljs-comment">// 1、定义爬取规则</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,7&#125;-?[1-9]\\d&#123;4,19&#125;)|(\\w&#123;2,&#125;@\\w&#123;2,20&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;)&quot;</span><br>                + <span class="hljs-string">&quot;|(400-?\\d&#123;3,7&#125;-?\\d&#123;3,7&#125;)&quot;</span>;<br>        <span class="hljs-comment">// 2、把正则表达式封装成一个Pattern对象</span><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-comment">// 3、通过pattern对象去获取查找内容的匹配器对象。</span><br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(data);<br>        <span class="hljs-comment">// 4、定义一个循环开始爬取信息</span><br>        <span class="hljs-keyword">while</span> (matcher.find())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> matcher.group(); <span class="hljs-comment">// 获取到了找到的内容了。</span><br>            System.out.println(rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-正则表达式搜索、替换"><a href="#5-5-正则表达式搜索、替换" class="headerlink" title="5.5 正则表达式搜索、替换"></a>5.5 正则表达式搜索、替换</h3><p>接下来，我们学习一下正则表达式的另外两个功能，替换、分割的功能。需要注意的是这几个功能需要用到Stirng类中的方法。这两个方法其实我们之前学过，只是当时没有学正则表达式而已。</p><p><img src="/assets/1667469943451.png" alt="1667469943451"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握使用正则表达式做搜索替换，内容分割。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegexTest5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、public String replaceAll(String regex , String newStr)：按照正则表达式匹配的内容进行替换</span><br>        <span class="hljs-comment">// 需求1：请把下面字符串中的不是汉字的部分替换为 “-”</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;</span>;<br>        System.out.println(s1.replaceAll(<span class="hljs-string">&quot;\\w+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>));<br>        <br>        <span class="hljs-comment">// 需求2(拓展)：某语音系统，收到一个口吃的人说的“我我我喜欢编编编编编编编编编编编编程程程！”，需要优化成“我喜欢编程！”。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;我我我喜欢编编编编编编编编编编编编程程程&quot;</span>;<br>        System.out.println(s2.replaceAll(<span class="hljs-string">&quot;(.)\\1+&quot;</span>, <span class="hljs-string">&quot;$1&quot;</span>));<br><br>        <span class="hljs-comment">// 2、public String[] split(String regex)：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</span><br>        <span class="hljs-comment">// 需求1：请把下面字符串中的人名取出来，使用切割来做</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;</span>;<br>        String[] names = s3.split(<span class="hljs-string">&quot;\\w+&quot;</span>);<br>        System.out.println(Arrays.toString(names));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day04--%E5%B8%B8%E7%94%A8API/"/>
    <url>/2023/12/01/day04--%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h1 id="day04——常用API"><a href="#day04——常用API" class="headerlink" title="day04——常用API"></a>day04——常用API</h1><h2 id="一、-StringBuilder类"><a href="#一、-StringBuilder类" class="headerlink" title="一、 StringBuilder类"></a>一、 StringBuilder类</h2><ul><li>StringBuilder代表可变字符串对象，相当于是一个容器，它里面的字符串是可以改变的，就是用来操作字符串的。</li><li>好处：StringBuilder比String更合适做字符串的修改操作，效率更高，代码也更加简洁。</li></ul><p><strong>1.1 StringBuilder方法演示</strong></p><p>接下来我们用代码演示一下StringBuilder的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;itehima&quot;</span>);<br>        <br>        <span class="hljs-comment">//1.拼接内容</span><br>        sb.append(<span class="hljs-number">12</span>);<br>        sb.append(<span class="hljs-string">&quot;黑马&quot;</span>);<br>        sb.append(<span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">//2.append方法，支持临时编程</span><br>        sb.append(<span class="hljs-number">666</span>).append(<span class="hljs-string">&quot;黑马2&quot;</span>).append(<span class="hljs-number">666</span>);<br>        System.out.println(sb); <span class="hljs-comment">//打印：12黑马666黑马2666</span><br>        <br>        <span class="hljs-comment">//3.反转操作</span><br>        sb.reverse();<br>        System.out.println(sb); <span class="hljs-comment">//打印：6662马黑666马黑21</span><br>        <br>        <span class="hljs-comment">//4.返回字符串的长度</span><br>        System.out.println(sb.length());<br>        <br>        <span class="hljs-comment">//5.StringBuilder还可以转换为字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sb.toString();<br>        System.out.println(s); <span class="hljs-comment">//打印：6662马黑666马黑21</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要用StringBuilder对字符串进行操作呢？因为它的效率比String更高，我们可以下面两段代码验证一下。</p><p><img src="/assets/1667402173587.png" alt="1667402173587"></p><p>经过我的验证，直接使用Stirng拼接100万次，等了1分钟，还没结束，我等不下去了；但是使用StringBuilder做拼接，不到1秒钟出结果了。</p><p><strong>1.2 StringBuilder应用案例</strong></p><p>接下来，我们通过一个案例把StringBuilder运用下，案例需求如下图所示</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> getArrayData( <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>&#125;);<br>        System.out.println(str);<br>    &#125;<br>    <br>    <span class="hljs-comment">//方法作用：将int数组转换为指定格式的字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getArrayData</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-comment">//1.判断数组是否为null</span><br>        <span class="hljs-keyword">if</span>(arr==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.如果数组不为null，再遍历，并拼接数组中的元素</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==arr.legnth-<span class="hljs-number">1</span>)&#123;<br>                sb.append(arr[i]).append(<span class="hljs-string">&quot;]&quot;</span>);;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sb.append(arr[i]).append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//3、把StirngBuilder转换为String，并返回。</span><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、StringJoiner类"><a href="#二、StringJoiner类" class="headerlink" title="二、StringJoiner类"></a>二、StringJoiner类</h2><p>接下来，我们学习一个类叫做StringJoiner，学习这个类干嘛用呢？是因为我们前面使用StringBuilder拼接字符串的时，代码写起来还是有一点麻烦，而StringJoiner号称是拼接神器，不仅效率高，而且代码简洁。</p><p>下面演示一下StringJoiner的基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>        s.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>        s.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>        s.add(<span class="hljs-string">&quot;java3&quot;</span>);<br>        System.out.println(s); <span class="hljs-comment">//结果为： java1,java2,java3</span><br>        <br>        <span class="hljs-comment">//参数1：间隔符</span><br>        <span class="hljs-comment">//参数2：开头</span><br>        <span class="hljs-comment">//参数3：结尾</span><br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;[&quot;</span>,<span class="hljs-string">&quot;]&quot;</span>);<br>        s1.add(<span class="hljs-string">&quot;java1&quot;</span>);<br>        s1.add(<span class="hljs-string">&quot;java2&quot;</span>);<br>        s1.add(<span class="hljs-string">&quot;java3&quot;</span>);<br>        System.out.println(s1); <span class="hljs-comment">//结果为： [java1,java2,java3]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用StirngJoiner改写前面把数组转换为字符串的案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> getArrayData( <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>&#125;);<br>        System.out.println(str);<br>    &#125;<br>    <br>    <span class="hljs-comment">//方法作用：将int数组转换为指定格式的字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getArrayData</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-comment">//1.判断数组是否为null</span><br>        <span class="hljs-keyword">if</span>(arr==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2.如果数组不为null，再遍历，并拼接数组中的元素</span><br>        <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>,<span class="hljs-string">&quot;[&quot;</span>,<span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; i++)&#123;<br>            <span class="hljs-comment">//加&quot;&quot;是因为add方法的参数要的是String类型</span><br>            s.add(String.valueOf(arr[i]));<br>        &#125;<br>        <span class="hljs-comment">//3、把StringJoiner转换为String，并返回。</span><br>        <span class="hljs-keyword">return</span> s.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、Math类"><a href="#三、Math类" class="headerlink" title="三、Math类"></a>三、Math类</h2><p>Math是数学的意思，该类提供了很多个进行数学运算的方法，如求绝对值，求最大值，四舍五入等，话不多说，直接上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：了解下Math类提供的常见方法。</span><br>        <span class="hljs-comment">// 1、public static int abs(int a)：取绝对值（拿到的结果一定是正数）</span><br>        <span class="hljs-comment">//    public static double abs(double a)</span><br>        System.out.println(Math.abs(-<span class="hljs-number">12</span>)); <span class="hljs-comment">// 12</span><br>        System.out.println(Math.abs(<span class="hljs-number">123</span>)); <span class="hljs-comment">// 123</span><br>        System.out.println(Math.abs(-<span class="hljs-number">3.14</span>)); <span class="hljs-comment">// 3.14</span><br><br>        <span class="hljs-comment">// 2、public static double ceil(double a): 向上取整</span><br>        System.out.println(Math.ceil(<span class="hljs-number">4.0000001</span>)); <span class="hljs-comment">// 5.0</span><br>        System.out.println(Math.ceil(<span class="hljs-number">4.0</span>)); <span class="hljs-comment">// 4.0</span><br><br>        <span class="hljs-comment">// 3、public static double floor(double a): 向下取整</span><br>        System.out.println(Math.floor(<span class="hljs-number">4.999999</span>)); <span class="hljs-comment">// 4.0</span><br>        System.out.println(Math.floor(<span class="hljs-number">4.0</span>)); <span class="hljs-comment">// 4.0</span><br><br>        <span class="hljs-comment">// 4、public static long round(double a)：四舍五入</span><br>        System.out.println(Math.round(<span class="hljs-number">3.4999</span>)); <span class="hljs-comment">// 3</span><br>        System.out.println(Math.round(<span class="hljs-number">3.50001</span>)); <span class="hljs-comment">// 4</span><br><br>        <span class="hljs-comment">// 5、public static int max(int a, int b)：取较大值</span><br>        <span class="hljs-comment">//   public static int min(int a, int b)：取较小值</span><br>        System.out.println(Math.max(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 20</span><br>        System.out.println(Math.min(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 10</span><br><br>        <span class="hljs-comment">// 6、 public static double pow(double a, double b)：取次方</span><br>        System.out.println(Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 2的3次方   8.0</span><br>        System.out.println(Math.pow(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 3的2次方   9.0</span><br><br>        <span class="hljs-comment">// 7、public static double random()： 取随机数 [0.0 , 1.0) (包前不包后)</span><br>        System.out.println(Math.random());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、-System类"><a href="#四、-System类" class="headerlink" title="四、 System类"></a>四、 System类</h2><p>接下来，学习一个System类，这是系统类，提供了一些获取获取系统数据的方法。比如获取系统时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：了解下System类的常见方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 1、public static void exit(int status):</span><br>        <span class="hljs-comment">//   终止当前运行的Java虚拟机。</span><br>        <span class="hljs-comment">//   该参数用作状态代码; 按照惯例，非零状态代码表示异常终止。</span><br>        System.exit(<span class="hljs-number">0</span>); <span class="hljs-comment">// 人为的终止虚拟机。(不要使用)</span><br><br>        <span class="hljs-comment">// 2、public static long currentTimeMillis():</span><br>        <span class="hljs-comment">//    获取当前系统的时间</span><br>        <span class="hljs-comment">//    返回的是long类型的时间毫秒值：指的是从1970-1-1 0:0:0开始走到此刻的总的毫秒值，1s = 1000ms</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(time);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;输出了：&quot;</span> + i);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println((time2 - time) / <span class="hljs-number">1000.0</span> + <span class="hljs-string">&quot;s&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、Runtime类"><a href="#五、Runtime类" class="headerlink" title="五、Runtime类"></a>五、Runtime类</h2><p>接下来，我们再学习一个Java的运行时类，叫Runtime类。这个类可以用来获取JVM的一些信息，也可以用这个类去执行其他的程序。话不多少，上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标：了解下Runtime的几个常见方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br><br>        <span class="hljs-comment">// 1、public static Runtime getRuntime() 返回与当前Java应用程序关联的运行时对象。</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <span class="hljs-comment">// 2、public void exit(int status) 终止当前运行的虚拟机,该参数用作状态代码; 按照惯例，非零状态代码表示异常终止。</span><br>        <span class="hljs-comment">// r.exit(0);</span><br><br>        <span class="hljs-comment">// 3、public int availableProcessors(): 获取虚拟机能够使用的处理器数。</span><br>        System.out.println(r.availableProcessors());<br><br>        <span class="hljs-comment">// 4、public long totalMemory() 返回Java虚拟机中的内存总量。</span><br>        System.out.println(r.totalMemory()/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span> + <span class="hljs-string">&quot;MB&quot;</span>); <span class="hljs-comment">// 1024 = 1K     1024 * 1024 = 1M</span><br><br>        <span class="hljs-comment">// 5、public long freeMemory() 返回Java虚拟机中的可用内存量</span><br>        System.out.println(r.freeMemory()/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span> + <span class="hljs-string">&quot;MB&quot;</span>);<br><br>        <span class="hljs-comment">// 6、public Process exec(String command) 启动某个程序，并返回代表该程序的对象。</span><br>        <span class="hljs-comment">// r.exec(&quot;D:\\soft\\XMind\\XMind.exe&quot;);</span><br>        <span class="hljs-type">Process</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> r.exec(<span class="hljs-string">&quot;QQ&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 让程序在这里暂停5s后继续往下走！！</span><br>        p.destroy(); <span class="hljs-comment">// 销毁！关闭程序！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、BigDecimal类"><a href="#六、BigDecimal类" class="headerlink" title="六、BigDecimal类"></a>六、BigDecimal类</h2><p>各位同学，接下来我们学习的这个类叫BigDecimal，至于它是干什么用的，我们先不说。我们先看一段代码，看这个代码有什么问题？再说BigDeimal这个类是干什么用的，这样会更好理解一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>);<br>        System.out.println(<span class="hljs-number">1.0</span> - <span class="hljs-number">0.32</span>);<br>        System.out.println(<span class="hljs-number">1.015</span> * <span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-number">1.301</span> / <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上代码，我们会发现，结果并和我们想看到的不太一样。如下图所示</p><p><img src="/assets/1667398959905.png" alt="1667398959905"></p><p>为了解决计算精度损失的问题，Java给我们提供了BigDecimal类，它提供了一些方法可以对数据进行四则运算，而且不丢失精度，同时还可以保留指定的小数位。下面看代码，演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握BigDecimal进行精确运算的方案。</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.1</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.2</span>;<br><br>        <span class="hljs-comment">// 1、把浮点型数据封装成BigDecimal对象，再来参与运算。</span><br>        <span class="hljs-comment">// a、public BigDecimal(double val) 得到的BigDecimal对象是无法精确计算浮点型数据的。 注意：不推荐使用这个，</span><br>        <span class="hljs-comment">// b、public BigDecimal(String val)  得到的BigDecimal对象是可以精确计算浮点型数据的。 可以使用。</span><br>        <span class="hljs-comment">// c、public static BigDecimal valueOf(double val): 通过这个静态方法得到的BigDecimal对象是可以精确运算的。是最好的方案。</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(a);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(b);<br><br>        <span class="hljs-comment">// 2、public BigDecimal add(BigDecimal augend): 加法</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> a1.add(b1);<br>        System.out.println(c1);<br><br>        <span class="hljs-comment">// 3、public BigDecimal subtract(BigDecimal augend): 减法</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> a1.subtract(b1);<br>        System.out.println(c2);<br><br>        <span class="hljs-comment">// 4、public BigDecimal multiply(BigDecimal augend): 乘法</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> a1.multiply(b1);<br>        System.out.println(c3);<br><br>        <span class="hljs-comment">// 5、public BigDecimal divide(BigDecimal b): 除法</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> a1.divide(b1);<br>        System.out.println(c4);<br><br><span class="hljs-comment">//        BigDecimal d1 = BigDecimal.valueOf(0.1);</span><br><span class="hljs-comment">//        BigDecimal d2 = BigDecimal.valueOf(0.3);</span><br><span class="hljs-comment">//        BigDecimal d3 = d1.divide(d2);</span><br><span class="hljs-comment">//        System.out.println(d3);</span><br><br>        <span class="hljs-comment">// 6、public BigDecimal divide(另一个BigDecimal对象，精确几位，舍入模式) : 除法，可以设置精确几位。</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.1</span>);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">0.3</span>);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> d1.divide(d2,  <span class="hljs-number">2</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 0.33</span><br>        System.out.println(d3);<br><br>        <span class="hljs-comment">// 7、public double doubleValue() : 把BigDecimal对象又转换成double类型的数据。</span><br>        <span class="hljs-comment">//print(d3);</span><br>        <span class="hljs-comment">//print(c1);</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">db1</span> <span class="hljs-operator">=</span> d3.doubleValue();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">db2</span> <span class="hljs-operator">=</span> c1.doubleValue();<br>        print(db1);<br>        print(db2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>&#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="五、Date类"><a href="#五、Date类" class="headerlink" title="五、Date类"></a>五、Date类</h2><p>接下来，我们学习一下Date类，Java中是由这个类的对象用来表示日期或者时间。</p><p>Date对象记录的时间是用毫秒值来表示的。Java语言规定，1970年1月1日0时0分0秒认为是时间的起点，此时记作0，那么1000（1秒&#x3D;1000毫秒）就表示1970年1月1日0时0分1秒，依次内推。</p><p><img src="/assets/1667399304240.png" alt="1667399304240"></p><p>下面是Date类的构造方法，和常见的成员方法，利用这些API写代码尝试一下</p><p><img src="/assets/1667399443159.png" alt="1667399443159"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1Date</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握Date日期类的使用。</span><br>        <span class="hljs-comment">// 1、创建一个Date的对象：代表系统当前时间信息的。</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d);<br><br>        <span class="hljs-comment">// 2、拿到时间毫秒值。</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> d.getTime();<br>        System.out.println(time);<br><br>        <span class="hljs-comment">// 3、把时间毫秒值转换成日期对象： 2s之后的时间是多少。</span><br>        time += <span class="hljs-number">2</span> * <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(time);<br>        System.out.println(d2);<br><br>        <span class="hljs-comment">// 4、直接把日期对象的时间通过setTime方法进行修改</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        d3.setTime(time);<br>        System.out.println(d3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、SimpleDateFormat类"><a href="#六、SimpleDateFormat类" class="headerlink" title="六、SimpleDateFormat类"></a>六、SimpleDateFormat类</h2><p>各位同学，前面我们打印Date对象时，发现打印输出的日期格式我们并不喜欢，是不是？你们喜欢那种格式呢？是不是像下面页面中这种格式啊？接下来我们学习的SimpleDateFormat类就可以转换Date对象表示日期时间的显示格式。</p><ul><li><p>我们把Date对象转换为指定格式的日期字符串这个操作，叫做<strong>日期格式化，</strong></p></li><li><p>反过来把指定格式的日期符串转换为Date对象的操作，叫做<strong>日期解析。</strong></p></li></ul><p><img src="/assets/1667399510543.png" alt="1667399510543"></p><p>接下来，我们先演示一下日期格式化，需要用到如下的几个方法</p><p><img src="/assets/1667399804244.png" alt="1667399804244"></p><p>注意：创建SimpleDateFormat对象时，在构造方法的参数位置传递日期格式，而日期格式是由一些特定的字母拼接而来的。我们需要记住常用的几种日期&#x2F;时间格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">字母   表示含义<br>yyyy年<br>MM月<br>dd日<br>HH时<br>mm分<br>ss秒<br>SSS毫秒<br><br><span class="hljs-string">&quot;2022年12月12日&quot;</span> 的格式是 <span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span><br><span class="hljs-string">&quot;2022-12-12 12:12:12&quot;</span> 的格式是 <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><br>按照上面的格式可以任意拼接，但是字母不能写错<br></code></pre></td></tr></table></figure><p>最后，上代码演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2SimpleDateFormat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-comment">// 目标：掌握SimpleDateFormat的使用。</span><br>        <span class="hljs-comment">// 1、准备一些时间</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(d);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> d.getTime();<br>        System.out.println(time);<br><br>        <span class="hljs-comment">// 2、格式化日期对象，和时间 毫秒值。</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> sdf.format(time);<br>        System.out.println(rs);<br>        System.out.println(rs2);<br>        System.out.println(<span class="hljs-string">&quot;----------------------------------------------&quot;</span>);<br><br>        <span class="hljs-comment">// 目标：掌握SimpleDateFormat解析字符串时间 成为日期对象。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2022-12-12 12:12:11&quot;</span>;<br>        <span class="hljs-comment">// 1、创建简单日期格式化对象 , 指定的时间格式必须与被解析的时间格式一模一样，否则程序会出bug.</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> sdf2.parse(dateStr);<br>        System.out.println(d2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>日期格式化&amp;解析案例</strong></p><p><img src="/assets/1667400116263.png" alt="1667400116263"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-comment">// 目标：完成秒杀案例。</span><br>        <span class="hljs-comment">// 1、把开始时间、结束时间、小贾下单时间、小皮下单时间拿到程序中来。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023年11月11日 0:0:0&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023年11月11日 0:10:0&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">xj</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023年11月11日 0:01:18&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">xp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023年11月11日 0:10:57&quot;</span>;<br><br>        <span class="hljs-comment">// 2、把字符串的时间解析成日期对象。</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">startDt</span> <span class="hljs-operator">=</span> sdf.parse(start);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">endDt</span> <span class="hljs-operator">=</span> sdf.parse(end);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">xjDt</span> <span class="hljs-operator">=</span> sdf.parse(xj);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">xpDt</span> <span class="hljs-operator">=</span> sdf.parse(xp);<br><br>        <span class="hljs-comment">// 3、开始判断小皮和小贾是否秒杀成功了。</span><br>        <span class="hljs-comment">// 把日期对象转换成时间毫秒值来判断</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> startDt.getTime();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> endDt.getTime();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">xjTime</span> <span class="hljs-operator">=</span> xjDt.getTime();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">xpTime</span> <span class="hljs-operator">=</span> xpDt.getTime();<br><br>        <span class="hljs-keyword">if</span>(xjTime &gt;= startTime &amp;&amp; xjTime &lt;= endTime)&#123;<br>            System.out.println(<span class="hljs-string">&quot;小贾您秒杀成功了~~&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;小贾您秒杀失败了~~&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(xpTime &gt;= startTime &amp;&amp; xpTime &lt;= endTime)&#123;<br>            System.out.println(<span class="hljs-string">&quot;小皮您秒杀成功了~~&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;小皮您秒杀失败了~~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、Calendar类"><a href="#七、Calendar类" class="headerlink" title="七、Calendar类"></a>七、Calendar类</h2><p>学完Date类和SimpleDateFormat类之后，我们再学习一个和日期相关的类，它是Calendar类。Calendar类表示日历，它提供了一些比Date类更好用的方法。</p><p>比如下面的案例，用Date类就不太好做，而用Calendar就特别方便。因为Calendar类提供了方法可以直接对日历中的年、月、日、时、分、秒等进行运算。</p><p><img src="/assets/1667400242406.png" alt="1667400242406"></p><p><img src="/assets/1667400365583.png" alt="1667400365583"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4Calendar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握Calendar的使用和特点。</span><br>        <span class="hljs-comment">// 1、得到系统此刻时间对应的日历对象。</span><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        System.out.println(now);<br><br>        <span class="hljs-comment">// 2、获取日历中的某个信息</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> now.get(Calendar.YEAR);<br>        System.out.println(year);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> now.get(Calendar.DAY_OF_YEAR);<br>        System.out.println(days);<br><br>        <span class="hljs-comment">// 3、拿到日历中记录的日期对象。</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> now.getTime();<br>        System.out.println(d);<br><br>        <span class="hljs-comment">// 4、拿到时间毫秒值</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> now.getTimeInMillis();<br>        System.out.println(time);<br><br>        <span class="hljs-comment">// 5、修改日历中的某个信息</span><br>        now.set(Calendar.MONTH, <span class="hljs-number">9</span>); <span class="hljs-comment">// 修改月份成为10月份。</span><br>        now.set(Calendar.DAY_OF_YEAR, <span class="hljs-number">125</span>); <span class="hljs-comment">// 修改成一年中的第125天。</span><br>        System.out.println(now);<br><br>        <span class="hljs-comment">// 6、为某个信息增加或者减少多少</span><br>        now.add(Calendar.DAY_OF_YEAR, <span class="hljs-number">100</span>);<br>        now.add(Calendar.DAY_OF_YEAR, -<span class="hljs-number">10</span>);<br>        now.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">6</span>);<br>        now.add(Calendar.HOUR, <span class="hljs-number">12</span>);<br>        now.set(<span class="hljs-number">2026</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>);<br>        System.out.println(now);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、为什么JDK8要新增日期类"><a href="#八、为什么JDK8要新增日期类" class="headerlink" title="八、为什么JDK8要新增日期类"></a>八、为什么JDK8要新增日期类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标：搞清楚为什么要用JDK 8开始新增的时间类。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 传统的时间类（Date、SimpleDateFormat、Calendar）存在如下问题：</span><br>        <span class="hljs-comment">// 1、设计不合理，使用不方便，很多都被淘汰了。</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">//System.out.println(d.getYear() + 1900);</span><br><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> c.get(Calendar.YEAR);<br>        System.out.println(year);<br><br>        <span class="hljs-comment">// 2、都是可变对象，修改后会丢失最开始的时间信息。</span><br><br>        <span class="hljs-comment">// 3、线程不安全。</span><br><br>        <span class="hljs-comment">// 4、不能精确到纳秒，只能精确到毫秒。</span><br>        <span class="hljs-comment">// 1秒 = 1000毫秒</span><br>        <span class="hljs-comment">// 1毫秒 = 1000微妙</span><br>        <span class="hljs-comment">// 1微妙 = 1000纳秒</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="九、JDK8日期、时间、日期时间"><a href="#九、JDK8日期、时间、日期时间" class="headerlink" title="九、JDK8日期、时间、日期时间"></a>九、JDK8日期、时间、日期时间</h2><p>接下来，我们学习一下JDK8新增的日期类。为什么以前的Date类就可以表示日期，为什么要有新增的日期类呢？原因如下</p><p><img src="/assets/1667400465054.png" alt="1667400465054"></p><p>JDK8新增的日期类分得更细致一些，比如表示年月日用LocalDate类、表示时间秒用LocalTime类、而表示年月日时分秒用LocalDateTime类等；除了这些类还提供了对时区、时间间隔进行操作的类等。它们几乎把对日期&#x2F;时间的所有操作都通过了API方法，用起来特别方便。</p><p><img src="/assets/1667400655334.png" alt="1667400655334"></p><p>先学习表示日期、时间、日期时间的类；有LocalDate、LocalTime、以及LocalDateTime类。仔细阅读代码，你会发现这三个类的用法套路都是一样的。</p><ul><li>LocalDate类的基本使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1_LocalDate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 0、获取本地日期对象(不可变对象)</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.now(); <span class="hljs-comment">// 年 月 日</span><br>        System.out.println(ld);<br><br>        <span class="hljs-comment">// 1、获取日期对象中的信息</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> ld.getYear(); <span class="hljs-comment">// 年</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> ld.getMonthValue(); <span class="hljs-comment">// 月(1-12)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> ld.getDayOfMonth(); <span class="hljs-comment">// 日</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfYear</span> <span class="hljs-operator">=</span> ld.getDayOfYear();  <span class="hljs-comment">// 一年中的第几天</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> ld.getDayOfWeek().getValue(); <span class="hljs-comment">// 星期几</span><br>        System.out.println(year);<br>        System.out.println(day);<br>        System.out.println(dayOfWeek);<br><br>        <span class="hljs-comment">// 2、直接修改某个信息: withYear、withMonth、withDayOfMonth、withDayOfYear</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld2</span> <span class="hljs-operator">=</span> ld.withYear(<span class="hljs-number">2099</span>);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld3</span> <span class="hljs-operator">=</span> ld.withMonth(<span class="hljs-number">12</span>);<br>        System.out.println(ld2);<br>        System.out.println(ld3);<br>        System.out.println(ld);<br><br>        <span class="hljs-comment">// 3、把某个信息加多少: plusYears、plusMonths、plusDays、plusWeeks</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld4</span> <span class="hljs-operator">=</span> ld.plusYears(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld5</span> <span class="hljs-operator">=</span> ld.plusMonths(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 4、把某个信息减多少：minusYears、minusMonths、minusDays、minusWeeks</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld6</span> <span class="hljs-operator">=</span> ld.minusYears(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld7</span> <span class="hljs-operator">=</span> ld.minusMonths(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 5、获取指定日期的LocalDate对象： public static LocalDate of(int year, int month, int dayOfMonth)</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld8</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2099</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld9</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2099</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<br><br>        <span class="hljs-comment">// 6、判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter</span><br>        System.out.println(ld8.equals(ld9));<span class="hljs-comment">// true</span><br>        System.out.println(ld8.isAfter(ld)); <span class="hljs-comment">// true</span><br>        System.out.println(ld8.isBefore(ld)); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>LocalTime类的基本使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2_LocalTime</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 0、获取本地时间对象</span><br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> LocalTime.now(); <span class="hljs-comment">// 时 分 秒 纳秒 不可变的</span><br>        System.out.println(lt);<br><br>        <span class="hljs-comment">// 1、获取时间中的信息</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> lt.getHour(); <span class="hljs-comment">//时</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minute</span> <span class="hljs-operator">=</span> lt.getMinute(); <span class="hljs-comment">//分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> lt.getSecond(); <span class="hljs-comment">//秒</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nano</span> <span class="hljs-operator">=</span> lt.getNano(); <span class="hljs-comment">//纳秒</span><br><br>        <span class="hljs-comment">// 2、修改时间：withHour、withMinute、withSecond、withNano</span><br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt3</span> <span class="hljs-operator">=</span> lt.withHour(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt4</span> <span class="hljs-operator">=</span> lt.withMinute(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt5</span> <span class="hljs-operator">=</span> lt.withSecond(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt6</span> <span class="hljs-operator">=</span> lt.withNano(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos</span><br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt7</span> <span class="hljs-operator">=</span> lt.plusHours(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt8</span> <span class="hljs-operator">=</span> lt.plusMinutes(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt9</span> <span class="hljs-operator">=</span> lt.plusSeconds(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt10</span> <span class="hljs-operator">=</span> lt.plusNanos(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos</span><br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt11</span> <span class="hljs-operator">=</span> lt.minusHours(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt12</span> <span class="hljs-operator">=</span> lt.minusMinutes(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt13</span> <span class="hljs-operator">=</span> lt.minusSeconds(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt14</span> <span class="hljs-operator">=</span> lt.minusNanos(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 5、获取指定时间的LocalTime对象：</span><br>        <span class="hljs-comment">// public static LocalTime of(int hour, int minute, int second)</span><br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt15</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt16</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<br><br>        <span class="hljs-comment">// 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter</span><br>        System.out.println(lt15.equals(lt16)); <span class="hljs-comment">// true</span><br>        System.out.println(lt15.isAfter(lt)); <span class="hljs-comment">// false</span><br>        System.out.println(lt15.isBefore(lt)); <span class="hljs-comment">// true</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>LocalDateTime类的基本使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3_LocalDateTime</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 0、获取本地日期和时间对象。</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now(); <span class="hljs-comment">// 年 月 日 时 分 秒 纳秒</span><br>        System.out.println(ldt);<br><br>        <span class="hljs-comment">// 1、可以获取日期和时间的全部信息</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> ldt.getYear(); <span class="hljs-comment">// 年</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> ldt.getMonthValue(); <span class="hljs-comment">// 月</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> ldt.getDayOfMonth(); <span class="hljs-comment">// 日</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfYear</span> <span class="hljs-operator">=</span> ldt.getDayOfYear();  <span class="hljs-comment">// 一年中的第几天</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> ldt.getDayOfWeek().getValue();  <span class="hljs-comment">// 获取是周几</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> ldt.getHour(); <span class="hljs-comment">//时</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minute</span> <span class="hljs-operator">=</span> ldt.getMinute(); <span class="hljs-comment">//分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> ldt.getSecond(); <span class="hljs-comment">//秒</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nano</span> <span class="hljs-operator">=</span> ldt.getNano(); <span class="hljs-comment">//纳秒</span><br><br>        <span class="hljs-comment">// 2、修改时间信息：</span><br>        <span class="hljs-comment">// withYear withMonth withDayOfMonth withDayOfYear withHour</span><br>        <span class="hljs-comment">// withMinute withSecond withNano</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt2</span> <span class="hljs-operator">=</span> ldt.withYear(<span class="hljs-number">2029</span>);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt3</span> <span class="hljs-operator">=</span> ldt.withMinute(<span class="hljs-number">59</span>);<br><br>        <span class="hljs-comment">// 3、加多少:</span><br>        <span class="hljs-comment">// plusYears  plusMonths plusDays plusWeeks plusHours plusMinutes plusSeconds plusNanos</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt4</span> <span class="hljs-operator">=</span> ldt.plusYears(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt5</span> <span class="hljs-operator">=</span> ldt.plusMinutes(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 4、减多少：</span><br>        <span class="hljs-comment">// minusDays minusYears minusMonths minusWeeks minusHours minusMinutes minusSeconds minusNanos</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt6</span> <span class="hljs-operator">=</span> ldt.minusYears(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt7</span> <span class="hljs-operator">=</span> ldt.minusMinutes(<span class="hljs-number">3</span>);<br><br><br>        <span class="hljs-comment">// 5、获取指定日期和时间的LocalDateTime对象：</span><br>        <span class="hljs-comment">// public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour,</span><br>        <span class="hljs-comment">//                                  int minute, int second, int nanoOfSecond)</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt8</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2029</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1222</span>);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt9</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2029</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1222</span>);<br><br>        <span class="hljs-comment">// 6、 判断2个日期、时间对象，是否相等，在前还是在后： equals、isBefore、isAfter</span><br>        System.out.println(ldt9.equals(ldt8));<br>        System.out.println(ldt9.isAfter(ldt));<br>        System.out.println(ldt9.isBefore(ldt));<br><br>        <span class="hljs-comment">// 7、可以把LocalDateTime转换成LocalDate和LocalTime</span><br>        <span class="hljs-comment">// public LocalDate toLocalDate()</span><br>        <span class="hljs-comment">// public LocalTime toLocalTime()</span><br>        <span class="hljs-comment">// public static LocalDateTime of(LocalDate date, LocalTime time)</span><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> ldt.toLocalDate();<br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> ldt.toLocalTime();<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt10</span> <span class="hljs-operator">=</span> LocalDateTime.of(ld, lt);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十、JDK8日期（时区）"><a href="#十、JDK8日期（时区）" class="headerlink" title="十、JDK8日期（时区）"></a>十、JDK8日期（时区）</h2><p>接着，我们学习代表时区的两个类。由于世界各个国家与地区的经度不同，各地区的时间也有所不同，因此会划分为不同的时区。每一个时区的时间也不太一样。</p><p><img src="/assets/1667400888534.png" alt="1667400888534"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4_ZoneId_ZonedDateTime</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：了解时区和带时区的时间。</span><br>        <span class="hljs-comment">// 1、ZoneId的常见方法：</span><br>        <span class="hljs-comment">// public static ZoneId systemDefault(): 获取系统默认的时区</span><br>        <span class="hljs-type">ZoneId</span> <span class="hljs-variable">zoneId</span> <span class="hljs-operator">=</span> ZoneId.systemDefault();<br>        System.out.println(zoneId.getId());<br>        System.out.println(zoneId);<br><br>        <span class="hljs-comment">// public static Set&lt;String&gt; getAvailableZoneIds(): 获取Java支持的全部时区Id</span><br>        System.out.println(ZoneId.getAvailableZoneIds());<br><br>        <span class="hljs-comment">// public static ZoneId of(String zoneId) : 把某个时区id封装成ZoneId对象。</span><br>        <span class="hljs-type">ZoneId</span> <span class="hljs-variable">zoneId1</span> <span class="hljs-operator">=</span> ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>);<br><br>        <span class="hljs-comment">// 2、ZonedDateTime：带时区的时间。</span><br>        <span class="hljs-comment">// public static ZonedDateTime now(ZoneId zone): 获取某个时区的ZonedDateTime对象。</span><br>        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> ZonedDateTime.now(zoneId1);<br>        System.out.println(now);<br><br>        <span class="hljs-comment">// 世界标准时间了</span><br>        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">now1</span> <span class="hljs-operator">=</span> ZonedDateTime.now(Clock.systemUTC());<br>        System.out.println(now1);<br><br>        <span class="hljs-comment">// public static ZonedDateTime now()：获取系统默认时区的ZonedDateTime对象</span><br>        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">now2</span> <span class="hljs-operator">=</span> ZonedDateTime.now();<br>        System.out.println(now2);<br><br>        <span class="hljs-comment">// Calendar instance = Calendar.getInstance(TimeZone.getTimeZone(zoneId1));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十一、JDK8日期（Instant类）"><a href="#十一、JDK8日期（Instant类）" class="headerlink" title="十一、JDK8日期（Instant类）"></a>十一、JDK8日期（Instant类）</h2><p>接下来，我们来学习Instant这个类。通过获取Instant的对象可以拿到此刻的时间，该时间由两部分组成：从1970-01-01 00:00:00 开始走到此刻的总秒数+不够1秒的纳秒数。</p><p><img src="/assets/1667401284295.png" alt="1667401284295"></p><p>该类提供的方法如下图所示，可以用来获取当前时间，也可以对时间进行加、减、获取等操作。</p><p><img src="/assets/1667401373923.png" alt="1667401373923"></p><p><strong>作用：可以用来记录代码的执行时间，或用于记录用户操作某个事件的时间点。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握Instant的使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5_Instant</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">// 1、创建Instant的对象，获取此刻时间信息</span><br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Instant.now(); <span class="hljs-comment">// 不可变对象</span><br><br>        <span class="hljs-comment">// 2、获取总秒数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> now.getEpochSecond();<br>        System.out.println(second);<br><br>        <span class="hljs-comment">// 3、不够1秒的纳秒数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nano</span> <span class="hljs-operator">=</span> now.getNano();<br>        System.out.println(nano);<br><br>        System.out.println(now);<br><br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> now.plusNanos(<span class="hljs-number">111</span>);<br><br>        <span class="hljs-comment">// Instant对象的作用：做代码的性能分析，或者记录用户的操作时间点</span><br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">now1</span> <span class="hljs-operator">=</span> Instant.now();<br>        <span class="hljs-comment">// 代码执行。。。。</span><br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">now2</span> <span class="hljs-operator">=</span> Instant.now();<br><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、JDK8日期（格式化器）"><a href="#十二、JDK8日期（格式化器）" class="headerlink" title="十二、JDK8日期（格式化器）"></a>十二、JDK8日期（格式化器）</h2><p>接下来，我们学习一个新增的日期格式化类，叫DateTimeFormater。它可以从来对日期进行格式化和解析。它代替了原来的SimpleDateFormat类。</p><p><img src="/assets/1667401511710.png" alt="1667401511710"></p><p>需要用到的方法，如下图所示</p><p><img src="/assets/1667401564173.png" alt="1667401564173"></p><p>接下来，将上面的方法用代码来演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  目标：掌握JDK 8新增的DateTimeFormatter格式化器的用法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test6_DateTimeFormatter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建一个日期时间格式化器对象出来。</span><br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br><br>        <span class="hljs-comment">// 2、对时间进行格式化</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        System.out.println(now);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> formatter.format(now); <span class="hljs-comment">// 正向格式化</span><br>        System.out.println(rs);<br><br>        <span class="hljs-comment">// 3、格式化时间，其实还有一种方案。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> now.format(formatter); <span class="hljs-comment">// 反向格式化</span><br>        System.out.println(rs2);<br><br>        <span class="hljs-comment">// 4、解析时间：解析时间一般使用LocalDateTime提供的解析方法来解析。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2029年12月12日 12:12:11&quot;</span>;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.parse(dateStr, formatter);<br>        System.out.println(ldt);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="十三、JDK8日期（Period类）"><a href="#十三、JDK8日期（Period类）" class="headerlink" title="十三、JDK8日期（Period类）"></a>十三、JDK8日期（Period类）</h2><p>除以了上新增的类，JDK8还补充了两个类，一个叫Period类、一个叫Duration类；这两个类可以用来对计算两个时间点的时间间隔。</p><p>其中Period用来计算日期间隔（年、月、日），Duration用来计算时间间隔（时、分、秒、纳秒）</p><p><img src="/assets/1667401637360.png" alt="1667401637360"></p><p>先来演示Period类的用法，它的方法如下图所示。可以用来计算两个日期之间相隔的年、相隔的月、相隔的日。<strong>只能两个计算LocalDate对象之间的间隔</strong></p><p><img src="/assets/1667401886743.png" alt="1667401886743"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标：掌握Period的作用：计算机两个日期相差的年数，月数、天数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test7_Period</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br><br>        <span class="hljs-comment">// 1、创建Period对象，封装两个日期对象。</span><br>        <span class="hljs-type">Period</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> Period.between(start, end);<br><br>        <span class="hljs-comment">// 2、通过period对象获取两个日期对象相差的信息。</span><br>        System.out.println(period.getYears());<br>        System.out.println(period.getMonths());<br>        System.out.println(period.getDays());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十四、JDK8日期（Duration类）"><a href="#十四、JDK8日期（Duration类）" class="headerlink" title="十四、JDK8日期（Duration类）"></a>十四、JDK8日期（Duration类）</h2><p>接下来，我们学习Duration类。它是用来表示两个时间对象的时间间隔。<strong>可以用于计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant等时间</strong></p><p><img src="/assets/1667401938724.png" alt="1667401938724"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8_Duration</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<br>        <span class="hljs-comment">// 1、得到Duration对象</span><br>        <span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);<br><br>        <span class="hljs-comment">// 2、获取两个时间对象间隔的信息</span><br>        System.out.println(duration.toDays());<span class="hljs-comment">// 间隔多少天</span><br>        System.out.println(duration.toHours());<span class="hljs-comment">// 间隔多少小时</span><br>        System.out.println(duration.toMinutes());<span class="hljs-comment">// 间隔多少分</span><br>        System.out.println(duration.toSeconds());<span class="hljs-comment">// 间隔多少秒</span><br>        System.out.println(duration.toMillis());<span class="hljs-comment">// 间隔多少毫秒</span><br>        System.out.println(duration.toNanos());<span class="hljs-comment">// 间隔多少纳秒</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day03--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/12/01/day03--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="day03——面向对象高级"><a href="#day03——面向对象高级" class="headerlink" title="day03——面向对象高级"></a>day03——面向对象高级</h1><p>各位同学，前面两天我们已经把面向对象最主要的内容学习完了，剩下的这些语法知识学完，那么Java语法知识就算全齐活了。</p><p>今天学习的内容同学们学习起来会更轻松一些，有一些语法知识只需要了解一下就可以了，因为实际工作用得并不多。</p><p>我们先来了解第一个语法知识，内部类。</p><h2 id="一、内部类"><a href="#一、内部类" class="headerlink" title="一、内部类"></a>一、内部类</h2><p> 内部类是类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），如果一个类定义在另一个类的内部，这个类就是内部类。</p><p>当一个类的内部，包含一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。</p><p>比如：汽车、的内部有发动机，发动机是包含在汽车内部的一个完整事物，可以把发动机设计成内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br><span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内部类有四种形式，分别是成员内部类、静态内部类、局部内部类、匿名内部类。</p><p>我们先来学习成员内部类</p><h3 id="1-1-成员内部类"><a href="#1-1-成员内部类" class="headerlink" title="1.1 成员内部类"></a>1.1 成员内部类</h3><p>成员内部类就是类中的一个普通成员，类似于成员变量、成员方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String a=<span class="hljs-string">&quot;黑马&quot;</span>;<br><br>    <span class="hljs-comment">// 成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">88</span>;<br><br>        <span class="hljs-comment">//在内部类中既可以访问自己类的成员，也可以访问外部类的成员</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(age); <span class="hljs-comment">//88</span><br>            System.out.println(a);   <span class="hljs-comment">//黑马</span><br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">77</span>;<br>            System.out.println(age); <span class="hljs-comment">//77</span><br>            System.out.println(<span class="hljs-built_in">this</span>.age); <span class="hljs-comment">//88</span><br>            System.out.println(Outer.<span class="hljs-built_in">this</span>.age); <span class="hljs-comment">//99</span><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员内部类如何创建对象，格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//外部类.内部类 变量名 = new 外部类().new 内部类();</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br><span class="hljs-comment">//调用内部类的方法</span><br>in.test();<br></code></pre></td></tr></table></figure><p>总结一下内部类访问成员的特点</p><ul><li>既可以访问内部类成员、也可以访问外部类成员</li><li>如果内部类成员和外部类成员同名，可以使用**<code>类名.this.成员</code>**区分</li></ul><h3 id="1-2-静态内部类"><a href="#1-2-静态内部类" class="headerlink" title="1.2 静态内部类"></a>1.2 静态内部类</h3><p>静态内部类，其实就是在成员内部类的前面加了一个static关键字。静态内部类属于外部类自己持有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String schoolName=<span class="hljs-string">&quot;黑马&quot;</span>;<br><br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-comment">//静态内部类访问外部类的静态变量，是可以的；</span><br>        <span class="hljs-comment">//静态内部类访问外部类的实例变量，是不行的</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(schoolName); <span class="hljs-comment">//99</span><br>            <span class="hljs-comment">//System.out.println(age);   //报错</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态内部类创建对象时，需要使用外部类的类名调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//格式：外部类.内部类 变量名 = new 外部类.内部类();</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br>in.test();<br></code></pre></td></tr></table></figure><h3 id="1-3-局部内部类"><a href="#1-3-局部内部类" class="headerlink" title="1.3 局部内部类"></a>1.3 局部内部类</h3><p>局部内部类是定义在方法中的类，和局部变量一样，只能在方法中有效。所以局部内部类的局限性很强，一般在开发中是不会使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Inner...show&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//局部内部类只能在方法中创建对象，并使用</span><br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        in.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4 匿名内部类"></a>1.4 匿名内部类</h3><blockquote><p><strong>1.4.1 认识匿名内部类，基本使用</strong></p></blockquote><p>各位同学，接下来学习一种再实际开发中用得最多的一种内部类，叫匿名内部类。相比于前面几种内部类，匿名内部类就比较重要的。</p><p>我们还是先认识一下什么是匿名内部类？</p><p>匿名内部类是一种特殊的局部内部类；所谓匿名，指的是程序员不需要为这个类声明名字。</p><p>下面就是匿名内部类的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类/接口(参数值)&#123;<br>    <span class="hljs-meta">@Override</span><br>    重写父类/接口的方法;<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名内部类本质上是一个没有名字的子类对象、或者接口的实现类对象。</p><p>比如，先定义一个Animal抽象类，里面定义一个cry()方法，表示所有的动物有叫的行为，但是因为动物还不具体，cry()这个行为并不能具体化，所以写成抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我想要在不定义子类的情况下创建Animal的子类对象，就可以使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//这里后面new 的部分，其实就是一个Animal的子类对象</span><br>        <span class="hljs-comment">//这里隐含的有多态的特性： Animal a = Animal子类对象;</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;猫喵喵喵的叫~~~&quot;</span>);<br>            &#125;<br>        &#125;<br>        a.eat(); <span class="hljs-comment">//直线上面重写的cry()方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，匿名内部类在编写代码时没有名字，编译后系统会为自动为匿名内部类生产字节码，字节码的名称会以<code>外部类$1.class</code>的方法命名</p><p><img src="/assets/1665658585267.png" alt="1665658585267"></p><p><strong>匿名内部类的作用：简化了创建子类对象、实现类对象的书写格式。</strong></p><blockquote><p><strong>1.4.2 匿名内部类的应用场景</strong></p></blockquote><p>学习完匿名内部类的基本使用之后，我们再来看一下匿名内部类在实际中的应用场景。其实一般我们会主动的使用匿名内部类。</p><p><strong>只有在调用方法时，当方法的形参是一个接口或者抽象类，为了简化代码书写，而直接传递匿名内部类对象给方法。</strong>这样就可以少写一个类。比如，看下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimming</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Swimming</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swimming</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;狗刨飞快&quot;</span>);<br>            &#125;<br>        &#125;;<br>        go(s1);<br>        <br>        <span class="hljs-type">Swimming</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swimming</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;猴子游泳也还行&quot;</span>);<br>            &#125;<br>        &#125;;<br>        go(s1);<br>    &#125;<br>    <span class="hljs-comment">//形参是Swimming接口，实参可以接收任意Swimming接口的实现类对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Swimming s)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始~~~~~~~~&quot;</span>);<br>        s.swim();<br>        System.out.println(<span class="hljs-string">&quot;结束~~~~~~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、枚举"><a href="#二、枚举" class="headerlink" title="二、枚举"></a>二、枚举</h2><h3 id="2-1-认识枚举"><a href="#2-1-认识枚举" class="headerlink" title="2.1 认识枚举"></a>2.1 认识枚举</h3><blockquote><p><strong>2.1.1 认识枚举、枚举的原理</strong></p></blockquote><p>同学们，接下来我们学习一个新的知识点，枚举。枚举是我们以后在项目开发中偶尔会用到的知识。话不多说，我们还是先来认识一下枚举。</p><p>枚举是一种特殊的类，它的格式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> 枚举类名&#123;<br>    枚举项<span class="hljs-number">1</span>,枚举项<span class="hljs-number">2</span>,枚举项<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实枚举项就表示枚举类的对象，只是这些对象在定义枚举类时就预先写好了，以后就只能用这几个固定的对象。</p><p>我们用代码演示一下，定义一个枚举类A，在枚举类中定义三个枚举项X, Y, Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">A</span>&#123;<br>    X,Y,Z;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要获取枚举类中的枚举项，只需要用类名调用就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//获取枚举A类的，枚举项</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> A.X;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> A.Y;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> A.Z;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>刚才说，枚举项实际上是枚举类的对象，这一点其实可以通过反编译的形式来验证（需要用到反编译的命令，这里不能直接将字节码拖进idea反编译）</p><p><img src="/assets/1665669996020.png" alt="1665669996020"></p><p>我们会看到，枚举类A是用class定义的，说明枚举确实是一个类，而且X，Y，Z都是A类的对象；而且每一个枚举项都是被<code>public static final </code>修饰，所以被可以类名调用，而且不能更改。</p><blockquote><p><strong>2.1.2 枚举深入</strong></p></blockquote><p>既然枚举是一个类的话，我们能不能在枚举类中定义构造器、成员变量、成员方法呢？答案是可以的。来看一下代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//定义枚举项</span><br>    X,Y,Z(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">//枚举项后面加括号，就是在执行枚举类的带参数构造方法。</span><br>    <br>    <span class="hljs-comment">//定义空构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//定义带参数构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然枚举类中可以像类一样，写一些类的其他成员，但是一般不会这么写，如果你真要这么干的话，到不如直接写普通类来的直接。</p><h3 id="2-2-枚举的应用场景"><a href="#2-2-枚举的应用场景" class="headerlink" title="2.2 枚举的应用场景"></a>2.2 枚举的应用场景</h3><p>刚才我们认识了一下什么是枚举，接下来我们看一下枚举在实际中的运用，枚举的应用场景是这样的：<strong>枚举一般表示一组信息，然后作为参数进行传输。</strong></p><p>我们来看一个案例。比如我们现在有这么一个应用，用户进入应用时，需要让用户选择是女生、还是男生，然后系统会根据用户选择的是男生，还是女生推荐不同的信息给用户观看。</p><p><img src="/assets/1665670887179.png" alt="1665670887179"></p><p>这里我们就可以先定义一个枚举类，用来表示男生、或者女生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constant</span>&#123;<br>    BOY,GRIL<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义一个测试类，完成用户进入系统后的选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//调用方法，传递男生</span><br>        provideInfo(Constant.BOY);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">provideInfo</span><span class="hljs-params">(Constant c)</span>&#123;<br>        <span class="hljs-keyword">switch</span>(c)&#123;<br>            <span class="hljs-keyword">case</span> BOY:<br>                System.out.println(<span class="hljs-string">&quot;展示一些信息给男生看&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> GRIL:<br>                System.out.println(<span class="hljs-string">&quot;展示一些信息给女生看&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终再总结一下枚举的应用场景：<strong>枚举一般表示几个固定的值，然后作为参数进行传输</strong>。</p><h2 id="三、泛型"><a href="#三、泛型" class="headerlink" title="三、泛型"></a>三、泛型</h2><h3 id="3-1-认识泛型"><a href="#3-1-认识泛型" class="headerlink" title="3.1 认识泛型"></a>3.1 认识泛型</h3><p>所谓泛型指的是，在定义类、接口、方法时，同时声明了一个或者多个类型变量（如：<E>），称为泛型类、泛型接口、泛型方法、它们统称为泛型。</p><p>比如我们前面学过的ArrayList类就是一个泛型类，我们可以打开API文档看一下ArrayList类的声明。</p><p><img src="/assets/1665671616852.png" alt="1665671616852"></p><p>ArrayList集合的设计者在定义ArrayList集合时，就已经明确ArrayList集合时给别人装数据用的，但是别人用ArrayList集合时候，装什么类型的数据他不知道，所以就用一个<code>&lt;E&gt;</code>表示元素的数据类型。</p><p>当别人使用ArrayList集合创建对象时，<code>new ArrayList&lt;String&gt; </code>就表示元素为String类型，<code>new ArrayList&lt;Integer&gt;</code>表示元素为Integer类型。</p><p><img src="/assets/1665671987771.png" alt="1665671987771"></p><p>我们总结一下泛型的作用、本质：</p><ul><li><p><strong>泛型的好处：在编译阶段可以避免出现一些非法的数据。</strong></p></li><li><p><strong>泛型的本质：把具体的数据类型传递给类型变量。</strong></p></li></ul><h3 id="3-2-自定义泛型类"><a href="#3-2-自定义泛型类" class="headerlink" title="3.2 自定义泛型类"></a>3.2 自定义泛型类</h3><p>接下来我们学习一下自定义泛型类，但是有一些话需要给大家提前交代一下：泛型类，在实际工作中一般都是源代码中写好，我们直接用的，就是ArrayList<E>这样的，自己定义泛型类是非常少的。</p><p>自定义泛型类的格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里的&lt;T,W&gt;其实指的就是类型变量，可以是一个，也可以是多个。</span><br><span class="hljs-keyword">public</span> class 类名&lt;T,W&gt;&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们自己定义一个MyArrayList<E>泛型类，模拟一下自定义泛型类的使用。注意这里重点仅仅只是模拟泛型类的使用，所以方法中的一些逻辑是次要的，也不会写得太严谨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型类，用来表示一个容器</span><br><span class="hljs-comment">//容器中存储的数据，它的类型用&lt;E&gt;先代替用着，等调用者来确认&lt;E&gt;的具体类型。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-comment">//定一个索引，方便对数组进行操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br>    <br>    <span class="hljs-comment">//添加元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>&#123;<br>        array[index]=e;<br>        index++;<br>    &#125;<br>    <br>    <span class="hljs-comment">//获取元素</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">return</span> (E)array[index];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们写一个测试类，来测试自定义的泛型类MyArrayList是否能够正常使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.确定MyArrayList集合中，元素类型为String类型</span><br>        MyArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//此时添加元素时，只能添加String类型</span><br>        list.add(<span class="hljs-string">&quot;张三&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>        <br>         <span class="hljs-comment">//2.确定MyArrayList集合中，元素类型为Integer类型</span><br>        MyArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//此时添加元素时，只能添加String类型</span><br>        list.add(<span class="hljs-number">100</span>);<br>        list.add(<span class="hljs-number">200</span>);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于自定义泛型类，你们把这个案例理解，对于初学者来说，就已经非常好了。</p><h3 id="3-3-自定义泛型接口"><a href="#3-3-自定义泛型接口" class="headerlink" title="3.3 自定义泛型接口"></a>3.3 自定义泛型接口</h3><p>在上一节中，我们已经学习了自定义泛型类，接下来我们学习一下泛型接口。泛型接口其实指的是在接口中把不确定的数据类型用<code>&lt;类型变量&gt;</code>表示。定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里的类型变量，一般是一个字母，比如&lt;E&gt;</span><br><span class="hljs-keyword">public</span> interface 接口名&lt;类型变量&gt;&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>比如，我们现在要做一个系统要处理学生和老师的数据，需要提供2个功能，保存对象数据、根据名称查询数据，要求：这两个功能处理的数据既能是老师对象，也能是学生对象。</p><p>首先我们得有一个学生类和老师类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们定义一个<code>Data&lt;T&gt;</code>泛型接口，T表示接口中要处理数据的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T t)</span>;<br>    <br>    <span class="hljs-keyword">public</span> ArrayList&lt;T&gt; <span class="hljs-title function_">getByName</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们写一个处理Teacher对象的接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此时确定Data&lt;E&gt;中的E为Teacher类型，</span><br><span class="hljs-comment">//接口中add和getByName方法上的T也都会变成Teacher类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span>&lt;Teacher&gt;&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Teacher t)</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ArrayList&lt;Teacher&gt; <span class="hljs-title function_">getByName</span><span class="hljs-params">(String name)</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们写一个处理Student对象的接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此时确定Data&lt;E&gt;中的E为Student类型，</span><br><span class="hljs-comment">//接口中add和getByName方法上的T也都会变成Student类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span>&lt;Student&gt;&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Student t)</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">getByName</span><span class="hljs-params">(String name)</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再啰嗦几句，在实际工作中，一般也都是框架底层源代码把泛型接口写好，我们实现泛型接口就可以了。</p><h3 id="3-4-泛型方法"><a href="#3-4-泛型方法" class="headerlink" title="3.4 泛型方法"></a>3.4 泛型方法</h3><p>同学们，接下来我们学习一下泛型方法。下面就是泛型方法的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;泛型变量,泛型变量&gt; 返回值类型 方法名(形参列表)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>下图中在返回值类型和修饰符之间有<T>定义的才是泛型方法。</p><p><img src="/assets/1665750638693.png" alt="1665750638693"></p><p>接下我们看一个泛型方法的案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//调用test方法，传递字符串数据，那么test方法的泛型就是String类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> test(<span class="hljs-string">&quot;test&quot;</span>);<br>    <br>        <span class="hljs-comment">//调用test方法，传递Dog对象，那么test方法的泛型就是Dog类型</span><br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> test(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()); <br>    &#125;<br>    <br>    <span class="hljs-comment">//这是一个泛型方法&lt;T&gt;表示一个不确定的数据类型，由调用者确定</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; test(T t)&#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-泛型限定"><a href="#3-5-泛型限定" class="headerlink" title="3.5 泛型限定"></a>3.5 泛型限定</h3><p>接着，我们来学习一个泛型的特殊用法，叫做泛型限定。泛型限定的意思是对泛型的数据类型进行范围的限制。有如下的三种格式</p><ul><li><?> 表示任意类型</li><li><? extends 数据类型> 表示指定类型或者指定类型的子类</li><li><? super 数据类型> 表示指定类型或者指定类型的父类</li></ul><p>下面我们演示一下，假设有Car作为父类，BENZ，BWM两个类作为Car的子类，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BENZ</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BWN</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span>&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.集合中的元素不管是什么类型，test1方法都能接收</span><br>        ArrayList&lt;BWM&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;Benz&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;String&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        test1(list1);<br>        test1(list2);<br>        test1(list3);<br>        <br>        <span class="hljs-comment">//2.集合中的元素只能是Car或者Car的子类类型，才能被test2方法接收</span><br>        ArrayList&lt;Car&gt; list4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;BWM&gt; list5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        test2(list4);<br>        test2(list5);<br>        <br>        <span class="hljs-comment">//2.集合中的元素只能是Car或者Car的父类类型，才能被test3方法接收</span><br>        ArrayList&lt;Car&gt; list6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;Object&gt; list7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        test3(list6);<br>        test3(list7);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(ArrayList&lt;?&gt; list)</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(ArrayList&lt;? extends Car&gt; list)</span>&#123;<br>        <br>    &#125;<br>    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">(ArrayList&lt;? <span class="hljs-built_in">super</span> Car&gt; list)</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-泛型擦除"><a href="#3-6-泛型擦除" class="headerlink" title="3.6 泛型擦除"></a>3.6 泛型擦除</h3><p>最后，关于泛型还有一个特点需要给同学们介绍一下，就是泛型擦除。什么意思呢？<strong>也就是说泛型只能编译阶段有效，一旦编译成字节码，字节码中是不包含泛型的</strong>。而且泛型只支持引用数据类型，不支持基本数据类型。</p><p>把下面的代码的字节码进行反编译</p><p><img src="/assets/1665752105271.png" alt="1665752105271"></p><p>下面是反编译之后的代码，我们发现ArrayList后面没有泛型</p><p><img src="/assets/1665752037764.png" alt="1665752037764"></p><h2 id="四、常用API"><a href="#四、常用API" class="headerlink" title="四、常用API"></a>四、常用API</h2><p>各位同学，恭喜大家，到目前位置我们关于面向对象的语法知识就全部学习完了。接下来我们就可以拿着这些语法知识，去学习一个一个的API方法，掌握的API方法越多，那么Java的编程能力就越强。</p><p> API（Application Programming interface）意思是应用程序编程接口，说人话就是Java帮我们写好的一些程序，如：类、方法等，我们直接拿过来用就可以解决一些问题。</p><p><img src="/assets/1665752705389.png" alt="1665752705389"></p><p>我们要学习那些API呢？把下面一种图中的所有类的常用方法学会了，那我们JavaSE进阶的课程就算你全学会了。</p><p><img src="/assets/1665752813753.png" alt="1665752813753"></p><p>很多初学者给我反应的问题是，这些API一听就会，但是就是记住不！送同学们一句话<strong>，</strong></p><p><strong>“千里之行始于足下，多记、多查、多些代码、孰能生巧！”</strong></p><p><img src="/assets/1665752883617.png" alt="1665752883617"></p><h3 id="4-1-Object类"><a href="#4-1-Object类" class="headerlink" title="4.1 Object类"></a>4.1 Object类</h3><p>各位小伙伴，我们要学习的第一个API就是Object类。Object类是Java中所有类的祖宗类，因此，Java中所有类的对象都可以直接使用Object类中提供的一些方法。</p><p>按照下图的提示，可以搜索到你想要找的类</p><p><img src="/assets/1665753230409.png" alt="1665753230409"></p><p>我们找到Object类的下面两个方法</p><p><img src="/assets/1665753282718.png" alt="1665753282718"></p><ul><li><strong>4.1.1 toString()方法</strong></li></ul><p>我们先来学习toString()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br>    调用toString()方法可以返回对象的字符串表示形式。<br>    默认的格式是：“包名.类名@哈希值<span class="hljs-number">16</span>进制”<br></code></pre></td></tr></table></figure><p>假设有一个学生类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;赵敏&quot;</span>,<span class="hljs-number">23</span>);<br>        System.out.println(s1.toString()); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果如下</p><p><img src="/assets/1665753662732.png" alt="1665753662732"></p><p>如果，在Student类重写toString()方法，那么我们可以返回对象的属性值，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;name=‘&quot;</span>+name+<span class="hljs-string">&quot;’, age=&quot;</span>+age+<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试类，结果如下</p><p><img src="/assets/1665754067446.png" alt="1665754067446"></p><blockquote><p><strong>4.1.2 equals(Object o)方法</strong></p></blockquote><p>接下来，我们学习一下Object类的equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span><br>    判断此对象与参数对象是否<span class="hljs-string">&quot;相等&quot;</span><br></code></pre></td></tr></table></figure><p>我们写一个测试类，测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;赵薇&quot;</span>,<span class="hljs-number">23</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;赵薇&quot;</span>,<span class="hljs-number">23</span>);<br>        <br>        <span class="hljs-comment">//equals本身也是比较对象的地址，和&quot;==&quot;没有区别</span><br>        System.out.println(s1.equals(s2)); <span class="hljs-comment">//false</span><br>         <span class="hljs-comment">//&quot;==&quot;比较对象的地址</span><br>        System.out.println(s1==s2); <span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们在Student类中，把equals方法重写了，就按照对象的属性值进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;name=‘&quot;</span>+name+<span class="hljs-string">&quot;’, age=&quot;</span>+age+<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//重写equals方法，按照对象的属性值进行比较</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) o;<br><br>        <span class="hljs-keyword">if</span> (age != student.age) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> name != <span class="hljs-literal">null</span> ? name.equals(student.name) : student.name == <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再运行测试类，效果如下</p><p><img src="/assets/1665754859931.png" alt="1665754859931"></p><p>总结一下Object的toString方法和equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br>   返回对象的字符串表示形式。默认的格式是：“包名.类名@哈希值<span class="hljs-number">16</span>进制”<br>   【子类重写后，返回对象的属性值】<br>   <br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span><br>    判断此对象与参数对象是否<span class="hljs-string">&quot;相等&quot;</span>。默认比较对象的地址值，和<span class="hljs-string">&quot;==&quot;</span>没有区别<br>    【子类重写后，比较对象的属性值】<br></code></pre></td></tr></table></figure><blockquote><p><strong>4.1.3 clone() 方法</strong></p></blockquote><p>接下来，我们学习Object类的clone()方法，克隆。意思就是某一个对象调用这个方法，这个方法会复制一个一模一样的新对象，并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span><br>    克隆当前对象，返回一个新对象<br></code></pre></td></tr></table></figure><p>想要调用clone()方法，必须让被克隆的类实现Cloneable接口。如我们准备克隆User类的对象，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String id; <span class="hljs-comment">//编号</span><br>    <span class="hljs-keyword">private</span> String username; <span class="hljs-comment">//用户名</span><br>    <span class="hljs-keyword">private</span> String password; <span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span>[] scores; <span class="hljs-comment">//分数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String id, String username, String password, <span class="hljs-type">double</span>[] scores)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.scores = scores;<br>    &#125;<br><br>    <span class="hljs-comment">//...get和set...方法自己加上</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们写一个测试类，克隆User类的对象。并观察打印的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;wo666&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[]&#123;<span class="hljs-number">99.0</span>,<span class="hljs-number">99.5</span>&#125;);<br><span class="hljs-comment">//调用方法克隆得到一个新对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> (User) u1.clone();<br>        System.out.println(u2.getId());<br>        System.out.println(u2.getUsername());<br>        System.out.println(u2.getPassword());<br>        System.out.println(u2.getScores()); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，克隆得到的对象u2它的属性值和原来u1对象的属性值是一样的。</p><p><img src="/assets/1665757008178.png" alt="1665757008178"></p><p>上面演示的克隆方式，是一种浅克隆的方法，浅克隆的意思：<strong>拷贝出来的对象封装的数据与原对象封装的数据一模一样（引用类型拷贝的是地址值）</strong>。如下图所示</p><p><img src="/assets/1665757187877.png" alt="1665757187877"></p><p>还有一种拷贝方式，称之为深拷贝，拷贝原理如下图所示</p><p><img src="/assets/1665757265609.png" alt="1665757265609"></p><p>下面演示一下深拷贝User对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String id; <span class="hljs-comment">//编号</span><br>    <span class="hljs-keyword">private</span> String username; <span class="hljs-comment">//用户名</span><br>    <span class="hljs-keyword">private</span> String password; <span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span>[] scores; <span class="hljs-comment">//分数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String id, String username, String password, <span class="hljs-type">double</span>[] scores)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.scores = scores;<br>    &#125;<br><br>    <span class="hljs-comment">//...get和set...方法自己加上</span><br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-comment">//先克隆得到一个新对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (User) <span class="hljs-built_in">super</span>.clone();<br>        <span class="hljs-comment">//再将新对象中的引用类型数据，再次克隆</span><br>        u.scores = u.scores.clone();<br>        <span class="hljs-keyword">return</span> u;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/1665757536274.png" alt="1665757536274"></p><h3 id="4-2-Objects类"><a href="#4-2-Objects类" class="headerlink" title="4.2 Objects类"></a>4.2 Objects类</h3><p>Objects是一个工具类，提供了一些方法可以对任意对象进行操作。主要方法如下</p><p><img src="/assets/1665760840329.png" alt="1665760840329"></p><p>下面写代码演示一下这几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itheima&quot;</span>;<br>        <br>        <span class="hljs-comment">//这里会出现NullPointerException异常，调用者不能为null</span><br>        System.out.println(s1.equals(s2));<br>        <span class="hljs-comment">//此时不会有NullPointerException异常，底层会自动先判断空</span><br>        System.out.println(Objects.equals(s1,s2));<br>        <br>        <span class="hljs-comment">//判断对象是否为null，等价于==</span><br>        System.out.println(Objects.isNull(s1)); <span class="hljs-comment">//true</span><br>        System.out.println(s1==<span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><br>        <br>        <span class="hljs-comment">//判断对象是否不为null，等价于!=</span><br>        System.out.println(Objects.nonNull(s2)); <span class="hljs-comment">//true</span><br>        System.out.println(s2!=<span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-基本类型包装类"><a href="#4-3-基本类型包装类" class="headerlink" title="4.3 基本类型包装类"></a>4.3 基本类型包装类</h3><p>同学们，接下来我们学习一下包装类。为什么要学习包装类呢？因为在Java中有一句很经典的话，万物皆对象。Java中的8种基本数据类型还不是对象，所以要把它们变成对象，变成对象之后，可以提供一些方法对数据进行操作。</p><p>Java中8种基本数据类型都用一个包装类与之对一个，如下图所示</p><p><img src="/assets/1665758797003.png" alt="1665758797003"></p><p>我们学习包装类，主要学习两点：</p><ul><li><ol><li>创建包装类的对象方式、自动装箱和拆箱的特性；</li></ol></li><li><ol start="2"><li>利用包装类提供的方法对字符串和基本类型数据进行相互转换</li></ol></li></ul><blockquote><p><strong>4.2.1 创建包装类对象</strong></p></blockquote><p>我们先来学习，创建包装类对象的方法，以及包装类的一个特性叫自动装箱和自动拆箱。我们以Integer为例，其他的可以自己学，都是类似的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建Integer对象，封装基本类型数据10</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//2.使用Integer类的静态方法valueOf(数据)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//3.还有一种自动装箱的写法（意思就是自动将基本类型转换为引用类型）</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//4.有装箱肯定还有拆箱（意思就是自动将引用类型转换为基本类型）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> c;<br><br><span class="hljs-comment">//5.装箱和拆箱在使用集合时就有体现</span><br>ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//添加的元素是基本类型，实际上会自动装箱为Integer类型</span><br>list.add(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//获取元素时，会将Integer类型自动拆箱为int类型</span><br><span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>4.2.2 包装类数据类型转换</strong></p></blockquote><p>在开发中，经常使用包装类对字符串和基本类型数据进行相互转换。</p><ul><li>把字符串转换为数值型数据：包装类.parseXxx(字符串)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s)</span><br>    把字符串转换为基本数据类型<br></code></pre></td></tr></table></figure><ul><li>将数值型数据转换为字符串：包装类.valueOf(数据);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>    把基本类型数据转换为<br></code></pre></td></tr></table></figure><ul><li>写一个测试类演示一下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.字符串转换为数值型数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ageStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;29&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> Integer.parseInt(ageStr);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">scoreStr</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> Double.prarseDouble(scoreStr);<br><br><span class="hljs-comment">//2.整数转换为字符串，以下几种方式都可以（挑中你喜欢的记一下）</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> Integer.toString(a);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> a.toString();<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> a+<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> String.valueOf(a);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day02--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/12/01/day02--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="day02——面向对象高级"><a href="#day02——面向对象高级" class="headerlink" title="day02——面向对象高级"></a>day02——面向对象高级</h1><p>今天我们继续学习面向对象的语法知识，我们今天学习的主要内容是：多态、抽象、接口。</p><p>学会这些语法知识，可以让我们编写代码更灵活，代码的复用性更高。</p><h2 id="一、多态"><a href="#一、多态" class="headerlink" title="一、多态"></a>一、多态</h2><p>接下来，我们学习面向对象三大特征的的最后一个特征——多态。</p><h3 id="1-1-多态概述"><a href="#1-1-多态概述" class="headerlink" title="1.1 多态概述"></a>1.1 多态概述</h3><blockquote><p><strong>什么是多态？</strong></p><p>多态是在继承、实现情况下的一种现象，表现为：对象多态、行为多态。</p></blockquote><p>比如：Teacher和Student都是People的子类，代码可以写成下面的样子</p><p><img src="/assets/16642789439056.png" alt="1664278943905"></p><p><img src="/assets/1664278943905.png" alt="1664278943905"></p><h3 id="1-2-多态的好处"><a href="#1-2-多态的好处" class="headerlink" title="1.2 多态的好处"></a>1.2 多态的好处</h3><p>各位同学，刚才我们认识了什么是多态。那么多态的写法有什么好处呢？</p><blockquote><p>在多态形式下，右边的代码是解耦合的，更便于扩展和维护。</p></blockquote><ul><li>怎么理解这句话呢？比如刚开始p1指向Student对象，run方法执行的就是Student对象的业务；假如p1指向Student对象 ，run方法执行的自然是Student对象的业务。</li></ul><p><img src="/assets/1665018279234.png" alt="1665018279234"></p><blockquote><p>定义方法时，使用父类类型作为形参，可以接收一切子类对象，扩展行更强，更便利。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握使用多态的好处</span><br><span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>go(t);<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        go(s);<br>    &#125;<br><br>    <span class="hljs-comment">//参数People p既可以接收Student对象，也能接收Teacher对象。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(People p)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始------------------------&quot;</span>);<br>        p.run();<br>        System.out.println(<span class="hljs-string">&quot;结束------------------------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-类型转换"><a href="#1-3-类型转换" class="headerlink" title="1.3 类型转换"></a>1.3 类型转换</h3><p>虽然多态形式下有一些好处，但是也有一些弊端。在多态形式下，不能调用子类特有的方法，比如在Teacher类中多了一个teach方法，在Student类中多了一个study方法，这两个方法在多态形式下是不能直接调用的。</p><p><img src="/assets/1665018661860.png" alt="1665018661860"></p><p>多态形式下不能直接调用子类特有方法，但是转型后是可以调用的。这里所说的转型就是把父类变量转换为子类类型。格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果p接收的是子类对象</span><br><span class="hljs-keyword">if</span>(父类变量 instance 子类)&#123;<br>    <span class="hljs-comment">//则可以将p转换为子类类型</span><br>    子类 变量名 = (子类)父类变量;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/1665018905475.png" alt="1665018905475"></p><p>如果类型转换错了，就会出现类型转换异常ClassCastException，比如把Teacher类型转换成了Student类型.</p><p><img src="/assets/1665019335142.png" alt="1665019335142"></p><p>关于多态转型问题，我们最终记住一句话：<strong>原本是什么类型，才能还原成什么类型</strong></p><h2 id="二、final关键字"><a href="#二、final关键字" class="headerlink" title="二、final关键字"></a>二、final关键字</h2><p>各位同学，接下来我们学习一个在面向对象编程中偶尔会用到的一个关键字叫final，也是为后面学习抽象类和接口做准备的。</p><h3 id="2-1-final修饰符的特点"><a href="#2-1-final修饰符的特点" class="headerlink" title="2.1 final修饰符的特点"></a>2.1 final修饰符的特点</h3><p>我们先来认识一下final的特点，final关键字是最终的意思，可以修饰类、修饰方法、修饰变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">- <span class="hljs-keyword">final</span>修饰类：该类称为最终类，特点是不能被继承<br>- <span class="hljs-keyword">final</span>修饰方法：该方法称之为最终方法，特点是不能被重写。<br>- <span class="hljs-keyword">final</span>修饰变量：该变量只能被赋值一次。<br></code></pre></td></tr></table></figure><ul><li>接下来我们分别演示一下，先看final修饰类的特点</li></ul><p><img src="/assets/1665020107661.png" alt="1665020107661"></p><ul><li><p>再来演示一下final修饰方法的特点</p><p><img src="/assets/1665020283101.png" alt="1665020283101"></p></li><li><p>再演示一下final修饰变量的特点</p><ul><li>情况一</li></ul><p><img src="/assets/1665020419364.png" alt="1665020419364"></p><ul><li>情况二</li></ul><p><img src="/assets/1665020580223.png" alt="1665020580223"></p><ul><li>情况三</li></ul><p><img src="/assets/1665020721501.png" alt="1665020721501"></p><p><img src="/assets/1665020951170.png" alt="1665020951170"></p></li></ul><h3 id="2-2-补充知识：常量"><a href="#2-2-补充知识：常量" class="headerlink" title="2.2 补充知识：常量"></a>2.2 补充知识：常量</h3><p>刚刚我们学习了final修饰符的特点，在实际运用当中经常使用final来定义常量。先说一下什么是Java中的常量？</p><ul><li>被 static final 修饰的成员变量，称之为常量。</li><li>通常用于记录系统的配置信息</li></ul><p>接下来我们用代码来演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constant</span> &#123;<br>    <span class="hljs-comment">//常量: 定义一个常量表示学校名称</span><br>    <span class="hljs-comment">//为了方便在其他类中被访问所以一般还会加上public修饰符</span><br>    <span class="hljs-comment">//常量命名规范：建议都采用大写字母命名，多个单词之前有_隔开</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;传智教育&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//由于常量是static的所以，在使用时直接用类名就可以调用</span><br>        System.out.println(Constant.SCHOOL_NAME);<br>        System.out.println(Constant.SCHOOL_NAME);<br>        System.out.println(Constant.SCHOOL_NAME);<br>        System.out.println(Constant.SCHOOL_NAME);<br>        System.out.println(Constant.SCHOOL_NAME);<br>        System.out.println(Constant.SCHOOL_NAME);<br>        System.out.println(Constant.SCHOOL_NAME);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关于常量的原理，同学们也可以了解一下：在程序编译后，常量会“宏替换”，出现常量的地方，全都会被替换为其记住的字面量。把代码反编译后，其实代码是下面的样子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;传智教育&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;传智教育&quot;</span>E);<br>        System.out.println(<span class="hljs-string">&quot;传智教育&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;传智教育&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;传智教育&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;传智教育&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;传智教育&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、抽象"><a href="#三、抽象" class="headerlink" title="三、抽象"></a>三、抽象</h2><p>同学们，接下来我们学习Java中一种特殊的类，叫抽象类。为了让同学们掌握抽象类，会先让同学们认识一下什么是抽象类以及抽象类的特点，再学习一个抽象类的常见应用场景。</p><h3 id="3-1-认识抽象类"><a href="#3-1-认识抽象类" class="headerlink" title="3.1 认识抽象类"></a>3.1 认识抽象类</h3><p>我们先来认识一下什么是抽象类，以及抽象类有什么特点。</p><ul><li>在Java中有一个关键字叫abstract，它就是抽象的意思，它可以修饰类也可以修饰方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">- 被<span class="hljs-keyword">abstract</span>修饰的类，就是抽象类<br>- 被<span class="hljs-keyword">abstract</span>修饰的方法，就是抽象方法（不允许有方法体）<br></code></pre></td></tr></table></figure><p>接下来用代码来演示一下抽象类和抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//abstract修饰类，这个类就是抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//abstract修饰方法，这个方法就是抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类的成员（成员变量、成员方法、构造器），类的成员都可以有。如下面代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">static</span> String schoolName;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//实例方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>抽象类是不能创建对象的，如果抽象类的对象就会报错</li></ul><p><img src="/assets/1665026273870.png" alt="1665026273870"></p><ul><li>抽象类虽然不能创建对象，但是它可以作为父类让子类继承。而且子类继承父类必须重写父类的所有抽象方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//B类继承A类，必须复写test方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>子类继承父类如果不复写父类的抽象方法，要想不出错，这个子类也必须是抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//B类基础A类，此时B类也是抽象类，这个时候就可以不重写A类的抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-抽象类的好处"><a href="#3-2-抽象类的好处" class="headerlink" title="3.2 抽象类的好处"></a>3.2 抽象类的好处</h3><p>接下来我们用一个案例来说一下抽象类的应用场景和好处。需求如下图所示</p><p><img src="/assets/1665028790780.png" alt="1665028790780"></p><p>分析需求发现，该案例中猫和狗都有名字这个属性，也都有叫这个行为，所以我们可以将共性的内容抽取成一个父类，Animal类，但是由于猫和狗叫的声音不一样，于是我们在Animal类中将叫的行为写成抽象的。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">//动物叫的行为：不具体，是抽象的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着写一个Animal的子类，Dog类。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(getName() + <span class="hljs-string">&quot;汪汪汪的叫~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，再写一个Animal的子类，Cat类。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(getName() + <span class="hljs-string">&quot;喵喵喵的叫~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，再写一个测试类，Test类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握抽象类的使用场景和好处.</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        a.cry();<span class="hljs-comment">//这时执行的是Dog类的cry方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再学一招，假设现在系统有需要加一个Pig类，也有叫的行为，这时候也很容易原有功能扩展。只需要让Pig类继承Animal，复写cry方法就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(getName() + <span class="hljs-string">&quot;嚯嚯嚯~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，创建对象时，让Animal接收Pig，就可以执行Pig的cry方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握抽象类的使用场景和好处.</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>();<br>        a.cry();<span class="hljs-comment">//这时执行的是Pig类的cry方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，我们总结一下抽象类的使用场景和好处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>用抽象类可以把父类中相同的代码，包括方法声明都抽取到父类，这样能更好的支持多态，一提高代码的灵活性。<br><br><span class="hljs-number">2.</span>反过来用，我们不知道系统未来具体的业务实现时，我们可以先定义抽象类，将来让子类去实现，以方便系统的扩展。<br></code></pre></td></tr></table></figure><h3 id="3-3-模板方法模式"><a href="#3-3-模板方法模式" class="headerlink" title="3.3 模板方法模式"></a>3.3 模板方法模式</h3><p>学习完抽象类的语法之后，接下来，我们学习一种利用抽象类实现的一种设计模式。先解释下一什么是设计模式？<strong>设计模式是解决某一类问题的最优方案</strong>。</p><p>设计模式在一些源码中经常会出现，还有以后面试的时候偶尔也会被问到，所以在合适的机会，就会给同学们介绍一下设计模式的知识。</p><p>那模板方法设计模式解决什么问题呢？<strong>模板方法模式主要解决方法中存在重复代码的问题</strong></p><p>比如A类和B类都有sing()方法，sing()方法的开头和结尾都是一样的，只是中间一段内容不一样。此时A类和B类的sing()方法中就存在一些相同的代码。</p><p><img src="/assets/1665058597483.png" alt="1665058597483"></p><p>怎么解决上面的重复代码问题呢？ 我们可以写一个抽象类C类，在C类中写一个doSing()的抽象方法。再写一个sing()方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模板方法设计模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-comment">// 模板方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;唱一首你喜欢的歌：&quot;</span>);<br><br>        doSing();<br><br>        System.out.println(<span class="hljs-string">&quot;唱完了!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSing</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，写一个A类继承C类，复写doSing()方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一只小小小小鸟，想要飞就能飞的高~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，再写一个B类继承C类，也复写doSing()方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我们一起学猫叫，喵喵喵喵喵喵喵~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，再写一个测试类Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：搞清楚模板方法设计模式能解决什么问题，以及怎么写。</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        b.sing();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述：模板方法模式解决了多个子类中有相同代码的问题。具体实现步骤如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">第<span class="hljs-number">1</span>步：定义一个抽象类，把子类中相同的代码写成一个模板方法。<br>第<span class="hljs-number">2</span>步：把模板方法中不能确定的代码写成抽象方法，并在模板方法中调用。<br>第<span class="hljs-number">3</span>步：子类继承抽象类，只需要父类抽象方法就可以了。<br></code></pre></td></tr></table></figure><h2 id="四、接口"><a href="#四、接口" class="headerlink" title="四、接口"></a>四、接口</h2><p>同学们，接下来我们学习一个比抽象类抽象得更加彻底的一种特殊结构，叫做接口。在学习接口是什么之前，有一些事情需要给大家交代一下：Java已经发展了20多年了，在发展的过程中不同JDK版本的接口也有一些变化，所以我们在学习接口时，先以老版本为基础，学习完老版本接口的特性之后，再顺带着了解一些新版本接口的特性就可以了。</p><h3 id="4-1-认识接口"><a href="#4-1-认识接口" class="headerlink" title="4.1 认识接口"></a>4.1 认识接口</h3><p>我们先来认识一下接口？Java提供了一个关键字interface，用这个关键字来定义接口这种特殊结构。格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface 接口名&#123;<br>    <span class="hljs-comment">//成员变量（常量）</span><br>    <span class="hljs-comment">//成员方法（抽象方法）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按照接口的格式，我们定义一个接口看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//这里public static final可以加，可以不加。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SCHOOL_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;黑马程序员&quot;</span>;<br>    <br>    <span class="hljs-comment">//这里的public abstract可以加，可以不加。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>写好A接口之后，在写一个测试类，用一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//打印A接口中的常量</span><br>        System.out.println(A.SCHOOL_NAME);<br>        <br>        <span class="hljs-comment">//接口是不能创建对象的</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现定义好接口之后，是不能创建对象的。那接口到底什么使用呢？需要我注意下面两点</p><ul><li><strong>接口是用来被类实现（implements）的，我们称之为实现类。</strong></li><li><strong>一个类是可以实现多个接口的（接口可以理解成干爹），类实现接口必须重写所有接口的全部抽象方法，否则这个类也必须是抽象类</strong></li></ul><p>比如，再定义一个B接口，里面有两个方法testb1()，testb2()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testb1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testb2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，再定义一个C接口，里面有两个方法testc1(), testc2()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testc1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testc2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，再写一个实现类D，同时实现B接口和C接口，此时就需要复写四个方法，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">B</span>, C&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testb1</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testb2</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testc1</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testc2</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，定义一个测试类Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：认识接口。</span><br>        System.out.println(A.SCHOOL_NAME);<br><br>        <span class="hljs-comment">// A a = new A();</span><br>        <span class="hljs-type">D</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-接口的好处"><a href="#4-2-接口的好处" class="headerlink" title="4.2 接口的好处"></a>4.2 接口的好处</h3><p>同学们，刚刚上面我们学习了什么是接口，以及接口的基本特点。那使用接口到底有什么好处呢？主要有下面的两点</p><ul><li>弥补了类单继承的不足，一个类同时可以实现多个接口。</li><li>让程序可以面向接口编程，这样程序员可以灵活方便的切换各种业务实现。</li></ul><p>我们看一个案例演示，假设有一个Studnet学生类，还有一个Driver司机的接口，还有一个Singer歌手的接口。</p><p>现在要写一个A类，想让他既是学生，偶然也是司机能够开车，偶尔也是歌手能够唱歌。那我们代码就可以这样设计，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Driver</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Singer</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//A类是Student的子类，同时也实现了Dirver接口和Singer接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Driver</span>, Singer&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//想唱歌的时候，A类对象就表现为Singer类型</span><br>        <span class="hljs-type">Singer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        s.sing();<br><br>        <span class="hljs-comment">//想开车的时候，A类对象就表现为Driver类型</span><br>        <span class="hljs-type">Driver</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        d.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述：接口弥补了单继承的不足，同时可以轻松实现在多种业务场景之间的切换。</p><h3 id="4-3-接口的案例"><a href="#4-3-接口的案例" class="headerlink" title="4.3 接口的案例"></a>4.3 接口的案例</h3><p>各位同学，关于接口的特点以及接口的好处我们都已经学习完了。接下来我们做一个案例，先来看一下案例需求.</p><p><img src="/assets/1665102202635.png" alt="1665102202635"></p><p>首先我们写一个学生类，用来描述学生的相关信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> score;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">char</span> sex, <span class="hljs-type">double</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">double</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，写一个StudentOperator接口，表示学生信息管理系统的两个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentOperator</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllInfo</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAverageScore</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，写一个StudentOperator接口的实现类StudentOperatorImpl1，采用第1套方案对业务进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentOperatorImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentOperator</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllInfo</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;----------全班全部学生信息如下--------------&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> students.get(i);<br>            System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span> + s.getName() + <span class="hljs-string">&quot;, 性别：&quot;</span> + s.getSex() + <span class="hljs-string">&quot;, 成绩：&quot;</span> + s.getScore());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------------------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAverageScore</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">allScore</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> students.get(i);<br>            allScore += s.getScore();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;平均分：&quot;</span> + (allScore) / students.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，再写一个StudentOperator接口的实现类StudentOperatorImpl2，采用第2套方案对业务进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentOperatorImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentOperator</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllInfo</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;----------全班全部学生信息如下--------------&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> students.get(i);<br>            System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span> + s.getName() + <span class="hljs-string">&quot;, 性别：&quot;</span> + s.getSex() + <span class="hljs-string">&quot;, 成绩：&quot;</span> + s.getScore());<br>            <span class="hljs-keyword">if</span>(s.getSex() == <span class="hljs-string">&#x27;男&#x27;</span>)&#123;<br>                count1++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                count2 ++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;男生人数是：&quot;</span> + count1  + <span class="hljs-string">&quot;, 女士人数是：&quot;</span> + count2);<br>        System.out.println(<span class="hljs-string">&quot;班级总人数是：&quot;</span> + students.size());<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------------------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAverageScore</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">allScore</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> students.get(<span class="hljs-number">0</span>).getScore();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> students.get(<span class="hljs-number">0</span>).getScore();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> students.get(i);<br>            <span class="hljs-keyword">if</span>(s.getScore() &gt; max) max = s.getScore();<br>            <span class="hljs-keyword">if</span>(s.getScore() &lt; min) min = s.getScore();<br>            allScore += s.getScore();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;学生的最高分是：&quot;</span> + max);<br>        System.out.println(<span class="hljs-string">&quot;学生的最低分是：&quot;</span> + min);<br>        System.out.println(<span class="hljs-string">&quot;平均分：&quot;</span> + (allScore - max - min) / (students.size() - <span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再写一个班级管理类ClassManager，在班级管理类中使用StudentOperator的实现类StudentOperatorImpl1对学生进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassManager</span> &#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StudentOperator</span> <span class="hljs-variable">studentOperator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentOperatorImpl1</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassManager</span><span class="hljs-params">()</span>&#123;<br>        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">99</span>));<br>        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;古力娜扎&quot;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">100</span>));<br>        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;马尔扎哈&quot;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">80</span>));<br>        students.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;卡尔扎巴&quot;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">60</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 打印全班全部学生的信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span>&#123;<br>        studentOperator.printAllInfo(students);<br>    &#125;<br><br>    <span class="hljs-comment">// 打印全班全部学生的平均分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printScore</span><span class="hljs-params">()</span>&#123;<br>        studentOperator.printAverageScore(students);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，再写一个测试类Test，在测试类中使用ClassMananger完成班级学生信息的管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成班级学生信息管理的案例。</span><br>        <span class="hljs-type">ClassManager</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassManager</span>();<br>        clazz.printInfo();<br>        clazz.printScore();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：如果想切换班级管理系统的业务功能，随时可以将StudentOperatorImpl1切换为StudentOperatorImpl2。自己试试</p><h3 id="4-4-接口JDK8的新特性"><a href="#4-4-接口JDK8的新特性" class="headerlink" title="4.4 接口JDK8的新特性"></a>4.4 接口JDK8的新特性</h3><p>各位同学，对于接口最常见的特性我们都学习完了。随着JDK版本的升级，在JDK8版本以后接口中能够定义的成员也做了一些更新，从JDK8开始，接口中新增的三种方法形式。</p><p>我们看一下这三种方法分别有什么特点？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1、默认方法：必须使用default修饰，默认会被public修饰</span><br><span class="hljs-comment">     * 实例方法：对象的方法，必须使用实现类的对象来访问。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===默认方法==&quot;</span>);<br>        test2();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2、私有方法：必须使用private修饰。(JDK 9开始才支持的)</span><br><span class="hljs-comment">     *   实例方法：对象的方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===私有方法==&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3、静态方法：必须使用static修饰，默认会被public修饰</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==静态方法==&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span>&#123;<br><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们写一个B类，实现A接口。B类作为A接口的实现类，只需要重写抽象方法就尅了，对于默认方法不需要子类重写。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，写一个测试类，观察接口中的三种方法，是如何调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握接口新增的三种方法形式</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        b.test1();<span class="hljs-comment">//默认方法使用对象调用</span><br>        <span class="hljs-comment">// b.test2();//A接口中的私有方法，B类调用不了</span><br>        A.test3();<span class="hljs-comment">//静态方法，使用接口名调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述：JDK8对接口新增的特性，有利于对程序进行扩展。</p><h3 id="4-5-接口的其他细节"><a href="#4-5-接口的其他细节" class="headerlink" title="4.5 接口的其他细节"></a>4.5 接口的其他细节</h3><p>最后，给同学们介绍一下使用接口的其他细节，或者说注意事项：</p><ul><li>一个接口可以继承多个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：理解接口的多继承。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span>&#123;&#125;<br><br><span class="hljs-comment">//比如：D接口继承C、B、A</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">C</span>, B, A&#123;<br><br>&#125;<br><br><span class="hljs-comment">//E类在实现D接口时，必须重写D接口、以及其父类中的所有抽象方法。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">D</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口除了上面的多继承特点之外，在多实现、继承和实现并存时，有可能出现方法名冲突的问题，需要了解怎么解决（仅仅只是了解一下，实际上工作中几乎不会出现这种情况）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>一个接口继承多个接口，如果多个接口中存在相同的方法声明，则此时不支持多继承<br><span class="hljs-number">2.</span>一个类实现多个接口，如果多个接口中存在相同的方法声明，则此时不支持多实现<br><span class="hljs-number">3.</span>一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会有限使用父类的方法<br><span class="hljs-number">4.</span>一个类实现类多个接口，多个接口中有同名的默认方法，则这个类必须重写该方法。<br></code></pre></td></tr></table></figure><p>综上所述：一个接口可以继承多个接口，接口同时也可以被类实现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day01--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/12/01/day01--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="day01——面向对象高级"><a href="#day01——面向对象高级" class="headerlink" title="day01——面向对象高级"></a>day01——面向对象高级</h1><p>各位同学，接下来的三天课程中，我们继续学习面向对象的相关课程。面向对象是写Java程序的核心套路，如何你不懂面向对象，那就相当于Java你白学了。所以在接下来的三天时间里，各位同学也需要克服重重困难好好学习。</p><p>前面我们说过面向对象最核心的套路是：<strong>设计对象来处理数据，解决问题。</strong> 如果你把面向对象高级这一部分课程学好，你设计出来的对象将更加好用。</p><p>在正式学习面向对象高级课程之前，我给大家提一些学习上的建议。目前我们学习的面向对象高级部分的知识点，就像一个一个的螺丝钉，在学习过程中你可能并不知道这些螺丝钉是用在哪里的，解决的什么问题。必须等这些内容都学习完之后，才能知道用这些螺丝钉可以用来搞飞机、造航母、造火箭。</p><p><img src="/assets/1663976726206.png" alt="1663976726206"></p><p>所以，现阶段我们在学习过程中，主要关注下面几点就可以了。等整个基础课程学习完之后，再慢慢感在到哪里用。</p><p><img src="/assets/1663976889900.png" alt="1663976889900"></p><h2 id="一、静态"><a href="#一、静态" class="headerlink" title="一、静态"></a>一、静态</h2><p>接下来，我们学习一下面向对象编程中很常见的一个关键字static.</p><p>static读作静态，可以用来修饰成员变量，也能修饰成员方法。我们先来学习static修饰成员变量。</p><h3 id="1-1-static修饰成员变量"><a href="#1-1-static修饰成员变量" class="headerlink" title="1.1 static修饰成员变量"></a>1.1 static修饰成员变量</h3><p>Java中的成员变量按照有无static修饰分为两种：<strong>类变量、实例变量</strong>。它们的区别如下图所示：</p><p><img src="/assets/1663977705413.png" alt="1663977705413"></p><p>由于静态变量是属于类的，只需要通过类名就可以调用：**<code>类名.静态变量</code>**</p><p>实例变量是属于对象的，需要通过对象才能调用：**<code>对象.实例变量</code>**</p><ul><li>下面是代码演示（注意静态变量，和实例变量是如何调用的）</li></ul><p><img src="/assets/1663978511018.png" alt="1663978511018"></p><p>为了让大家对于这两种成员变量的执行过程理解更清楚一点，在这里给大家在啰嗦几句，我们来看一下上面代码的内存原理。</p><p><img src="/assets/1663978808670.png" alt="1663978808670"></p><ul><li><strong>最后总结一下</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">- <span class="hljs-number">1.</span>类变量：属于类，在内存中只有一份，用类名调用<br>- <span class="hljs-number">2.</span>实例变量：属于对象，每一个对象都有一份，用对象调用<br></code></pre></td></tr></table></figure><h3 id="1-2-static修饰成员变量的应用场景"><a href="#1-2-static修饰成员变量的应用场景" class="headerlink" title="1.2 static修饰成员变量的应用场景"></a>1.2 static修饰成员变量的应用场景</h3><p>学习完static修饰成员变量的基本使用之后，接下来我们学习一下static修饰成员变量在实际工作中的应用。</p><p>在实际开发中，如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成类变量来记住。</p><blockquote><p><strong>我们看一个案例</strong>**</p><p>需求：系统启动后，要求用于类可以记住自己创建了多少个用户对象。**</p></blockquote><ul><li>第一步：先定义一个<code>User</code>类，在用户类中定义一个static修饰的变量，用来表示在线人数；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> number;<br>    <span class="hljs-comment">//每次创建对象时，number自增一下</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;<br>        User.number++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二步：再写一个测试类，再测试类中创建4个User对象，再打印number的值，观察number的值是否再自增。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//创建4个对象</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <br>        <br>        <span class="hljs-comment">//查看系统创建了多少个User对象</span><br>        System.out.println(<span class="hljs-string">&quot;系统创建的User对象个数：&quot;</span>+User.number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，查看执行结果是：**<code>系统创建的User对象个数：4</code>**</p><h3 id="1-3-static修饰成员方法"><a href="#1-3-static修饰成员方法" class="headerlink" title="1.3 static修饰成员方法"></a>1.3 static修饰成员方法</h3><p>各位同学，学习完static修饰成员变量之后，接下来我们学习static修饰成员方法。成员方法根据有无static也分为两类：<strong>类方法、实例方法</strong></p><p><img src="/assets/1664004813041.png" alt="1664004813041"></p><blockquote><p>有static修饰的方法，是属于类的，称为<strong>类方法</strong>；调用时直接用类名调用即可。</p></blockquote><blockquote><p>无static修饰的方法，是属于对象的，称为实例方法；调用时，需要使用对象调用。</p></blockquote><p>我们看一个案例，演示类方法、实例方法的基本使用</p><ul><li>先定义一个Student类，在类中定义一个类方法、定义一个实例方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-type">double</span> score;<br>    <br>    <span class="hljs-comment">//类方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> printHelloWorld&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//实例方法（对象的方法）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPass</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//打印成绩是否合格</span><br>        System.out.println(score&gt;=<span class="hljs-number">60</span>?<span class="hljs-string">&quot;成绩合格&quot;</span>:<span class="hljs-string">&quot;成绩不合格&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在定义一个测试类，注意类方法、对象方法调用的区别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.调用Student类中的类方法</span><br>        Student.printHelloWorld();<br>        <br>        <span class="hljs-comment">//2.调用Student类中的实例方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();        <br>        s.printPass();<br>        <br>        <span class="hljs-comment">//使用对象也能调用类方法【不推荐，IDEA连提示都不给你，你就别这么用了】</span><br>        s.printHelloWorld();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>搞清楚类方法和实例方法如何调用之后，接下来再啰嗦几句，和同学们聊一聊static修饰成员方法的内存原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>类方法：<span class="hljs-keyword">static</span>修饰的方法，可以被类名调用，是因为它是随着类的加载而加载的；<br> 所以类名直接就可以找到<span class="hljs-keyword">static</span>修饰的方法<br> <br><span class="hljs-number">2.</span>实例方法：非<span class="hljs-keyword">static</span>修饰的方法，需要创建对象后才能调用，是因为实例方法中可能会访问实例变量，而实例变量需要创建对象后才存在。<br>  所以实例方法，必须创建对象后才能调用。<br></code></pre></td></tr></table></figure><p><img src="/assets/1664005554987.png" alt="1664005554987"></p><p>关于static修饰成员变量、和静态修饰成员方法这两种用法，到这里就学习完了。</p><h3 id="1-4-工具类"><a href="#1-4-工具类" class="headerlink" title="1.4 工具类"></a>1.4 工具类</h3><p>学习完static修饰方法之后，我们讲一个有关类方法的应用知识，叫做工具类。</p><p>如果一个类中的方法全都是静态的，那么这个类中的方法就全都可以被类名直接调用，由于调用起来非常方便，就像一个工具一下，所以把这样的类就叫做工具类。</p><ul><li>我们写一个生成验证码的工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUtils</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-comment">//1.定义一个字符串，用来记录产生的验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-comment">//2.验证码是由所有的大写字母、小写字母或者数字字符组成</span><br>        <span class="hljs-comment">//这里先把所有的字符写成一个字符串，一会从字符串中随机找字符</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKMNOPQRSTUVWXYZ&quot;</span>;<br>        <br>        <span class="hljs-comment">//3.循环n次，产生n个索引,再通过索引获取字符</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> r.nextInt(data.length());<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> data.charAt(index);<br>            <span class="hljs-comment">//4.把获取到的字符，拼接到code验证码字符串上。</span><br>            code+=ch;<br>        &#125;<br>        <br>        <span class="hljs-comment">//最后返回code,code的值就是验证码</span><br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接着可以在任何位置调用<code>MyUtils</code>的<code>createCOde()方法</code>产生任意个数的验证码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//比如这是一个登录界面</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(MyUtils.createCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//比如这是一个注册界面</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">registerDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(MyUtils.createCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>工具类的使用就是这样子的，学会了吗？</p><blockquote><p>在补充一点，工具类里的方法全都是静态的，推荐用类名调用为了防止使用者用对象调用。我们可以把工具类的构造方法私有化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUtils</span>&#123;<br>    <span class="hljs-comment">//私有化构造方法：这样别人就不能使用构造方法new对象了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyUtils</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">//类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>       ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-static的注意事项"><a href="#1-5-static的注意事项" class="headerlink" title="1.5 static的注意事项"></a>1.5 static的注意事项</h3><p>各位同学，到现在在我们已经学会了static修饰的变量、方法如何调用了。但是有一些注意事项还是需要给大家说明一下，目的是让大家知道，使用static写代码时，如果出错了，要知道为什么错、如何改正。</p><p><img src="/assets/1664007168869.png" alt="1664007168869"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">static</span> String schoolName; <span class="hljs-comment">// 类变量</span><br>    <span class="hljs-type">double</span> score; <span class="hljs-comment">// 实例变量</span><br><br>    <span class="hljs-comment">// 1、类方法中可以直接访问类的成员，不可以直接访问实例成员。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printHelloWorld</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 注意：同一个类中，访问类成员，可以省略类名不写。</span><br>        schoolName = <span class="hljs-string">&quot;黑马&quot;</span>;<br>        printHelloWorld2();<br><br>        System.out.println(score); <span class="hljs-comment">// 报错的</span><br>        printPass(); <span class="hljs-comment">// 报错的</span><br><br>        ystem.out.println(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 报错的</span><br>    &#125;<br>    <br><span class="hljs-comment">// 类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printHelloWorld2</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPass2</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-comment">// 2、实例方法中既可以直接访问类成员，也可以直接访问实例成员。</span><br>    <span class="hljs-comment">// 3、实例方法中可以出现this关键字，类方法中不可以出现this关键字的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPass</span><span class="hljs-params">()</span>&#123;<br>        schoolName = <span class="hljs-string">&quot;黑马2&quot;</span>; <span class="hljs-comment">//对的</span><br>        printHelloWorld2(); <span class="hljs-comment">//对的</span><br><br>        System.out.println(score); <span class="hljs-comment">//对的</span><br>        printPass2(); <span class="hljs-comment">//对的</span><br><br>        System.out.println(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//对的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-static应用（代码块）"><a href="#1-6-static应用（代码块）" class="headerlink" title="1.6 static应用（代码块）"></a>1.6 static应用（代码块）</h3><p>各位同学，接下来我们再补充讲解一个知识点，叫代码块；代码块根据有无static修饰分为两种：静态代码块、实例代码块</p><blockquote><p><strong>我们先类学习静态代码块：</strong></p></blockquote><p><img src="/assets/1664007549583.png" alt="1664007549583"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">schoolName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;黑马&quot;</span>;<br>    <span class="hljs-comment">// 静态代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块执行了~~&quot;</span>);<br>        schoolName = <span class="hljs-string">&quot;黑马&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态代码块不需要创建对象就能够执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：认识两种代码块，了解他们的特点和基本作用。</span><br>        System.out.println(Student.number);<br>        System.out.println(Student.number);<br>        System.out.println(Student.number);<br><br>        System.out.println(Student.schoolName); <span class="hljs-comment">// 黑马</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上面代码时，发现没有创建对象，静态代码块就已经执行了。</p><p><img src="/assets/1664007747151.png" alt="1664007747151"></p><p>关于静态代码块重点注意：<strong>静态代码块，随着类的加载而执行，而且只执行一次。</strong></p><blockquote><p><strong>再来学习一下实例代码块</strong></p></blockquote><p><img src="/assets/1664008215853.png" alt="1664008215853"></p><p>实例代码块的作用和构造器的作用是一样的，用来给对象初始化值；而且每次创建对象之前都会先执行实例代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-comment">//实例变量</span><br><span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//实例代码块：实例代码块会执行在每一个构造方法之前</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;实例代码块执行了~~&quot;</span>);<br>        age = <span class="hljs-number">18</span>;<br>        System.out.println(<span class="hljs-string">&quot;有人创建了对象：&quot;</span> + <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参数构造器执行了~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;有参数构造器执行了~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来在测试类中进行测试，观察创建对象时，实例代码块是否先执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>        System.out.println(s1.age);<br>        System.out.println(s2.age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于实例代码块重点注意：<strong>实例代码块每次创建对象之前都会执行一次</strong></p><h3 id="1-7-static应用（单例设计模式）"><a href="#1-7-static应用（单例设计模式）" class="headerlink" title="1.7 static应用（单例设计模式）"></a>1.7 static应用（单例设计模式）</h3><p>各位同学，关于static的应用我们再补充一个使用的技巧，叫做单例设计模式。</p><p>所谓设计模式指的是，一类问题可能会有多种解决方案，而设计模式是在编程实践中，多种方案中的一种最优方案。</p><p>关于静态的使用到这里，我们就学习完了。</p><h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><h3 id="2-1-继承快速入门"><a href="#2-1-继承快速入门" class="headerlink" title="2.1 继承快速入门"></a>2.1 继承快速入门</h3><p>各位同学，我们继续学习面向对象相关内容。面向对象编程之所以能够能够被广大开发者认可，有一个非常重要的原因，是因为它有三大特征，继承、封装和多态。封装我们在基础班已经学过了，接下来我们学习一下继承。</p><p><img src="/assets/1664009338913.png" alt="1664009338913"></p><p>接下来，我们演示一下使用继承来编写代码，注意观察继承的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//公开的成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===print1===&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//私有的成员</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===print2===&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，写一个B类，让B类继承A类。在继承A类的同时，B类中新增一个方法print3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//由于i和print1是属于父类A的公有成员，在子类中可以直接被使用</span><br>        System.out.println(i); <span class="hljs-comment">//正确</span><br>        print1(); <span class="hljs-comment">//正确</span><br>        <br>        <span class="hljs-comment">//由于j和print2是属于父类A的私有成员，在子类中不可以被使用</span><br>        System.out.println(j); <span class="hljs-comment">//错误</span><br>        print2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们再演示一下，创建B类对象，能否调用父类A的成员。再写一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        <span class="hljs-comment">//父类公有成员，子类对象是可以调用的</span><br>        System.out.println(i); <span class="hljs-comment">//正确</span><br>        b.print1();<br>        <br>        <span class="hljs-comment">//父类私有成员，子类对象时不可以调用的</span><br>        System.out.println(j); <span class="hljs-comment">//错误</span><br>        b.print2(); <span class="hljs-comment">//错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，关于继承的基本使用我们就算学会了。为了让大家对继承有更深入的认识，我们来看看继承的内存原理。</p><p>这里我们只需要关注一点：<strong>子类对象实际上是由子、父类两张设计图共同创建出来的。</strong></p><p>所以，在子类对象的空间中，既有本类的成员，也有父类的成员。但是子类只能调用父类公有的成员。</p><p><img src="/assets/1664010590126.png" alt="1664010590126"></p><h3 id="2-2-继承的好处"><a href="#2-2-继承的好处" class="headerlink" title="2.2 继承的好处"></a>2.2 继承的好处</h3><p>各位同学，学习完继承的快速入门之后，接下来我们学习一下继承的好处，以及它的应用场景。</p><p>我们通过一个案例来学习</p><p><img src="/assets/1664010915416.png" alt="1664010915416"></p><p>观察代码发现，我们会发现Teacher类中和Consultant类中有相同的代码；其实像这种两个类中有相同代码时，没必要重复写。</p><p>我们可以把重复的代码提取出来，作为父类，然后让其他类继承父类就可以了，这样可以提高代码的复用性。改造后的代码如下：</p><p><img src="/assets/1664011136599.png" alt="1664011136599"></p><p>接下来使用继承来完成上面的案例，这里只演示People类和Teacher类，然后你尝试自己完成Consultant类。</p><ul><li>先写一个父类 People，用来设计Teacher和Consultant公有的成员。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>再写两个子类Teacher继承People类，同时在子类中加上自己特有的成员。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">private</span> String skill; <span class="hljs-comment">//技能</span><br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSkill</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> skill;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSkill</span><span class="hljs-params">(String skill)</span>&#123;<br>        <span class="hljs-built_in">this</span>.skill=skill;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(getName()+<span class="hljs-string">&quot;具备的技能：&quot;</span>+skill);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最后再写一个测试类，再测试类中创建Teacher、Consultant对象，并调用方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：搞清楚继承的好处。</span><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        t.setName(<span class="hljs-string">&quot;播仔&quot;</span>);<br>        t.setSkill(<span class="hljs-string">&quot;Java、Spring&quot;</span>);<br>        System.out.println(t.getName());<br>        System.out.println(t.getSkill());<br>        t.printInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行代码，打印结果如下：</p><p><img src="/assets/1664011737379.png" alt="1664011737379"></p><p>关于继承的好处我们只需要记住：<strong>继承可以提高代码的复用性</strong></p><h3 id="2-3-权限修饰符"><a href="#2-3-权限修饰符" class="headerlink" title="2.3 权限修饰符"></a>2.3 权限修饰符</h3><p>各位同学，在刚才使用继承编写的代码中我们有用到两个权限修饰符，一个是public（公有的）、一个是private（私有的），实际上还有两个权限修饰符，一个是protected（受保护的）、一个是缺省的（不写任何修饰符）。</p><p>接下来我们就学习一下这四个权限修饰符分别有什么作用。</p><blockquote><p><strong>什么是权限修饰符呢？</strong></p><p>权限修饰符是用来限制类的成员（成员变量、成员方法、构造器…）能够被访问的范围。</p></blockquote><p>每一种权限修饰符能够被访问的范围如下</p><p><img src="/assets/1664012151488.png" alt="1664012151488"></p><p>下面我们用代码演示一下，在本类中可以访问到哪些权限修饰的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">// 1、私有:只能在本类中访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==private==&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2、缺省：本类，同一个包下的类</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==缺省==&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3、protected: 本类，同一个包下的类，任意包下的子类</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">protectedMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==protected==&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4、public： 本类，同一个包下的类，任意包下的子类，任意包下的任意类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publicMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==public==&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//在本类中，所有权限都可以被访问到</span><br>        privateMethod(); <span class="hljs-comment">//正确</span><br>        method(); <span class="hljs-comment">//正确</span><br>        protectedMethod(); <span class="hljs-comment">//正确</span><br>        publicMethod(); <span class="hljs-comment">//正确</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在和Fu类同一个包下，创建一个测试类Demo，演示同一个包下可以访问到哪些权限修饰的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Fu</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fu</span>();<br>        <span class="hljs-comment">// f.privateMethod();//私有方法无法使用</span><br>        f.method();<br>        f.protectedMethod();<br>        f.publicMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在另一个包下创建一个Fu类的子类，演示不同包下的子类中可以访问哪些权限修饰的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">//在不同包下的子类中，只能访问到public、protected修饰的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// privateMethod(); // 报错</span><br>        <span class="hljs-comment">// method(); // 报错</span><br>        protectedMethod();<span class="hljs-comment">//正确</span><br>        publicMethod();<span class="hljs-comment">//正确</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在和Fu类不同的包下，创建一个测试类Demo2，演示一下不同包的无关类，能访问到哪些权限修饰的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Fu</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fu</span>();<br>        <span class="hljs-comment">// f.privateMethod(); // 报错</span><br>        <span class="hljs-comment">// f.method();  //报错</span><br>        <span class="hljs-comment">// f.protecedMethod();//报错</span><br>        f.publicMethod();<span class="hljs-comment">//正确</span><br><br>        <span class="hljs-type">Zi</span> <span class="hljs-variable">zi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>        <span class="hljs-comment">// zi.protectedMethod();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-单继承、Object"><a href="#2-4-单继承、Object" class="headerlink" title="2.4 单继承、Object"></a>2.4 单继承、Object</h3><p>刚才我们写的代码中，都是一个子类继承一个父类，那么有同学问到，一个子类可以继承多个父类吗？ </p><p><strong>Java语言只支持单继承，不支持多继承，但是可以多层继承</strong>。就像家族里儿子、爸爸和爷爷的关系一样：一个儿子只能有一个爸爸，不能有多个爸爸，但是爸爸也是有爸爸的。</p><p><img src="/assets/1664016601977.png" alt="1664016601977"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握继承的两个注意事项事项。</span><br>        <span class="hljs-comment">// 1、Java是单继承的：一个类只能继承一个直接父类；</span><br>        <span class="hljs-comment">// 2、Object类是Java中所有类的祖宗。</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        list.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        System.out.println(list.toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125; <span class="hljs-comment">//extends Object&#123;&#125;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-comment">// class C extends B , A&#123;&#125; // 报错</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-方法重写"><a href="#2-5-方法重写" class="headerlink" title="2.5 方法重写"></a>2.5 方法重写</h3><p>各位同学，学习完继承之后，在继承的基础之上还有一个很重要的现象需要给大家说一下。</p><p>叫做方法重写。为了让大家能够掌握方法重写，我们先认识什么是方法重写，再说一下方法的应用场景。</p><blockquote><p><strong>什么是方法重写</strong></p></blockquote><p>当子类觉得父类方法不好用，或者无法满足父类需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的这个方法，这就是方法重写。</p><p><strong>注意：重写后，方法的访问遵循就近原则</strong>。下面我们看一个代码演示</p><p>写一个A类作为父类，定义两个方法print1和print2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;111111&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再写一个B类作为A类的子类，重写print1和print2方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 安全，可读性好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;666&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;666666&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在测试类中创建B类对象，调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：认识方法重写，掌握方法重写的常见应用场景。</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        b.print1();<br>        b.print2(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行代码，我们发现真正执行的是B类中的print1和print2方法</p><p><img src="/assets/1664149862001.png" alt="1664149862001"></p><p>知道什么是方法重写之后，还有一些注意事项，需要和大家分享一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">- <span class="hljs-number">1.</span>重写的方法上面，可以加一个注解<span class="hljs-meta">@Override</span>,用于标注这个方法是复写的父类方法<br>- <span class="hljs-number">2.</span>子类复写父类方法时，访问权限必须大于或者等于父类方法的权限<br><span class="hljs-keyword">public</span> &gt; <span class="hljs-keyword">protected</span> &gt; 缺省<br>- <span class="hljs-number">3.</span> 重写的方法返回值类型，必须与被重写的方法返回值类型一样，或者范围更小<br>- <span class="hljs-number">4.</span> 私有方法、静态方法不能被重写，如果重写会报错。<br></code></pre></td></tr></table></figure><p>关于这些注意事项，同学们其实只需要了解一下就可以了。实际上我们实际写代码时，只要和父类写的一样就可以（ 总结起来就8个字：<strong>声明不变，重新实现</strong>）</p><blockquote><p><strong>方法重写的应用场景</strong></p></blockquote><p>学习完方法重写之后，接下来，我们还需要大家掌握方法重写，在实际中的应用场景。方法重写的应用场景之一就是：<strong>子类重写Object的toString()方法，以便返回对象的内容。</strong></p><p>比如：有一个Student类，这个类会默认继承Object类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实Object类中有一个toString()方法，直接通过Student对象调用Object的toString()方法，会得到对象的地址值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;播妞&quot;</span>, <span class="hljs-number">19</span>);<br>        <span class="hljs-comment">// System.out.println(s.toString());</span><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/1664150713665.png" alt="1664150713665"></p><p>但是，此时不想调用父类Object的toString()方法，那就可以在Student类中重新写一个toSting()方法，用于返回对象的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.d12_extends_override;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行测试类，结果如下</p><p><img src="/assets/1664150752636.png" alt="1664150752636"></p><p>好了，到这里方法什么是方法重写，以及方法重写的应用场景我们就学习完了。</p><h3 id="2-6-子类中访问成员的特点"><a href="#2-6-子类中访问成员的特点" class="headerlink" title="2.6 子类中访问成员的特点"></a>2.6 子类中访问成员的特点</h3><p>各位同学，刚才我们已经学习了继承，我们发现继承至少涉及到两个类，而每一个类中都可能有各自的成员（成员变量、成员方法），就有可能出现子类和父类有相同成员的情况，那么在子类中访问其他成员有什么特点呢？</p><ul><li><strong>原则：在子类中访问其他成员（成员变量、成员方法），是依据就近原则的</strong></li></ul><p>定义一个父类，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;父类名字&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==父类的print1方法执行==&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义一个子类，代码如下。有一个同名的name成员变量，有一个同名的print1成员方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">F</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;子类名称&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;局部名称&quot;</span>;<br>        System.out.println(name); <span class="hljs-comment">// 局部名称</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==子类的print1方法执行了=&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMethod</span><span class="hljs-params">()</span>&#123;<br>        print1(); <span class="hljs-comment">// 子类的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来写一个测试类，观察运行结果，我们发现都是调用的子类变量、子类方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握子类中访问其他成员的特点：就近原则。</span><br>        <span class="hljs-type">Z</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Z</span>();<br>        z.showName();<br>        z.showMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果子类和父类出现同名变量或者方法，优先使用子类的；此时如果一定要在子类中使用父类的成员，可以加this或者super进行区分。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">F</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;子类名称&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;局部名称&quot;</span>;<br>        System.out.println(name); <span class="hljs-comment">// 局部名称</span><br>        System.out.println(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">// 子类成员变量</span><br>        System.out.println(<span class="hljs-built_in">super</span>.name); <span class="hljs-comment">// 父类的成员变量</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==子类的print1方法执行了=&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMethod</span><span class="hljs-params">()</span>&#123;<br>        print1(); <span class="hljs-comment">// 子类的</span><br>        <span class="hljs-built_in">super</span>.print1(); <span class="hljs-comment">// 父类的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-子类中访问构造器的特点"><a href="#2-7-子类中访问构造器的特点" class="headerlink" title="2.7 子类中访问构造器的特点"></a>2.7 子类中访问构造器的特点</h3><p>各位同学，我们知道一个类中可以写成员变量、成员方法，还有构造器。在继承关系下，子类访问成员变量和成员方法的特点我们已经学过了；接下来再学习子类中访问构造器的特点。</p><p>我们先认识子类构造器的语法特点，再讲一下子类构造器的应用场景</p><blockquote><p><strong>子类中访问构造器的语法规则</strong></p></blockquote><ul><li><p>首先，子类全部构造器，都会先调用父类构造器，再执行自己。</p><p>执行顺序，如下图按照① ② ③ 步骤执行：</p></li></ul><p><img src="/assets/1664160225526.png" alt="1664160225526"></p><blockquote><p><strong>子类访问构造器的应用场景</strong></p></blockquote><ul><li>如果不想使用默认的<code>super()</code>方式调用父类构造器，还可以手动使用<code>super(参数)</code>调用父类有参数构造器。</li></ul><p><img src="/assets/1664163881728.png" alt="1664163881728"></p><blockquote><p><strong>在本类中访问自己的构造方法</strong></p></blockquote><p>刚才我们学习了通过<code>super()</code>和<code>super(参数)</code>可以访问父类的构造器。有时候我们也需要访问自己类的构造器。语法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>(): 调用本类的空参数构造器<br><span class="hljs-built_in">this</span>(参数): 调用本类有参数的构造器<br></code></pre></td></tr></table></figure><p><img src="/assets/1664170865036.png" alt="1664170865036"></p><blockquote><p><strong>最后我们被this和super的用法在总结一下</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">访问本类成员：<br><span class="hljs-built_in">this</span>.成员变量<span class="hljs-comment">//访问本类成员变量</span><br><span class="hljs-built_in">this</span>.成员方法<span class="hljs-comment">//调用本类成员方法</span><br><span class="hljs-built_in">this</span>()   <span class="hljs-comment">//调用本类空参数构造器</span><br>    <span class="hljs-built_in">this</span>(参数)  <span class="hljs-comment">//调用本类有参数构造器</span><br><br>访问父类成员：<br><span class="hljs-built_in">super</span>.成员变量<span class="hljs-comment">//访问父类成员变量</span><br><span class="hljs-built_in">super</span>.成员方法<span class="hljs-comment">//调用父类成员方法</span><br><span class="hljs-built_in">super</span>()   <span class="hljs-comment">//调用父类空参数构造器</span><br>    <span class="hljs-built_in">super</span>(参数)  <span class="hljs-comment">//调用父类有参数构造器</span><br>    <br>注意：<span class="hljs-built_in">this</span>和<span class="hljs-built_in">super</span>访问构造方法，只能用到构造方法的第一句，否则会报错。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day06-Java%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%93%E9%A2%98%EF%BC%89/"/>
    <url>/2023/12/01/day06-Java%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%93%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="day06——Java编程案例（专题）"><a href="#day06——Java编程案例（专题）" class="headerlink" title="day06——Java编程案例（专题）"></a>day06——Java编程案例（专题）</h1><p>各位同学，前面我们已经学习过很多Java的基础知识了，主要有<strong>变量、数组、运算符、流程控制、方法等</strong>。但是对于这些知识点的运用，掌握得还不是很熟练，所以今天我们专门花一天时间，给同学们讲几个专项练习题，把前面所学习的知识巩固一下。</p><p>同时通过这些专项练习题，<strong>积攒大家的代码量，以便提升大家的编程能力和编程思维</strong>。这里所说的编程思维就是使用Java技术解决问题的思维方式；编程能力就是按照编程思维编写代码的能力。</p><p>想要提升编程思维和编程能力，在这里给同学们一些学习上的建议：</p><ul><li>编程思维、编程能力不是一朝一夕形成的，需要大量思考，练习和时间的沉淀。</li><li>具体措施：前期，建议先模仿；后期，自然就能创新了；<br>勤于练习代码，勤于思考，孰能生巧。</li></ul><p>中国的航空母舰、战斗机，这些技术都是先模仿，再创新的，而且的模仿的周期是非常长的。所以同学们在使用Java技术解决问题时，也是先模仿一些特定问题的解决思路，以后遇到同类型的问题，就采用同一种思维模式来做就行。</p><p><img src="/assets/1661995636689.png" alt="1661995636689"></p><h2 id="案例一：买飞机票"><a href="#案例一：买飞机票" class="headerlink" title="案例一：买飞机票"></a>案例一：买飞机票</h2><p>各位同学，我们先来学习第一个案例《飞机买票》，先仔细阅读一下案例需求</p><p><img src="/assets/1661996140214.png" alt="1661996140214"></p><p>我们来分析一下，这个需求该如何实现。前面我跟同学们讲过，将来我们去做一些需求，都是一个一个方法来实现的，所以在这里我们也采用方法来编写。</p><p>这个方法如何编写呢？采用下面的方式来思考</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>阅读需求我们会发现，不同月份、不同原价、不同舱位类型优惠方案都不一样；<br>所以，可以将原价、月份、舱位类型写成参数<br><br><span class="hljs-number">2.</span>接着，考虑方法是否有返回值？<br>阅读需求我们发现，最终结果是求当前用户的优惠票价<br>所以，可以将优惠票价作为方法的返回值。<br><br><span class="hljs-number">3.</span>最后，再考虑方法内部的业务逻辑<br>先使用<span class="hljs-keyword">if</span>判断月份是旺季还是淡季，然后使用<span class="hljs-keyword">switch</span>分支判断是头等舱还是经济舱，计算票价<br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成买飞机票的案例。</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> calculate(<span class="hljs-number">1000</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&quot;头等舱&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;优惠价是：&quot;</span> + price);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">double</span> price,<span class="hljs-type">int</span> month,String type)</span>&#123;<br>        <span class="hljs-comment">// 1、判断当前月份是淡季还是旺季</span><br>        <span class="hljs-keyword">if</span>(month &gt;= <span class="hljs-number">5</span> &amp;&amp; month &lt;= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 旺季</span><br>            <span class="hljs-comment">// 2、判断仓位类型。</span><br>            <span class="hljs-keyword">switch</span> (type)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;头等舱&quot;</span>:<br>                    price *= <span class="hljs-number">0.9</span>; <span class="hljs-comment">// price = price * 0.9;</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;经济舱&quot;</span>:<br>                    price *= <span class="hljs-number">0.85</span>;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 淡季</span><br>            <span class="hljs-keyword">switch</span> (type)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;头等舱&quot;</span>:<br>                    price *= <span class="hljs-number">0.7</span>; <span class="hljs-comment">// price = price * 0.7;</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;经济舱&quot;</span>:<br>                    price *= <span class="hljs-number">0.65</span>;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例二：开发验证码"><a href="#案例二：开发验证码" class="headerlink" title="案例二：开发验证码"></a>案例二：开发验证码</h2><p>各位同学，接下来，我们学习第二个案例《开发验证码》，同样先阅读一下案例需求</p><p><img src="/assets/1661996187012.png" alt="1661996187012"></p><p>分析一下，需求是要我们开发一个程序，生成指定位数的验证码。考虑到实际工作中生成验证码的功能很多地方都会用到，为了提高代码的复用性，我们还是把生成验证码的功能写成方法比较好。</p><p>那生成验证码的方法该怎么写呢？按照下面的三个步骤进行思考</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>要求生成指定位数的验证码，到底多少位呢？让调用者传递即可<br>所以，需要一个参数，用来表示验证码的位数<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要有返回值？<br>该方法的结果，就是为了得到验证码<br>所以，返回值就是验证码；<br><br><span class="hljs-number">3.</span>最后，再考虑方法内部的业务逻辑<br><span class="hljs-number">1</span>)先按照方法接收的验证码位数n,循环n次<br><span class="hljs-number">2</span>)每次循环，产生一个字符，可以是数字字符、或者大小写字母字符<br><span class="hljs-number">3</span>)定义一个String类型的变量用于记住产生的每位随机字符<br></code></pre></td></tr></table></figure><p>按照思路，编写代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成生成随机验证码。</span><br>        System.out.println(createCode(<span class="hljs-number">8</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-comment">//1)先按照方法接收的验证码位数n,循环n次</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">//3)定义一个String类型的变量用于记住产生的每位随机字符</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// i = 1 2 3 4 5</span><br>            <span class="hljs-comment">//2)每次循环，产生一个字符，可以是数字字符、或者大小写字母字符</span><br>            <span class="hljs-comment">// 思路：随机一个0 1 2之间的数字出来，0代表随机一个数字字符，1、2代表随机大写字母，小写字母。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">3</span>); <span class="hljs-comment">// 0 1 2</span><br>            <span class="hljs-keyword">switch</span> (type) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    <span class="hljs-comment">// 随机一个数字字符</span><br>                    code += r.nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 0 - 9  code = code + 8</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    <span class="hljs-comment">// 随机一个大写字符 A 65   Z 65+25    (0 - 25) + 65</span><br>                    <span class="hljs-type">char</span> <span class="hljs-variable">ch1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>) (r.nextInt(<span class="hljs-number">26</span>) + <span class="hljs-number">65</span>);<br>                    code += ch1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    <span class="hljs-comment">// 随机一个小写字符 a 97   z 97+25    (0 - 25) + 97</span><br>                    <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>) (r.nextInt(<span class="hljs-number">26</span>) + <span class="hljs-number">97</span>);<br>                    code += ch2;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例三：评委打分"><a href="#案例三：评委打分" class="headerlink" title="案例三：评委打分"></a>案例三：评委打分</h2><p>各位同学，接下来，我们学习第三个案例《评委打分》，同样先阅读一下案例需求</p><p><img src="/assets/1661996204673.png" alt="1661996204673">我们把上面的需求还是用方法来编写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据来处理？<br>需求中说，有多个评委的打分，但是到底多少个评委呢？ 可以由调用者传递<br>所以，我们可以把评委的个数写成参数；<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要有返回值？<br>需求中，想要的最终结果是平均分<br>所以，返回值就是平均分；<br><br><span class="hljs-number">3.</span>最后，再考虑方法内部的业务逻辑<br><span class="hljs-number">1</span>)假设评委的个位为n个，那么就需要n个评委的分数，首先可以新建一个长度为n的数组，用来存储每一个评委的分数<br><br><span class="hljs-number">2</span>)循环n次，使用Scanner键盘录入n个<span class="hljs-number">1</span>~<span class="hljs-number">100</span>范围内的整数，并把整数存储到数组中<br><br><span class="hljs-number">3</span>)求数组中元素的总和、最大值、最小值<br><br><span class="hljs-number">4</span>)最后再计算平均值； 平均值 = (和-最大值-最小值)/(数组.length-<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成评委打分案例。</span><br>        System.out.println(<span class="hljs-string">&quot;当前选手得分是：&quot;</span> + getAverageScore(<span class="hljs-number">6</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAverageScore</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-comment">// 1、定义一个动态初始化的数组，负责后期存入评委的打分</span><br>        <span class="hljs-type">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 6</span><br>        <span class="hljs-comment">// scores = [0, 0, 0, 0, 0, 0]</span><br><br>        <span class="hljs-comment">// 2、遍历数组的每个位置，依次录入评委的分数</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++) &#123;<br>            <span class="hljs-comment">// i = 0 1 2 3 4 5</span><br>            System.out.println(<span class="hljs-string">&quot;请您录入第&quot;</span>+ (i + <span class="hljs-number">1</span>) +<span class="hljs-string">&quot;个评委的分数：&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            scores[i] = score;<br>        &#125;<br><br>        <span class="hljs-comment">// 3、从数组中计算出总分，找出最高分，最低分。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 求总分用的变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> scores[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 求最大值的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> scores[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 求最小值的。</span><br><br>        <span class="hljs-comment">// 遍历数组找出这些数据的。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++) &#123;<br>            <span class="hljs-comment">// i = 0 1 2 3 4 5</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> scores[i];<br>            <span class="hljs-comment">// 求和</span><br>            sum += score;<br>            <span class="hljs-comment">// 求最大值</span><br>            <span class="hljs-keyword">if</span>(score &gt; max)&#123;<br>                max = score;<br>            &#125;<br>            <span class="hljs-comment">// 求最小值</span><br>            <span class="hljs-keyword">if</span>(score &lt; min)&#123;<br>                min = score;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 4、计算出平均分并返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> * (sum - min - max) / (number - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例四：数字加密"><a href="#案例四：数字加密" class="headerlink" title="案例四：数字加密"></a>案例四：数字加密</h2><p>各位同学，接下来我们学习第四个案例《数字加密》，我们还是先阅读一下案例需求</p><p><img src="/assets/1661996239984.png" alt="1661996239984"></p><p>仔细阅读需求后发现，简答来说该需求要做的事情，就是把一个4位数的整数，经过一系列的加密运算（至于怎么运算，待会再详细分析），得到一个新的整数。</p><p>我们还是把这个需求用方法来实现，按照下面的思维模式进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>需要一个<span class="hljs-number">4</span>位数，至于是哪一个数，让方法的调用者传递。<br>所以，方法的参数，就是这个需要加密的四位数<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要有返回值？<br>方法最终的结果是一个加密后的数据<br>所以，返回值就表示为加密后的数据。<br><br><span class="hljs-number">3.</span>最后，再考虑方法内部的业务逻辑，这里的业务逻辑就是那一系列的加密运算<br><span class="hljs-number">1</span>)先要把<span class="hljs-number">4</span>位数整数拆分为，<span class="hljs-number">4</span>个数字，用一个数组保存起来<br><span class="hljs-number">2</span>)再将数组中的每一个元素加<span class="hljs-number">5</span>，再对<span class="hljs-number">10</span>取余<br><span class="hljs-number">3</span>)最后将数组中的元素反转，<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成数字加密程序的开发。</span><br>        System.out.println(<span class="hljs-string">&quot;加密后的结果是：&quot;</span> + encrypt(<span class="hljs-number">8346</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span>&#123;<br>        <span class="hljs-comment">// number = 1983</span><br>        <span class="hljs-comment">// 1、把这个密码拆分成一个一个的数字，才可以对其进行加密啊。</span><br>        <span class="hljs-type">int</span>[] numbers = split(number);<br>        <span class="hljs-comment">// numbers = [1, 9, 8, 3]</span><br><br>        <span class="hljs-comment">// 2、遍历这个数组中的每个数字，对其进行加密处理。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numbers.length; i++) &#123;<br>            <span class="hljs-comment">// i = 0 1 2 3</span><br>            numbers[i] = (numbers[i] + <span class="hljs-number">5</span>) % <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-comment">// numbers = [6, 4, 3, 8]</span><br><br>        <span class="hljs-comment">// 3、对数组反转，把对数组进行反转的操作交给一个独立的方法来完成</span><br>        reverse(numbers);<br>        <span class="hljs-comment">// numbers = [8, 3, 4, 6]</span><br><br>        <span class="hljs-comment">// 4、把这些加密的数字拼接起来做为加密后的结果返回即可。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numbers.length; i++) &#123;<br>            data += numbers[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-comment">// 反转数组的</span><br>        <span class="hljs-comment">// numbers = [6, 4, 3, 8]</span><br>        <span class="hljs-comment">//            i        j</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = numbers.length - <span class="hljs-number">1</span>; i &lt; j; i++,j--) &#123;<br>            <span class="hljs-comment">// 交换i和j位置处的值。</span><br>            <span class="hljs-comment">// 1、把后一个位置处的值交给一个临时变量先存起来</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> numbers[j];<br>            <span class="hljs-comment">// 2、把前一个位置处的值赋值给后一个位置处</span><br>            numbers[j] = numbers[i];<br>            <span class="hljs-comment">// 3、把后一个位置处原来的值（由临时变量记住着）赋值给前一个位置</span><br>            numbers[i] = temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] split(<span class="hljs-type">int</span> number) &#123;<br>        <span class="hljs-comment">// number = 1983</span><br>        <span class="hljs-type">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        numbers[<span class="hljs-number">0</span>] = number / <span class="hljs-number">1000</span>;<br>        numbers[<span class="hljs-number">1</span>] = (number / <span class="hljs-number">100</span>) % <span class="hljs-number">10</span>;<br>        numbers[<span class="hljs-number">2</span>] = (number / <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>;<br>        numbers[<span class="hljs-number">3</span>] = number % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> numbers;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例五：数组拷贝"><a href="#案例五：数组拷贝" class="headerlink" title="案例五：数组拷贝"></a>案例五：数组拷贝</h2><p>各位同学，接下来我们学习第五个案例《数组拷贝》，我们还是先阅读一下案例需求</p><p><img src="/assets/1661996258614.png" alt="1661996258614"></p><p>仔细阅读需求发现，想要实现的效果就是：给定一个数组，然后经过我们编写的程序，得到一个和原数组一模一样的数组。</p><p>我们也采用一个方法来编写，按照下面的思维模式来思考</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>该方法的目的是拷贝数组，拷贝哪一个数组呢？ 需要调用者传递<br>所以，参数应该是一个数组<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要有返回值？<br>该方法最终想要得到一个新数组<br>所以，返回值是拷贝得到的新数组<br><br><span class="hljs-number">3.</span>最后，考虑方法内部的业务逻辑？<br><span class="hljs-number">1</span>)创建一个新的数组，新数组的长度和元素数组一样<br><span class="hljs-number">2</span>)遍历原数组，将原数组中的元素赋值给新数组<br><span class="hljs-number">3</span>)最终将新数组返回<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握数组拷贝。</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;;<br>        <span class="hljs-type">int</span>[] arr2 = copy(arr);<br>        printArray(arr2);<br><br>        <span class="hljs-comment">// 注意：这个不是拷贝数组，叫把数组变量赋值给另一个数组变量。</span><br>        <span class="hljs-comment">//        int[] arr3 = arr;</span><br>        <span class="hljs-comment">//        arr3[1] = 666;</span><br>        <span class="hljs-comment">//        System.out.println(arr[1]);</span><br><br>        arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">666</span>;<br>        System.out.println(arr[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copy(<span class="hljs-type">int</span>[] arr)&#123;<br>        <span class="hljs-comment">// arr = [11, 22, 33]</span><br>        <span class="hljs-comment">//        0    1   2</span><br><br>        <span class="hljs-comment">// 1、创建一个长度一样的整型数组出来。</span><br>        <span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        <span class="hljs-comment">// arr2 = [0, 0, 0]</span><br>        <span class="hljs-comment">//         0  1  2</span><br><br>        <span class="hljs-comment">// 2、把原数组的元素值对应位置赋值给新数组。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">// i = 0 1 2</span><br>            arr2[i] = arr[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arr2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(i==arr.length-<span class="hljs-number">1</span> ? arr[i] : arr[i] + <span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例六：抢红包"><a href="#案例六：抢红包" class="headerlink" title="案例六：抢红包"></a>案例六：抢红包</h2><p>各位同学，接下来我们学习第六个案例《抢红包》，我们还是先阅读一下案例需求</p><p><img src="/assets/1661996292796.png" alt="1661996292796"></p><p><img src="/assets/1662022389872.png" alt="1662022389872"></p><p>我们还是把这个案例用一个方法来编写，同样按照下面的模式来分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>需要接收<span class="hljs-number">5</span>个红包，至于是哪<span class="hljs-number">5</span>个红包，可以有调用者传递；把<span class="hljs-number">5</span>个红包的数值，用数组来存 储。<br>所以，参数就是一个数组<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要有返回值？<br>按照需求的效果，抢完红包就直接打印了，不需要返回值<br><br><span class="hljs-number">3.</span>最后，考虑方法内部的业务逻辑是怎么的？<br>思考：红包实际上是数组中的元素，抢红包实际上随机获取数组中的元素；而且一个红包只能抢一次，怎么做呢？我们可以把数组中获取到元素的位置，置为<span class="hljs-number">0</span>,下次再或者这个位置的元素一判断为<span class="hljs-number">0</span>，再重新获取新的元素，依次内推，直到把数组中所有的元素都获取完。<br><br>我们我们把抽红包的思路再整理一下：<br><span class="hljs-number">1</span>)首先，写一个循环，循环次数为数组的长度<br><span class="hljs-number">2</span>)每次循环，键盘录入，提示<span class="hljs-string">&quot;用户录入任意键抽奖：&quot;</span><br>    <span class="hljs-number">3</span>)随机从数组中产生一个索引，获取索引位置的元素，这个元素就表示抽的红包<br>如果值不为<span class="hljs-number">0</span>，则打印如：<span class="hljs-string">&quot;恭喜您，您抽中了520元&quot;</span>,把这个位置元素置为<span class="hljs-number">0</span><br>    如果值为<span class="hljs-number">0</span>，则说明这个红包被抽过，重新循环到第<span class="hljs-number">2</span>步，重新抽奖<br>    【注意：如果当前这一次没有抽中，这一次抽奖机会被浪费掉了，我们可以把控制循环的次数自减一下】<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] moneys = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">999</span>,<span class="hljs-number">50</span>,<span class="hljs-number">520</span>,<span class="hljs-number">1314</span>&#125;;<br>        start(moneys);<br>    &#125;<br>    <span class="hljs-comment">//开始抽奖</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">int</span>[] moneys)</span>&#123;<br>        <span class="hljs-comment">//1)首先，写一个循环，循环次数为数组的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; moneys.length; i++) &#123;<br>            <span class="hljs-comment">//2)每次循环，键盘录入，提示&quot;用户录入任意键抽奖：&quot;</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>                System.out.print(<span class="hljs-string">&quot;用户录入任意键抽奖：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.next();<br>                <span class="hljs-comment">//3)随机从数组中产生一个索引，获取索引位置的元素，这个元素就表示抽的红包</span><br>                <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> r.nextInt(moneys.length);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> moneys[index];<br>                <span class="hljs-keyword">if</span>(money!=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//如果值不为0，则打印如：&quot;恭喜您，您抽中了520元&quot;</span><br>                    System.out.println(<span class="hljs-string">&quot;恭喜您，您抽中了&quot;</span>+money+<span class="hljs-string">&quot;元&quot;</span>);<br>                    moneys[index] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果值为0，则说明这个红包被抽过，重新循环到第2步，重新抽奖</span><br>                    <span class="hljs-comment">//此时这一次抽奖机会被浪费掉了，可以把控制循环的次数自减一下</span><br>                    i--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例七：找素数"><a href="#案例七：找素数" class="headerlink" title="案例七：找素数"></a>案例七：找素数</h2><p>各位同学，接下来我们学习第七个案例《找素数》，我们还是先阅读一下案例需求</p><p><img src="/assets/1661996325454.png" alt="1661996325454"></p><p>首先我们得统一认识一下什么是素数：<strong>只能被1和本身整除的数是素数</strong>，比如：3、7是素数，9,21不是素数（因为9可以被3整除，21可以被3和7整除）</p><p>再思考题目需求该怎么做？<strong>打印输出101~200之间的素数，并求有多少个？</strong>，我们也是把这个需求写成一个方法，还是按照三个步骤分析方法如何编写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>该方法是求一个范围内的素数，一个范围需要两个数据来确定，比如：<span class="hljs-number">101</span>~<span class="hljs-number">200</span><br>所以，方法需要两个参数来接收范围的开始值start，和范围的结束值end<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要返回值？<br>该方法需要求一个范围内的素数的个数<br>所以，返回值就是素数的个数<br><br><span class="hljs-number">3.</span>最后，考虑方法内部的业务逻辑<br>思考：怎么判断一个数是素数呢？要仅仅抓住，素数的要求:“只能被<span class="hljs-number">1</span>和本身整除的数是素数”。我们可以从反向思考，如果这个数只要能被除了<span class="hljs-number">1</span>和本身以外的数整除，那么这个数就不是素数。<br><span class="hljs-comment">//比如1：判断9是否为素数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//规定flag等于true表示num是素数；否则表示num不是素数</span><br><span class="hljs-comment">//如果这个数num只要能被除了1和本身以外的数整除，那么这个数就不是素数。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>; j&lt;<span class="hljs-number">9</span>-<span class="hljs-number">1</span>; j++)&#123;<br>        <span class="hljs-comment">//当j=3时，num%j == 9%3 == 0; </span><br><span class="hljs-keyword">if</span>(num%j==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//说明num=9; 表示一个素数。把flag改为false; </span><br>            flag = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br>把上面的代码循环执行，每次循环然后把num换成start~end之间的整数即可。<br></code></pre></td></tr></table></figure><p>编写代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成找素数。</span><br>        System.out.println(<span class="hljs-string">&quot;当前素数的个数是：&quot;</span> + search(<span class="hljs-number">101</span>, <span class="hljs-number">200</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// start = 101   end = 200</span><br>        <span class="hljs-comment">// 1、定义一个for循环找到101到200之间的每个数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end ; i++) &#123;<br>            <span class="hljs-comment">// i = 101 102 103 ... 199 200</span><br><br>            <span class="hljs-comment">// 信号位思想</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 假设的意思：默认当前i记住的数据是素数。</span><br>            <span class="hljs-comment">// 2、判断当前i记住的这个数据是否是素数。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// i当前记住的这个数据不是素数了</span><br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 3、根据判定的结果决定是否输出i当前记住的数据：是素数才输出展示。</span><br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                System.out.println(i);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例八：模拟双色球-拓展案例"><a href="#案例八：模拟双色球-拓展案例" class="headerlink" title="案例八：模拟双色球[拓展案例]"></a>案例八：模拟双色球[拓展案例]</h2><p>各位同学，接下来我们学习第八个案例《模拟双色球》，我们还是先阅读一下案例需求</p><p><img src="/assets/1661996916834.png" alt="1661996916834"></p><p>这个案例我们可以采用方法方法来完成</p><ol><li>第一个方法，让用户手动投注，产生一注双色球彩票</li></ol><p><img src="/assets/1662026373775.png" alt="1662026373775"></p><ol start="2"><li>第二个方法，由系统随机产生一注双色球彩票开奖号码</li></ol><p><img src="/assets/1662026388626.png" alt="1662026388626"></p><ol start="3"><li>第三个方法，判断传入两组号码，用于判断彩票的中奖情况</li></ol><p><img src="/assets/1662026410363.png" alt="1662026410363"></p><h3 id="8-1-手动投注"><a href="#8-1-手动投注" class="headerlink" title="8.1 手动投注"></a>8.1 手动投注</h3><p>编写一个方法，让用户手动投注，产生一注双色球彩票，思路分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>双色球彩票的规则非常明确，没有什么数据需要传递给方法。<br>所以，不需要参数<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要返回值？<br>方法最终的结果是需要一注双色球彩票的号码，一注彩票有<span class="hljs-number">7</span>个号码，可以用一个数组来存<br>所以，返回值是一个数组<br><br><span class="hljs-number">3.</span>最后，考虑方法内部的业务逻辑怎么编写？<br><span class="hljs-number">1</span>)首先需要准备一个<span class="hljs-type">int</span>类型数组，长度为<span class="hljs-number">7</span>; 用于存储产生的投注号码<br><span class="hljs-number">2</span>)循环遍历数组的前<span class="hljs-number">6</span>个元素，采用键盘录入的方式，给前区<span class="hljs-number">6</span>个红球赋值<br>要求录入的整数在<span class="hljs-number">1</span>~<span class="hljs-number">33</span>范围内，同时录入的整数在数组中不能已存在，否则重新录入<br><span class="hljs-number">3</span>)最后再录入一个整数，给后区一个蓝球赋值<br>要求整数必须在<span class="hljs-number">1</span>~<span class="hljs-number">16</span>范围内<br></code></pre></td></tr></table></figure><ul><li>手动投注代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 1、设计一个方法，用于让用户投注一组号码并返回（前6个是红球号码，最后1个是蓝球号码 ）*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] userSelectNumbers()&#123;<br>    <span class="hljs-comment">// 2、创建一个整型数组，用于存储用户投注的7个号码（前6个是红球号码，最后1个是蓝球号码 ）</span><br>    <span class="hljs-type">int</span>[] numbers =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">7</span>];<br>    <span class="hljs-comment">// numbers = [0, 0, 0, 0, 0, 0, 0]</span><br>    <span class="hljs-comment">//            0  1  2  3  4  5  6</span><br><br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-comment">// 3、遍历前6个位置，让用户依次投注6个红球号码，存入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numbers.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// i = 0 1 2 3 4 5</span><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 4、开始让用户为当前位置投注一个红球号码（1-33之间，不能重复）</span><br>            System.out.println(<span class="hljs-string">&quot;请您输入第&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个红球号码（1-33之间，不能重复）：&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>            <span class="hljs-comment">// 5、先判断用户输入的红球号码是否在1-33之间</span><br>            <span class="hljs-keyword">if</span>(number &lt; <span class="hljs-number">1</span> || number &gt; <span class="hljs-number">33</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;对不起，您输入的红球号码不在1-33之间，请确认！&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 号码是在1-33之间了，接着还要继续判断这个号码是否重复，不重复才可以使用。</span><br>                <span class="hljs-keyword">if</span>(exist(numbers, number))&#123;<br>                    <span class="hljs-comment">// number当前这个红球号码是重复了。</span><br>                    System.out.println(<span class="hljs-string">&quot;对不起，您当前输入的红球号码前面选择过，重复了，请确认！&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// number记住的这个号码没有重复了，就可以使用了。</span><br>                    numbers[i] = number;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 结束当次投注，结束了当前死循环。</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6、投注最后一个蓝球号码。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;请您输入最后1个蓝球号码（1-16）：&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-keyword">if</span>(number &lt; <span class="hljs-number">1</span> || number &gt; <span class="hljs-number">16</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;对不起，您输入的蓝球号码范围不对！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            numbers[<span class="hljs-number">6</span>] = number;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 蓝球号码录入成功，结束死循环</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> numbers;<br>&#125;<br></code></pre></td></tr></table></figure><p>每键盘录入一个号码，需要判断这个号码在数组中是否存在，存在返回true；不存在返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> number)</span> &#123;<br>    <span class="hljs-comment">// 需求：判断number这个数字是否在numbers数组中存在。</span><br>    <span class="hljs-comment">// numbers = [12, 25, 18, 0, 0, 0, 0]</span><br>    <span class="hljs-comment">// number = 12</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numbers.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(numbers[i] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(numbers[i] == number)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了打印一注彩票的号码（数组中的元素），把打印数组中的元素也写成方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        System.out.print(i == arr.length - <span class="hljs-number">1</span> ? arr[i] : arr[i] + <span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;]&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在main方法中测试，运行看能不能产生一注彩票号码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成双色球系统的开发。</span><br>        <span class="hljs-type">int</span>[] userNumbers = userSelectNumbers();<br>        System.out.println(<span class="hljs-string">&quot;您投注的号码：&quot;</span>);<br>        printArray(userNumbers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-随机开奖号码"><a href="#8-2-随机开奖号码" class="headerlink" title="8.2 随机开奖号码"></a>8.2 随机开奖号码</h3><p>编写一个方法，让用户自动机选投注，产生一注双色球彩票，思路分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>双色球彩票的规则非常明确，没有什么数据需要传递给方法。<br>所以，不需要参数<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要返回值？<br>方法最终的结果是需要一注双色球彩票的号码，一注彩票有<span class="hljs-number">7</span>个号码，可以用一个数组来存<br>所以，返回值是一个数组<br><br><span class="hljs-number">3.</span>最后，考虑方法内部的业务逻辑怎么编写？<br><span class="hljs-number">1</span>)首先需要准备一个<span class="hljs-type">int</span>类型数组，长度为<span class="hljs-number">7</span>; 用于存储产生的投注号码<br><span class="hljs-number">2</span>)循环遍历数组的前<span class="hljs-number">6</span>个元素，采用生成随机数的的方式，给前区<span class="hljs-number">6</span>个红球赋值<br>要求生成的随机数在<span class="hljs-number">1</span>~<span class="hljs-number">33</span>范围内，同时随机的整数数组中不能已存在，否则重新生产<br><span class="hljs-number">3</span>)最后再随机一个整数，给后区一个蓝球赋值<br>要求随机整数必须在<span class="hljs-number">1</span>~<span class="hljs-number">16</span>范围内<br></code></pre></td></tr></table></figure><p>机选号码，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 2、设计一个方法：随机一组中奖号码出来（6个红球号码，1个蓝球号码 ）*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] createLuckNumbers()&#123;<br>    <span class="hljs-comment">// 1、创建一个整型数组，用于存储这7个号码</span><br>    <span class="hljs-type">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">7</span>];<br><br>    <span class="hljs-type">Random</span> <span class="hljs-variable">r</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-comment">// 2、遍历前6个位置处，依次随机一个红球号码存入（1-33 不重复）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numbers.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// i = 0 1 2 3 4 5</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 3、为当前这个位置随机一个红球号码出来存入。</span><br>            <span class="hljs-comment">//1 - 33 ==&gt; -1 ===&gt; (0 , 32) + 1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">33</span>) + <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 4、判断这个号码是否之前出现过（红球号码不能重复）。</span><br>            <span class="hljs-keyword">if</span>(!exist(numbers, number))&#123;<br>                <span class="hljs-comment">// number不重复。</span><br>                numbers[i] = number;<br>                <span class="hljs-comment">//结束死循环，代表找到了当前这个位置的一个不重复的红球号码了。</span><br>                <span class="hljs-keyword">break</span>; <br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3、录入一个蓝球号码。 1-16</span><br>    numbers[<span class="hljs-number">6</span>] = r.nextInt(<span class="hljs-number">16</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> numbers;<br>&#125;<br></code></pre></td></tr></table></figure><p>在main方法中测试，看是否能够产生一注彩票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成双色球系统的开发。</span><br>        <span class="hljs-comment">//用户手动投注</span><br>        <span class="hljs-type">int</span>[] userNumbers = userSelectNumbers();<br>        System.out.println(<span class="hljs-string">&quot;您投注的号码：&quot;</span>);<br>        printArray(userNumbers);<br>        <br>        <span class="hljs-comment">//生成中奖号码</span><br>        <span class="hljs-type">int</span>[] luckNumbers = createLuckNumbers();<br>        System.out.println(<span class="hljs-string">&quot;中奖的号码：&quot;</span>);<br>        printArray(luckNumbers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-3-判断是否中奖"><a href="#8-3-判断是否中奖" class="headerlink" title="8.3 判断是否中奖"></a>8.3 判断是否中奖</h3><p>编写一个方法，判断用户的彩票号码是否中奖，具体中奖规则如下</p><ul><li><p>6个红球+1个蓝球 ，奖金1000万</p></li><li><p>6个红球+0个蓝球，奖金500万</p></li><li><p>5个红球+1个蓝球，奖金3000块</p></li><li><p>5个红球+0个蓝球，或者4个红球+1个蓝球，奖金200块</p></li><li><p>4个红球+0个蓝球，或者3个红球+1个蓝球，奖金10块</p></li><li><p>小于3个红球+1个蓝球，奖金5块</p></li><li><p>如果前面的都不成立，就中奖，算你为福利事业做贡献了。</p></li></ul><p>编写方法的思路如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>首先，考虑方法是否需要接收数据处理？<br>判断彩票是否中奖，需要有两组号码；一组号码是彩票号码，一组号码是开奖号码<br>所以，参数需要有两个数组<br><br><span class="hljs-number">2.</span>接着，考虑方法是否需要返回值？<br>方法不需要返回结果，中了奖，直接将奖项打印输出就行了。<br>【注意：这只是提供一种代码的编写方案，你将中奖的金额返回也行】<br><br><span class="hljs-number">3.</span>最后，考虑方法内部的业务逻辑怎么编写？<br><span class="hljs-number">1</span>)定义两个变量redCount和blueCount用来记录，红球的个数和蓝球的个数<br><span class="hljs-number">2</span>)遍历两个数组中前<span class="hljs-number">6</span>个元素(红球)，判断两个数组中有没有相同元素<br>如果找到一个相同元素，则redCount++<br>    <span class="hljs-number">3</span>)比较两个数组中最后一个元素(蓝球)是否相同<br>    如果相同，则blueCount++<br><span class="hljs-number">4</span>)根据红球和蓝球的命中个数，打印输出对应的奖项<br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 3、设计一个方法，用于判断用户的中奖情况 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] userNumbers,<span class="hljs-type">int</span>[] luckNumbers)</span>&#123;<br>    <span class="hljs-comment">// userNumbers = [12, 14, 16, 18, 23, 26, 8]</span><br>    <span class="hljs-comment">// luckNumbers = [16, 17, 18, 19, 26, 32, 8]</span><br><br>    <span class="hljs-comment">// 2、分别定义2个变量用于记住红球命中了几个以及蓝球命中了几个</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">redCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">blueCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 先判断红球命中的数量。</span><br>    <span class="hljs-comment">// 遍历用户投注的号码的前6个红球</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; userNumbers.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// userNumbers[i]</span><br>        <span class="hljs-comment">// 开始遍历中奖号码的前6个红球号码，看用户当前选择的这个号码是否命中了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; luckNumbers.length - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span>(userNumbers[i] == luckNumbers[j])&#123;<br>                redCount++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3、判断蓝球是否命中了</span><br>    blueCount = userNumbers[<span class="hljs-number">6</span>] == luckNumbers[<span class="hljs-number">6</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>    System.out.println(<span class="hljs-string">&quot;您命中的红球数量是：&quot;</span> + redCount);<br>    System.out.println(<span class="hljs-string">&quot;您命中的蓝球数量是：&quot;</span> + blueCount);<br><br>    <span class="hljs-comment">// 4、判断中奖详情，并输出结果</span><br>    <span class="hljs-keyword">if</span>(redCount == <span class="hljs-number">6</span> &amp;&amp; blueCount == <span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;恭喜您，中奖1000万，可以开始享受人生了~~~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(redCount == <span class="hljs-number">6</span> &amp;&amp; blueCount == <span class="hljs-number">0</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;恭喜您，中奖500万，可以稍微开始享受人生了~~~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(redCount == <span class="hljs-number">5</span> &amp;&amp; blueCount == <span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;恭喜您，中奖3000元，可以出去吃顿小龙虾了~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(redCount == <span class="hljs-number">5</span> &amp;&amp; blueCount == <span class="hljs-number">0</span> || redCount == <span class="hljs-number">4</span> &amp;&amp; blueCount == <span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;恭喜您，中了小奖：200元~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(redCount == <span class="hljs-number">4</span> &amp;&amp; blueCount == <span class="hljs-number">0</span> || redCount == <span class="hljs-number">3</span> &amp;&amp; blueCount == <span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;中了10元~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( redCount &lt; <span class="hljs-number">3</span> &amp;&amp; blueCount == <span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;中了5元~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;感谢您对福利事业做出的巨大贡献~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在main方法中测试，检测是否中奖的方法是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成双色球系统的开发。</span><br>        <span class="hljs-comment">//用户投注</span><br>        <span class="hljs-type">int</span>[] userNumbers = userSelectNumbers();<br>        System.out.println(<span class="hljs-string">&quot;您投注的号码：&quot;</span>);<br>        printArray(userNumbers);<br><br>        <span class="hljs-comment">//随机产生一个中奖号码</span><br>        <span class="hljs-type">int</span>[] luckNumbers = createLuckNumbers();<br>        System.out.println(<span class="hljs-string">&quot;中奖的号码：&quot;</span>);<br>        printArray(luckNumbers);<br><br>        <span class="hljs-comment">//判断用户投注的号码是否中奖</span><br>        judge(userNumbers, luckNumbers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day05-%E6%96%B9%E6%B3%95/"/>
    <url>/2023/12/01/day05-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="day05——方法"><a href="#day05——方法" class="headerlink" title="day05——方法"></a>day05——方法</h1><p>各位同学，今天我们学习的内容是方法。方法也是Java语言中一个很重要的组成部分，在实际开发中几乎每时每刻都在使用方法。所以对于今天的课程一定要搞清楚。</p><p>我们先来学习一下方法是什么</p><h2 id="一、方法概述"><a href="#一、方法概述" class="headerlink" title="一、方法概述"></a>一、方法概述</h2><p><strong>1.1 方法是什么</strong></p><p><strong>方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用。</strong>这句话什么意思呢？意思是，把一段功能代码围在一起，别人都可以来调用它。</p><p>下图是方法的完整格式</p><p><img src="/assets/1661667297650.png" alt="1661667297650"></p><p>我们看一个需求，比如现在张工、李工两个人都需要求两个整数的和。不使用方法，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、李工。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a+b;<br>System.out.println(<span class="hljs-string">&quot;和是：&quot;</span> + c);<br><br><br><span class="hljs-comment">// 2、张工。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> a1+b1;<br>System.out.println(<span class="hljs-string">&quot;和是：&quot;</span> + c1);<br></code></pre></td></tr></table></figure><p>阅读上面的代码，我们不难发现。两次求和的代码中，除了求和的数据不一样，代码的组织结构完全一样。</p><p><strong>像这种做相同事情的代码，就可以用方法进行封装</strong>。需要用到这段代码功能时，让别人调用方法就行。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//目标：掌握定义方法的完整格式，搞清楚使用方法的好处。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 需求：假如现在很多程序员都要进行2个整数求和的操作。</span><br>        <span class="hljs-comment">// 1、李工。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;和是：&quot;</span> + rs);<br><br>        <span class="hljs-comment">// 2、张工。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> sum(<span class="hljs-number">30</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;和是：&quot;</span> + rs2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1.2 方法的执行流程</strong></p><p>当调用一个方法时，执行流程，按照下图中标注的序号执行。</p><p>​① 通过sum方法名找到sum方法</p><p>​② 把10传递给方法中的参数a</p><p>​③ 把20传递给方法中的参数b；</p><p>​④  执行方法中的代码，此时<code>int c=a+b;</code>; 相当于 <code>int c = 10+20</code>; c的值为30</p><p>​ <code>return c</code> 的含义是，把c的结果返回给调用处。 也就是调用sum方法的结果为30,</p><p><img src="/assets/1661668878007.png" alt="1661668878007"></p><p>学习完方法的执行流程之后，下面有几个注意事项需要我们写代码时注意一下。</p><p><strong>1.3 定义方法的注意点</strong></p><p><img src="/assets/1661680196574.png" alt="1661680196574"></p><ol><li><p>方法的修饰符：暂时都使用public static 修饰。（目前看做是固定写法，后面是可以改动的）</p></li><li><p>方法申明了具体的返回值类型，内部必须使用return返回对应类型的数据。</p></li><li><p>形参列表可以有多个，甚至可以没有； 如果有多个形参，多个形参必须用“，”隔开，且不能给初始化值。</p></li></ol><p><strong>1.4 使用方法的好处</strong></p><p>最好，我们总结一下，用方法有什么好处，可以归纳为下面2点：</p><ol><li>提高了代码的复用性，提高了开发效率。</li><li>让程序的逻辑更清晰。</li></ol><p>如下图所示：写好一个方法之后，每一个人都可以直接调用，而不用再重复写相同的代码。所以是提高了代码的复用性，不用写重复代码，自然也提高了开发效率。</p><p><img src="/assets/1661680445407.png" alt="1661680445407"></p><p>那么让程序的逻辑更加清晰，是如何体现的呢？ 比如，我们后期会用所学习的技术，做一个ATM系统，ATM系统中有查看账户、存钱、取钱、修改密码等功能，到时候我们可以把每一个功能都写成一个方法。如下图所示，这样程序的逻辑就更加清晰了。</p><p><img src="/assets/1661680833652.png" alt="1661680833652"></p><p>好了，关于方法是什么，以及方法的基本使用就学习到这里。</p><p><strong>总结一下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>什么是方法？<br>答：方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用<br><span class="hljs-number">2.</span>方法的完整格式是什么样的？<br><span class="hljs-comment">//格式如下：</span><br>修饰符  返回值类型  方法名( 形参列表 )&#123;<br>    方法体代码(需要执行的功能代码)<br>       <span class="hljs-keyword">return</span> 返回值;<br>    &#125;<br><span class="hljs-number">3.</span>方法要执行必须怎么办？<br>必须调用才执行; <br><span class="hljs-comment">//调用格式:</span><br>方法名(...);<br><br><span class="hljs-number">4.</span>使用方法有什么好处？<br>答：提高代码的复用性，提高开发效率，使程序逻辑更清晰。<br></code></pre></td></tr></table></figure><h2 id="二、方法的其他形式"><a href="#二、方法的其他形式" class="headerlink" title="二、方法的其他形式"></a>二、方法的其他形式</h2><p>各位同学，刚才我们学习了定义完整格式的方法。但是实际开发中，需要按照方法解决的实际业务需求，设计出合理的方法形式来解决问题。</p><p>实际上设计一个合理的方法，需要重点关注下面两点</p><p><img src="/assets/1661685360525.png" alt="1661685360525"></p><p><img src="/assets/1661685287374.png" alt="1661685287374"></p><p>设计一个合理的方法的原则如下：</p><ul><li>如果方法不需要返回数据，返回值类型必须申明成void（无返回值申明）,  此时方法内部不可以使用return返回数据。</li><li>方法如果不需要接收外部传递进来的数据，则不需要定义形参，且调用方法时也不可以传数据给方法。</li><li>没有参数，且没有返回值类型（void）的方法，称为值无参数、无返回值方法。此时调用方法时不能传递数据给方法。</li></ul><p>接下来我们看几个案例代码，练习根据实际需求定义出合理的方法</p><p><strong>需求1：写一个方法，打印3个”Hello World”</strong></p><p>分析：需求已经非常明确，打印的是3个HelloWorld，在方法中直接循环3次就可以完成需求。不需要外部给方法传递数据，所以不需要参数。</p><p><img src="/assets/1661686972979.png" alt="1661686972979"></p><p><strong>需求2：写一个方法，打印若干个”Hello World”，具体多少个，有调用者指定</strong></p><p>分析：需求不明确打印HelloWorld的个数，而是需要调用者指定。也就是说，调用者调用方法时需要给方法传递打印HelloWorld的个数。那么定义方法时，就需要写一个参数，来接收调用者传递过来的个数。</p><p><img src="/assets/1661687241729.png" alt="1661687241729"></p><h2 id="三、方法使用常见的问题"><a href="#三、方法使用常见的问题" class="headerlink" title="三、方法使用常见的问题"></a>三、方法使用常见的问题</h2><p>各位同学，自己第一次写方法时，或多或少会可能会出现一些问题。下面把使用方法时，常见的问题整理一下。</p><p>目的是让同学们，以后写方法时避免出现这些问题。一旦出现这些问题，要知道是什么原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">- <span class="hljs-number">1.</span> 方法在内种没有先后顺序，但是不能把一个方法定义在另一个方法中。<br><br>- <span class="hljs-number">2.</span> 方法的返回值类型写<span class="hljs-keyword">void</span>（无返回申明）时，方法内不能使用<span class="hljs-keyword">return</span>返回数据，<br>如果方法的返回值类型写了具体类型，方法内部则必须使用<span class="hljs-keyword">return</span>返回对应类型的数据。<br><br>- <span class="hljs-number">3.</span> <span class="hljs-keyword">return</span>语句的下面，不能编写代码，属于无效的代码，执行不到这儿。<br><br>- <span class="hljs-number">4.</span> 方法不调用就不会执行,  调用方法时，传给方法的数据，必须严格匹配方法的参数情况。<br><br>- <span class="hljs-number">5.</span> 调用有返回值的方法，有<span class="hljs-number">3</span>种方式：<br>     ① 可以定义变量接收结果 <br>     ② 或者直接输出调用，<br>     ③ 甚至直接调用；<br><br>- <span class="hljs-number">6.</span> 调用无返回值的方法，只有<span class="hljs-number">1</span>种方式： 只能直接调用。<br></code></pre></td></tr></table></figure><h2 id="四、方法的案例"><a href="#四、方法的案例" class="headerlink" title="四、方法的案例"></a>四、方法的案例</h2><h3 id="4-1-方法案例1"><a href="#4-1-方法案例1" class="headerlink" title="4.1 方法案例1"></a>4.1 方法案例1</h3><p><img src="/assets/1661687914420.png" alt="1661687914420"></p><p>按照需求：定义方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">需要求1~n的和，由于n不确定是多少，所以就把n写成形式参数，n的具体值由调用者指定。</span><br><span class="hljs-comment">在方法中把n当做一个确定的数据来使用就行。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// i = 1 2 3 ... n</span><br>        sum += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好方法之后，在main方法中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> add(<span class="hljs-number">5</span>);<br>    System.out.println(<span class="hljs-string">&quot;1-5的和是：&quot;</span> + rs); <span class="hljs-comment">//15</span><br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> add(<span class="hljs-number">6</span>);<br>    System.out.println(<span class="hljs-string">&quot;1-6的和是：&quot;</span> + rs); <span class="hljs-comment">//21</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-方法案例2"><a href="#4-2-方法案例2" class="headerlink" title="4.2 方法案例2"></a>4.2 方法案例2</h3><p><img src="/assets/1661687941843.png" alt="1661687941843"></p><p>按照需求：定义方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">需求中，是要判断一个数是奇数还是偶数，但是并没有明确说，是哪一个数。</span><br><span class="hljs-comment">也就是说这个数可能是奇数，也可以能是偶数，是一个能够变化的数。</span><br><span class="hljs-comment">把这个数写成方法的形式参数，就可以达到这个目的。因为调用方法时，调用者可以给传递  奇数，也可以传递偶数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span>&#123;<br>    <span class="hljs-keyword">if</span>(number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>        System.out.println(number + <span class="hljs-string">&quot;是一个偶数！&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(number + <span class="hljs-string">&quot;是一个奇数！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义好方法之后，在main方法中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    judge(<span class="hljs-number">7</span>); <span class="hljs-comment">//调用后打印：7是一个奇数</span><br>    judge(<span class="hljs-number">8</span>); <span class="hljs-comment">//调用后打印：8是一个偶数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、方法在计算机中的执行原理"><a href="#五、方法在计算机中的执行原理" class="headerlink" title="五、方法在计算机中的执行原理"></a>五、方法在计算机中的执行原理</h2><p>各位同学，刚才我们已经写了好几个方法并成功调用了。但是不知道同学们奇不奇怪一个问题。方法在计算机的内存中到底是怎么干的呢？</p><p>为了让大家更加深刻的理解方法的执行过程，接下来，给同学们讲一下方法在计算机中的执行原理。理解方法的执行原理，对我们以后知识的学习也是有帮助的。</p><p>我们知道Java程序的运行，都是在内存中执行的，而内存区域又分为栈、堆和方法区。那Java的方法是在哪个内存区域中执行呢？</p><p>答案是栈内存。 <strong>每次调用方法，方法都会进栈执行；执行完后，又会弹栈出去。</strong></p><p>方法进栈和弹栈的过程，就类似于手枪子弹夹，上子弹和击发子弹的过程。最后上的一颗子弹是，第一个打出来的；第一颗上的子弹，是最后一个打出来的。</p><p><img src="/assets/1661689511649.png" alt="1661689511649"></p><p>假设在main方法中依次调用A方法、B方法、C方法，在内存中的执行流程如下：</p><ul><li>每次调用方法，方法都会从栈顶压栈执行没执行</li><li>每个方法执行完后，会从栈顶弹栈出去</li></ul><p><img src="/assets/1661692070922.png" alt="1661692070922"></p><h3 id="5-1-有返回值的方法，内存分析"><a href="#5-1-有返回值的方法，内存分析" class="headerlink" title="5.1 有返回值的方法，内存分析"></a>5.1 有返回值的方法，内存分析</h3><p>下面我们分析一下，求两个整数和的代码，在内存中的执行原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(rs);<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b )</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b; <br>        <span class="hljs-keyword">return</span> c;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图所示：以上代码在内存中的执行过程，按照①②③④⑤⑥⑦的步骤执行.</p><p><img src="/assets/1661694127049.png" alt="1661694127049"></p><h3 id="5-2-无返回值的方法，内存分析"><a href="#5-2-无返回值的方法，内存分析" class="headerlink" title="5.2 无返回值的方法，内存分析"></a>5.2 无返回值的方法，内存分析</h3><p>刚才我们分析的是有有参数有返回值的方法内存原理。下面再分析一个无返回值、无参数的内存原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2Method</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        study();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>eat();<br>System.out.println(<span class="hljs-string">&quot;学习&quot;</span>);<br>sleep();<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃饭&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;睡觉&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/1661696067585.png" alt="1661696067585"></p><p><strong>总结一下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>方法的运行区域在哪里？<br>答：栈内存。<br><br><span class="hljs-number">2.</span>栈有什么特点？方法为什么要在栈中运行自己？<br>答：先进后出。保证一个方法调用完另一个方法后，可以回来继续执行。<br></code></pre></td></tr></table></figure><h2 id="六、方法参数的传递机制"><a href="#六、方法参数的传递机制" class="headerlink" title="六、方法参数的传递机制"></a>六、方法参数的传递机制</h2><p>各位同学，刚才我们学习了方法运行的原理，相信大家对方法的运行过程有更加深刻的认识。但是方法参数的传递过程还需要，还需要进一步学习一下。</p><p>因为我们刚才演示的一些方法中传递的参数都是基本类型，实际上参数还可以是传递引用类型。接下来，学习一下当参数是基本类型时、和参数是引用类型时的区别。</p><p>先记住一个结论：<strong>Java的参数传递机制都是：值传递</strong></p><p>所谓值传递：指的是在传递实参给方法的形参的时候，传递的是实参变量中存储的值的副本。 同学们肯定想知道，形参是什么？实参又是什么呢？ 请看下面这个张图</p><p><img src="/assets/1661725157681.png" alt="1661725157681"></p><h3 id="6-1-参数传递的基本类型数据"><a href="#6-1-参数传递的基本类型数据" class="headerlink" title="6.1 参数传递的基本类型数据"></a>6.1 参数传递的基本类型数据</h3><p>接下来，看一下方法参数传递是基本类型数据时，内存中是怎么执行的。</p><p><img src="/assets/1661725470322.png" alt="1661725470322"></p><p>我们把参数传递的结论再复习一下：<strong>Java的参数传递机制都是：值传递，传递的是实参存储的值的副本。</strong></p><h3 id="6-3-参数传递的是引用数据类型"><a href="#6-3-参数传递的是引用数据类型" class="headerlink" title="6.3 参数传递的是引用数据类型"></a>6.3 参数传递的是引用数据类型</h3><p>接下来，看一下方法的参数是引用类型的数据时，内存中是怎么执行的。</p><p><img src="/assets/1661728059814.png" alt="1661728059814"></p><p>我们发现调用change方法时参数是引用类型，<strong>实际上也是值传递，只不过参数传递存储的地址值</strong>。此时change方法和main方法中两个方法中各自有一个变量arrs，这两个变量记录的是同一个地址值[I@4c873330，change方法把数组中的元素改了，main方法在访问时，元素已经被修改了。</p><p><strong>总结一下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>基本类型和引用类型的参数在传递的时候有什么不同？<br>= 都是值传递<br>- 基本类型的参数传递存储的数据值。<br>    - 引用类型的参数传递存储的地址值。<br></code></pre></td></tr></table></figure><h2 id="七、方法参数传递案例"><a href="#七、方法参数传递案例" class="headerlink" title="七、方法参数传递案例"></a>七、方法参数传递案例</h2><h3 id="7-1-方法参数传递案例1"><a href="#7-1-方法参数传递案例1" class="headerlink" title="7.1 方法参数传递案例1"></a>7.1 方法参数传递案例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：输出一个<span class="hljs-type">int</span>类型的数组内容，要求输出格式为：[<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>]。<br><br>分析：<br> <span class="hljs-number">1.</span>方法是否需要接收数据进行处理？<br> 方法要打印<span class="hljs-type">int</span>类型数组中的元素，打印哪一个数组需求并不明确；<br>        所以可以把<span class="hljs-type">int</span>数组写成参数，让调用者指定<br>        <br> <span class="hljs-number">2.</span>方法是否需要返回数据？<br> 方法最终的目的知识打印数组中的元素。<br> 不需要给调用者返回什么，所以不需要返回值，返回值类型写<span class="hljs-keyword">void</span><br> <br> <span class="hljs-number">3.</span>方法内部的业务：遍历数组，并输出相应的内容<br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成打印int类型的数组内容。</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">70</span>&#125;;<br>        printArray(arr);<br><br>        <span class="hljs-type">int</span>[] arr2 = <span class="hljs-literal">null</span>;<br>        printArray(arr2);<br><br>        <span class="hljs-type">int</span>[] arr3 = &#123;&#125;;<br>        printArray(arr3);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    参数：int[] arr表示要被打印元素的数组，需要调用者传递</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>        <span class="hljs-keyword">if</span>(arr == <span class="hljs-literal">null</span>)&#123;<br>            System.out.println(arr); <span class="hljs-comment">// null</span><br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 跳出当前方法</span><br>        &#125;<br><br>        System.out.print(<span class="hljs-string">&quot;[&quot;</span>);<br>        <span class="hljs-comment">// 直接遍历接到的数组元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i == arr.length - <span class="hljs-number">1</span>)&#123;<br>                System.out.print(arr[i]);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.print(arr[i] + <span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-方法参数传递案例2"><a href="#7-2-方法参数传递案例2" class="headerlink" title="7.2 方法参数传递案例2"></a>7.2 方法参数传递案例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：比较两个<span class="hljs-type">int</span>类型的数组是否一样，返回<span class="hljs-literal">true</span>或者<span class="hljs-literal">false</span><br><br>分析：<br><span class="hljs-number">1.</span>方法是否需要接收数据进行处理？<br>因为，方法中需要两个<span class="hljs-type">int</span>数组比较，但是需求并不明确是哪两个数组；<br>所以，需要接收两个<span class="hljs-type">int</span>类型的数组，形参声明为：<span class="hljs-type">int</span>[] arr1，<span class="hljs-type">int</span>[] arr2 <br><br> <span class="hljs-number">2.</span>方法是否需要返回数据？<br> 因为,方法最终的结果需要<span class="hljs-literal">true</span>或者<span class="hljs-literal">false</span>;<br>所以，返回值类型是<span class="hljs-type">boolean</span><br> <br><span class="hljs-number">3.</span> 方法内部的业务：判断两个数组内容是否一样。<br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成判断两个int类型的数组是否一样。</span><br>        <span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        <span class="hljs-type">int</span>[] arr2 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>        System.out.println(equals(arr1, arr2));<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">    int[] arr1, 参与比较的第一个int数组</span><br><span class="hljs-comment">    int[] arr2  参与比较的第二个int数组</span><br><span class="hljs-comment">    返回值:</span><br><span class="hljs-comment">    返回比较的结果true或者false</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2)</span>&#123;<br>        <span class="hljs-comment">// 1、判断arr1和arr2是否都是null.</span><br>        <span class="hljs-keyword">if</span>(arr1 == <span class="hljs-literal">null</span> &amp;&amp; arr2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 相等的</span><br>        &#125;<br><br>        <span class="hljs-comment">// 2、判断arr1是null，或者arr2是null.</span><br>        <span class="hljs-keyword">if</span>(arr1 == <span class="hljs-literal">null</span> || arr2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不相等</span><br>        &#125;<br><br>        <span class="hljs-comment">// 3、判断2个数组的长度是否一样，如果长度不一样，直接返回false.</span><br>        <span class="hljs-keyword">if</span>(arr1.length != arr2.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不相等</span><br>        &#125;<br><br>        <span class="hljs-comment">// 4、两个数组的长度是一样的，接着比较它们的内容是否一样。</span><br>        <span class="hljs-comment">// arr1 = [10, 20, 30]</span><br>        <span class="hljs-comment">// arr2 = [10, 20, 30]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>            <span class="hljs-comment">// 判断当前位置2个数组的元素是否不一样，不一样直接返回false</span><br>            <span class="hljs-keyword">if</span>(arr1[i] != arr2[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不相等的</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 两个数组是一样的。</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="八、方法重载"><a href="#八、方法重载" class="headerlink" title="八、方法重载"></a>八、方法重载</h2><p>接下来，我们学习一个开发中很重要的一个方法的形式——叫方法重载。</p><p>所谓方法重载指的是：一个类中，出现多个相同的方法名，但是它们的形参列表是不同的，那么这些方法就称为方法重载了。</p><p>我们在这里要能够认识，哪些是重载的方法。</p><p>下面案例中有多个test方法，但是参数列表都不一样，它们都是重载的方法。调用时只需要通过参数来区分即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodOverLoadDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：认识方法重载，并掌握其应用场景。</span><br>        test();<br>        test(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===test1===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===test2===&quot;</span> + a);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">double</span> a)</span>&#123;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们认识了方法重载，那么方法重载有哪些应用场景呢？ </p><p>一般在开发中，我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很专业的。</p><p>比如，我们现在看一个案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：开发武器系统，功能需求如下：<br>    可以默认发一枚武器。<br>    可以指定地区发射一枚武器。<br>    可以指定地区发射多枚武器。<br><br></code></pre></td></tr></table></figure><p>上面的几个需求中，不管以什么样的方式发武器，其实最终的目的都是发武器。</p><p>所以我们可以设计几个名称相同的方法，这样调用者调用起来就不用记那么多名字了</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：掌握方法重载的应用场景。</span><br>        fire();<br>        fire(<span class="hljs-string">&quot;岛国2&quot;</span>);<br>        fire(<span class="hljs-string">&quot;米国&quot;</span>, <span class="hljs-number">999</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fire</span><span class="hljs-params">()</span>&#123;<br>        fire(<span class="hljs-string">&quot;岛国&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fire</span><span class="hljs-params">(String country)</span>&#123;<br>        fire(country, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fire</span><span class="hljs-params">(String country, <span class="hljs-type">int</span> number)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发射了&quot;</span> + number + <span class="hljs-string">&quot;枚武器给&quot;</span> + country);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结一下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>什么是方法重载？<br>答：一个类中，多个方法的名称相同，但它们形参列表不同。<br><span class="hljs-number">2.</span>方法重载需要注意什么？<br>- 一个类中，只要一些方法的名称相同、形参列表不同，那么它们就是方法重载了，<br>  其它的都不管（如：修饰符，返回值类型是否一样都无所谓）。<br><br>- 形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称。<br><br><span class="hljs-number">3</span>、方法重载有啥应用场景？<br>答：开发中我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很专业的。<br></code></pre></td></tr></table></figure><h2 id="九、return单独使用"><a href="#九、return单独使用" class="headerlink" title="九、return单独使用"></a>九、return单独使用</h2><p>各位同学，关于方法的定义，我们还剩下最后一种特殊用法，就是在方法中单独使用return语句，可以用来提前结束方法的执行。</p><p>如，下面的chu方法中，当除数为0时，就提前结束方法的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br>        chu(<span class="hljs-number">10</span> , <span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chu</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>            System.err.println(“您的数据有误！！不执行！！”);<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 直接跳出并结束当前chu方法的执行</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a / b;<br>        System.out.println(<span class="hljs-string">&quot;除法结果是：&quot;</span>+c); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>今天的课程就到此结束了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/01/day04-Java%E6%95%B0%E7%BB%84/"/>
    <url>/2023/12/01/day04-Java%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="day04——Java数组"><a href="#day04——Java数组" class="headerlink" title="day04——Java数组"></a>day04——Java数组</h1><p>各位同学，今天我们学习一个Java中非常重要的技术——数组。</p><h2 id="一、认识数组"><a href="#一、认识数组" class="headerlink" title="一、认识数组"></a>一、认识数组</h2><p>先来认识一下什么数组</p><h3 id="1-什么数组"><a href="#1-什么数组" class="headerlink" title="1. 什么数组"></a>1. 什么数组</h3><p>数组就是一个容器，用来存一批同种类型的数据的。</p><p>比如：想要存储 20,10,80,60,90 这些数据。 我们可以把代码写成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">80</span>,<span class="hljs-number">60</span>,<span class="hljs-number">90</span>&#125;;<br></code></pre></td></tr></table></figure><p>比如：想要存储 “牛二“,“西门“,“全蛋“ 这些数据。我们可以把代码写成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] names = &#123;<span class="hljs-string">&quot;牛二&quot;</span>, <span class="hljs-string">&quot;西门&quot;</span>, <span class="hljs-string">&quot;全蛋&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-数组的应用场景"><a href="#2-数组的应用场景" class="headerlink" title="2. 数组的应用场景"></a>2. 数组的应用场景</h3><p>有变量，为什么还要有数组呢？ 比如，我们要做一个点名器</p><p><img src="/assets/1661321640902.png" alt="1661321640902"></p><p>如果用变量来做的话，代码是这样子的</p><p><img src="/assets/1661321680612.png" alt="1661321680612"></p><p>如果用数组来做的话，代码是这样子的</p><p><img src="/assets/1661321716135.png" alt="1661321716135"></p><p>一对比我们发现数组的写法比变量的写法更加简洁，所以我们可以得出一个结论</p><p><strong>结论：遇到批量数据的存储和操作时，数组比变量更适合</strong></p><h2 id="二、数组的定义和访问"><a href="#二、数组的定义和访问" class="headerlink" title="二、数组的定义和访问"></a>二、数组的定义和访问</h2><p>各位同学，我们已经知道数组是用来干什么的。那么如何使用Java语言写一个数组呢？这里就需要学习一下数组的初始化格式。</p><p>数组有两种初始化的方式，一种是静态初始化、一种是动态初始化。我们先用静态初始化来学习数组的操作。</p><h3 id="2-1-数组的静态初始化"><a href="#2-1-数组的静态初始化" class="headerlink" title="2.1 数组的静态初始化"></a>2.1 数组的静态初始化</h3><p>所谓静态初始化指的是：在定义数组时直接给数组中的数据赋值。</p><p><strong>1. 静态初始化标准格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 变量名 = <span class="hljs-keyword">new</span> 数据类型[]&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>按照格式定义int类型、double类型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义数组，用来存储多个年龄</span><br><span class="hljs-type">int</span>[] ages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">12</span>, <span class="hljs-number">24</span>, <span class="hljs-number">36</span>&#125;<br><span class="hljs-comment">//定义数组，用来存储多个成绩</span><br><span class="hljs-type">double</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[]&#123;<span class="hljs-number">89.9</span>, <span class="hljs-number">99.5</span>, <span class="hljs-number">59.5</span>, <span class="hljs-number">88.0</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>2. 静态初始化简化格式</strong></p><p>Java语言的设计者为了简化定义数组的写法，还为静态初始化提供了一种简化写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 变量名 = &#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>使用简化格式定义int类型、double类型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义数组，用来存储多个年龄</span><br><span class="hljs-type">int</span>[] ages = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">24</span>, <span class="hljs-number">36</span>&#125;<br><span class="hljs-comment">//定义数组，用来存储多个成绩</span><br><span class="hljs-type">double</span>[] scores = &#123;<span class="hljs-number">89.9</span>, <span class="hljs-number">99.5</span>, <span class="hljs-number">59.5</span>, <span class="hljs-number">88.0</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>3. 注意哟！！</strong></p><ul><li>定义数组时， <code>数据类型[] 数组名</code> 也可写成 <code>数据类型 数组名[]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以下两种写法是等价的。但是建议大家用第一种，因为这种写法更加普遍</span><br><span class="hljs-type">int</span>[] ages = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">24</span>, <span class="hljs-number">36</span>&#125;;<br><span class="hljs-type">int</span> ages[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">24</span>, <span class="hljs-number">36</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. 数组在计算机中的基本原理</strong></p><p>我们知道数组是怎么定义的之后，那么接下来看一下数组在计算机中的基本原理。</p><p>我们以<code>int[] ages = &#123;12,24,36&#125;;</code>这句话为例，看一下这句话到底在计算机中做了那些事情。</p><ul><li>首先，左边<code>int[] ages</code> 表示定义了一个数组类型的变量，变量名叫ages</li><li>其次，右边<code>&#123;12,24,36&#125;</code>表示创建一个数组对象，你完全可以把它理解成一个能装数据的东西。这个对象在内存中会有一个地址值<code>[I@4c873330</code>，每次创建一个数组对象都会有不用的地址值。</li><li>然后，把右边的地址值<code>[I@4c873330</code>赋值给左边的ages变量</li><li>所以，ages变量就可以通过地址值，找到数组这个东西。</li></ul><p><img src="/assets/1661353166416.png" alt="1661353166416"></p><h3 id="2-2-数组的元素访问"><a href="#2-2-数组的元素访问" class="headerlink" title="2.2 数组的元素访问"></a>2.2 数组的元素访问</h3><p>各位同学，通过刚才的学习，我们知道数组是用来存储数据的。那么数组中存储的数据又如何访问呢？这里所说的访问，意思就是获取中数组中数据的值、或者给数组中的数据赋值。</p><p>这里先给大家统一几个概念，数组中存储的数据我们叫做元素；而且数组中的每一个元素都有一个编号与之对应，我们把这个编号叫做索引，这个索引是从0依次递增的整数。如下图所示</p><p><img src="/assets/1661354056668.png" alt="1661354056668"></p><p>要想访问数组中的元素，格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组名可以找到数组对象的地址，再通过索引就可以定位到具体的元素了</span><br>数组名[索引]<br></code></pre></td></tr></table></figure><p>接下来用代码来演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//索引：   0   1   2</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">24</span>, <span class="hljs-number">36</span>&#125;;<br><span class="hljs-comment">// 1、访问数组的全部数据</span><br>System.out.println(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">//12</span><br>System.out.println(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">//24</span><br>System.out.println(arr[<span class="hljs-number">2</span>]); <span class="hljs-comment">//36</span><br><span class="hljs-comment">//下面代码没有3索引，会出现ArrayIndexOutOfBoundsException 索引越界异常</span><br><span class="hljs-comment">//System.out.println(arr[3]); </span><br><br><span class="hljs-comment">// 2、修改数组中的数据</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">66</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">100</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">//66</span><br>System.out.println(arr[<span class="hljs-number">1</span>]); <span class="hljs-number">0</span><br>System.out.println(arr[<span class="hljs-number">2</span>]); <span class="hljs-comment">//100</span><br></code></pre></td></tr></table></figure><p>除了访问数组中的元素，我们可以获取数组中元素的个数，后面我们统称为数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3、访问数组的元素个数：数组名.length</span><br>System.out.println(arr.length);<br><br><span class="hljs-comment">// 技巧：获取数组的最大索引: arr.length - 1(前提是数组中存在数据)</span><br>System.out.println(arr.length - <span class="hljs-number">1</span>);<br><br><span class="hljs-type">int</span>[] arr2 = &#123;&#125;;<br>System.out.println(arr2.length - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="2-3-数组的遍历"><a href="#2-3-数组的遍历" class="headerlink" title="2.3 数组的遍历"></a>2.3 数组的遍历</h3><p>各位同学，接下来我们学习一个对数组最最最常见的操作——数组遍历。所谓遍历意思就是将数组中的元素一个一个的取出来。</p><p>我们刚才学习了数组中元素的访问，访问元素必须用到索引，如下列代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ages = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">24</span>, <span class="hljs-number">36</span>&#125;;<br>System.out.println(ages[<span class="hljs-number">0</span>]);<br>System.out.println(ages[<span class="hljs-number">1</span>]);<br>System.out.println(ages[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><p>但是，如果数组中有很多很多元素，索引靠自己一个一个数肯定是不行的！我们可以使用for循环从0开始一直遍历到长度-1的位置，就可以获取所有的索引了。 </p><p>当你获取到每一个索引，那么每一个元素不就获取到了吗？上代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ages = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">24</span>, <span class="hljs-number">36</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ages.length; i++) &#123;<br>    <span class="hljs-comment">// i的取值 = 0,1,2</span><br>    System.out.println(ages[i]); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-数组静态初始化案例"><a href="#2-4-数组静态初始化案例" class="headerlink" title="2.4 数组静态初始化案例"></a>2.4 数组静态初始化案例</h3><p>学习完数组的静态初始化之后，接下来我们做一个练习题来巩固一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：某部门<span class="hljs-number">5</span>名员工的销售额分别是：<span class="hljs-number">16</span>、<span class="hljs-number">26</span>、<span class="hljs-number">36</span>、<span class="hljs-number">6</span>、<span class="hljs-number">100</span>，请计算出他们部门的总销售额。<br><br>需求分析：<br><span class="hljs-number">1.</span>看到有<span class="hljs-number">16</span>、<span class="hljs-number">26</span>、<span class="hljs-number">36</span>、<span class="hljs-number">6</span>、<span class="hljs-number">100</span>这<span class="hljs-number">5</span>个数据数据，而且数据值很明确;<br><span class="hljs-number">1</span>)想到,可以使用数组静态初始化把这<span class="hljs-number">5</span>个数据存起来<br><br><span class="hljs-number">2.</span>请计算出他们部门的总销售额（这不就是求数组中数据的和吗？）<br><span class="hljs-number">2</span>)必须先将数组中所有的元素遍历出来<br><span class="hljs-number">3</span>)想要求和，得先有一个求和变量sum<br><span class="hljs-number">4</span>)再将每一个元素和求和变量sum进行累加（求和思想）<br></code></pre></td></tr></table></figure><p>按照分析的思路来写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、定义一个数组存储5名员工的销售额</span><br><span class="hljs-comment">//索引          0   1    2  3   4</span><br><span class="hljs-type">int</span>[] money = &#123;<span class="hljs-number">16</span>, <span class="hljs-number">26</span>, <span class="hljs-number">36</span>, <span class="hljs-number">6</span>, <span class="hljs-number">100</span>&#125;;<br><br><span class="hljs-comment">// 3、定义一个变量用于累加求和</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 2、遍历这个数组中的每个数据。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; money.length; i++) &#123;<br>    <span class="hljs-comment">// i = 0  1  2  3  4</span><br>    sum += money[i];<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;员工的销售总额：&quot;</span> + sum);<br></code></pre></td></tr></table></figure><h3 id="2-5-数组的动态初始化"><a href="#2-5-数组的动态初始化" class="headerlink" title="2.5 数组的动态初始化"></a>2.5 数组的动态初始化</h3><p>各位同学，刚才我们初始化数组时，都是直接将元素写出来。但是还有另一个初始化数组的方式叫 <strong>动态初始化</strong>。</p><p>动态初始化不需要我们写出具体的元素，而是指定元素类型和长度就行。格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据类型[]  数组名 = new 数据类型[长度];</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>下面是动态初始化数组的原理图。我们发现<code>int[] arr</code> 其实就是一个变量，它记录了数组对象的地址值，而且数组中的元素默认值是0。</p><p><img src="/assets/1661356063895.png" alt="1661356063895"></p><p><strong>注意：</strong></p><p>使用动态初始化定义数组时，根据元素类型不同，默认值也有所不同。</p><p><img src="/assets/1661417981361.png" alt="1661417981361"></p><p>关于数组动态初始化的格式和原理，咱们就先学习到这里。</p><h3 id="2-6-数组动态初始化案例"><a href="#2-6-数组动态初始化案例" class="headerlink" title="2.6 数组动态初始化案例"></a>2.6 数组动态初始化案例</h3><p>各位同学，接下来我们做一个数组动态初始化的案例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">案例需求：<br>某歌唱比赛，需要开发一个系统：可以录入<span class="hljs-number">6</span>名评委的打分，录入完毕后立即输出平均分做<br>选手得分<br><br>需求分析：<br><span class="hljs-number">1.</span>需要录入<span class="hljs-number">6</span>名评委的分数，可以用一个数组来保存。<br>   因为在评委没有录入分数之前，还不确定数组中应该存哪些数据。<br>   所以可以使用数组的动态初始化<br><span class="hljs-number">2.</span>遍历数组中的每一个位置，并录入分数，将分数存入数组中<br><span class="hljs-number">3.</span>遍历数组中的每一个元素，对元素求和<br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、定义一个动态初始化的数组，负责后期存储6个评委的打分。</span><br><span class="hljs-type">double</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">6</span>];<br><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br><span class="hljs-comment">// 2、遍历数组中的每个位置，录入评委的分数，存入到数组中去</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++) &#123;<br>    <span class="hljs-comment">// i = 0 1 2 3 4 5</span><br>    System.out.println(<span class="hljs-string">&quot;请您输入当前第&quot;</span> + (i + <span class="hljs-number">1</span>) +<span class="hljs-string">&quot;个评委的分数：&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> sc.nextDouble();<br>    scores[i] = score;<br>&#125;<br><br><span class="hljs-comment">// 3、遍历数组中的每个元素进行求和</span><br><span class="hljs-type">double</span> <span class="hljs-variable">sum</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++) &#123;<br>    sum += scores[i];<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;选手最终得分是：&quot;</span> + sum / scores.length);<br></code></pre></td></tr></table></figure><h2 id="三、数组在计算机中的执行原理"><a href="#三、数组在计算机中的执行原理" class="headerlink" title="三、数组在计算机中的执行原理"></a>三、数组在计算机中的执行原理</h2><p>好的各位同学，在前面我们已经学习了数组的基本使用，也理解了数组的基本原理。由于数组是一个容器，变量也是一个容器，在理解他们执行原理的时候，有些同学就容易搞混，现在我把他们放在一起带着大家回顾一下他们的会执行原理，顺便带着大家详细理解一下Java程序的执行的内存原理。</p><h3 id="3-1-数组的执行原理，Java程序的执行原理"><a href="#3-1-数组的执行原理，Java程序的执行原理" class="headerlink" title="3.1 数组的执行原理，Java程序的执行原理"></a>3.1 数组的执行原理，Java程序的执行原理</h3><p>我们以下面的代码，来讲解变量、数组的执原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(a);<br><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;;<br>        System.out.println(arr);<br><br>        System.out.println(arr[<span class="hljs-number">1</span>]);<br><br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">44</span>;<br>        arr[<span class="hljs-number">1</span>] = <span class="hljs-number">55</span>;<br>        arr[<span class="hljs-number">2</span>] = <span class="hljs-number">66</span>;<br><br>        System.out.println(arr[<span class="hljs-number">0</span>]);<br>        System.out.println(arr[<span class="hljs-number">1</span>]);<br>        System.out.println(arr[<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们给大家讲过，程序是在内存中执行的。实际上Java程序是把编译后的字节码加载到Java虚拟机中执行的。</p><p><img src="/assets/1661437717797.png" alt="1661437717797"></p><p>Java为了便于虚拟机执行Java程序，将虚拟机的内存划分为 方法区、栈、堆、本地方法栈、寄存器 这5块区域。同学们需要重点关注的是  <strong>方法区、栈、堆</strong>。</p><p>下面把每一个块内存区域作用介绍一下，我们大致只需要知道每一部分存储什么内容就行。</p><ul><li><strong>方法区</strong>：字节码文件先加载到这里</li><li><strong>栈</strong>：方法运行时所进入的内存区域，由于变量在方法中，所以变量也在这一块区域中</li><li><strong>堆</strong>：存储new出来的东西，并分配地址。由于数组是new 出来的，所以数组也在这块区域。</li></ul><p>下面是上面案例执行的内存原理如下图所示，按照① ② ③ ④ ⑤ ⑥ 的标记的顺序来看</p><p><img src="/assets/1661438278304.png" alt="1661438278304"></p><p><strong>总结一下<code>int a = 10</code>与 <code>int[] arr = new int[]&#123;11,22,33&#125;的区别</code></strong></p><ul><li><strong>a</strong>是一个变量，在栈内存中，<strong>a</strong>变量中存储的数据就是<strong>10</strong>这个值。</li><li><strong>arr</strong>也是一个变量，在栈中，存储的是数组对象在堆内存中的地址值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里的int a是一个基本类型变量，存储的是一个数值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> ; <br><span class="hljs-comment">//这里的int[] arr是一个引用类型的变量，存储的是一个地址值</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">66</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-2-多个变量指向同一个数组的问题"><a href="#3-2-多个变量指向同一个数组的问题" class="headerlink" title="3.2 多个变量指向同一个数组的问题"></a>3.2 多个变量指向同一个数组的问题</h3><p>各位同学，我们了解了数组在内存中的执行原理。我们知道数组类型的变量，指向的是堆内存中数组对象的地址。但是在实际开发中可能存在一种特殊情况，就是多个变量指向同一个数组对象的形式。</p><p>讲解这个知识点的目的，是让同学们注意多个变量指向同一个数组对象存在什么问题？</p><p>我们先看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：认识多个变量指向同一个数组对象的形式，并掌握其注意事项。</span><br>        <span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;;<br><br>        <span class="hljs-comment">// 把int类型的数组变量arr1赋值给int类型的数组变量arr2</span><br>        <span class="hljs-type">int</span>[] arr2 = arr1;<br><br>        System.out.println(arr1);<br>        System.out.println(arr2);<br><br>        arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;<br>        System.out.println(arr1[<span class="hljs-number">1</span>]);<br><br>        arr2 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 拿到的数组变量中存储的值是null</span><br>        System.out.println(arr2);<br><br>        <span class="hljs-comment">//System.out.println(arr2[0]);</span><br>        <span class="hljs-comment">//System.out.println(arr2.length);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点关注这一段代码</p><p><img src="/assets/1661439843879.png" alt="1661439843879"></p><p>刚执行完<code>int[] arr1 = &#123;11,22,33&#125;;</code>时，内存原理如下</p><p><img src="/assets/1661439986204.png" alt="1661439986204"></p><p>当执行完<code>int[] arr2 = arr1;</code>后，内存原理如下</p><p><img src="/assets/1661440179341.png" alt="1661440179341"></p><p>当执行到<code>arr2[1]=99;时</code>，内存原理如下</p><p><img src="/assets/1661440425901.png" alt="1661440425901"></p><p><strong>总结一下：</strong></p><ul><li><p>两个变量指向同一个数组时，两个变量记录的是同一个地址值。</p></li><li><p>当一个变量修改数组中的元素时，另一个变量去访问数组中的元素，元素已经被修改过了。</p></li></ul><p>到这里有关数组的基本操作，和内存原理我们就全部学习完了。</p><h2 id="四、数组专项练习"><a href="#四、数组专项练习" class="headerlink" title="四、数组专项练习"></a>四、数组专项练习</h2><p>接下来我们做一些专项练习题，把数组的常见操作练习一下。在学习这个案例时，重点掌握数组求最值的思路，代码只是用来表达你的思路的。</p><h3 id="4-1-数组求最值"><a href="#4-1-数组求最值" class="headerlink" title="4.1 数组求最值"></a>4.1 数组求最值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：定义一个<span class="hljs-type">int</span>类型数组，求数组中元素的最大值，并打印最大值<br></code></pre></td></tr></table></figure><p>我们先看一下选美比赛，是怎么选出颜值最高的人的。然后再以此思路，来写代码找出数组中元素的最大值。</p><p><img src="/assets/1661441712915.png" alt="1661441712915"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">数组求最大值思路：<br><span class="hljs-number">1</span>)先找出数组中<span class="hljs-number">0</span>索引的元素，假设为最大值，用max表示【擂主】<br><span class="hljs-number">2</span>)遍历后面的每一个元素和max比较，把较大的元素值重新赋值给max(擂主换人)<br>    <span class="hljs-number">3</span>)最后max就是所有元素的最大值(最后站在台上的擂主)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、把颜值数据拿到程序中来，用数组装起来</span><br>        <span class="hljs-type">int</span>[] faceScores = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">9000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">9500</span>, -<span class="hljs-number">5</span>&#125;;<br><br>        <span class="hljs-comment">// 2、定义一个变量用于最终记住最大值。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> faceScores[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 3、从数组的第二个位置开始遍历。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; faceScores.length; i++) &#123;<br>            <span class="hljs-comment">// i = 1  2  3  4  5</span><br>            <span class="hljs-comment">// 判断一下当前遍历的这个数据，是否大于最大值变量max存储的数据，</span><br>            <span class="hljs-comment">//如果大于，当前遍历的数据需要赋值给max</span><br>            <span class="hljs-keyword">if</span>(faceScores[i] &gt; max )&#123;<br>                max = faceScores[i];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最高颜值是：&quot;</span> + max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结一下：</strong></p><p>通过这个案例，我们主要掌握求最值的思路，以后不管遇到求最大值还是最小值，编程思路都是一样的，不同的可能是数据不同。</p><h3 id="4-2-数组元素反转"><a href="#4-2-数组元素反转" class="headerlink" title="4.2 数组元素反转"></a>4.2 数组元素反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：某个数组有<span class="hljs-number">5</span>个数据：<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>，请将这个数组中的数据进行反转。<br>      [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]  反转后 [<span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>数组元素反转的核心，其实是数组中两个数据的交换。我们可以认为两个数据分别存储在两个水杯中。想要交换两个水杯中的东西，我们得借助第三个水杯，如下图所示</p><p><img src="/assets/1661442733592.png" alt="1661442733592"></p><p><img src="/assets/1661442758553.png" alt="1661442758553"></p><p>数组中元素交换，就是用的借用第三方变量的思想。 我们把数组中的每一个元素当做一个水杯，然后索引控制哪两个元素互换位置。</p><p>怎么样，才能达到元素反转的效果呢？我们只需将第一个和最后一个元素互换、第二个和倒数第二个互换、依次内推…. 如下图所示</p><p><img src="/assets/1661443189060.png" alt="1661443189060"></p><p>怎么样写代码，才能达到上面的效果呢？我们继续分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>每次交换，需要有左右两边的两个索引，我们可以用i和j表示<br>刚开始i=<span class="hljs-number">0</span>，j=数组长度-<span class="hljs-number">1</span>;<br><span class="hljs-number">2.</span>每次让i和j索引位置的两个元素互换位置<br>arr[i]和arr[j]互换位置<br><span class="hljs-number">3.</span>每次还完位置之后，让i往右移动一位，让j往前移动一位<br></code></pre></td></tr></table></figure><p>具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成数组反转。</span><br>        <span class="hljs-comment">// 1、准备一个数组</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;  <br><br>        <span class="hljs-comment">// 2、定义一个循环，设计2个变量，一个在前，一个在后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = arr.length - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-comment">// arr[i]   arr[j]</span><br>            <span class="hljs-comment">// 交换</span><br>            <span class="hljs-comment">// 1、定义一个临时变量记住后一个位置处的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>            <span class="hljs-comment">// 2、把前一个位置处的值赋值给后一个位置了</span><br>            arr[j] = arr[i];<br>            <span class="hljs-comment">// 3、把临时变量中记住的后一个位置处的值赋值给前一个位置处</span><br>            arr[i] = temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 3、遍历数组中的每个数据，看是否反转成功了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结一下：</strong></p><p>通过上面的案例，需要我们掌握元素互换位置的编程思路；以后遇到数据互换问题，都这样做。</p><h3 id="4-3-随机排名"><a href="#4-3-随机排名" class="headerlink" title="4.3 随机排名"></a>4.3 随机排名</h3><p>各位同学，通过数组元素反转的案例，我们学会了如何对两个数据进行交换。接下来，我们再学习随机排名案例，将数据交换的思路再巩固一下。</p><p>先来看一下需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">需求：某公司开发部<span class="hljs-number">5</span>名开发人员，要进行项目进展汇报演讲，现在采取随机排名后进行汇报。请先依次录入<span class="hljs-number">5</span>名员工的工号，然后展示出一组随机的排名顺序。<br></code></pre></td></tr></table></figure><p>分析一下随机排名的思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>在程序中录入<span class="hljs-number">5</span>名员工的工号存储起来 ---&gt; 使用动态初始化数组的方式。<br><span class="hljs-number">2.</span>依次遍历数组中的每个数据。<br><span class="hljs-number">3.</span>每遍历到一个数据，都随机一个索引值出来，让当前数据与该索引位置处的数据进行交换。<br></code></pre></td></tr></table></figure><p>如下图所示，每次遍历到一个元素，随机将当前位置元素和随机索引元素换位置。</p><p><img src="/assets/1661444407716.png" alt="1661444407716"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 目标：完成随机排名</span><br>        <span class="hljs-comment">// 1、定义一个动态初始化的数组用于存储5名员工的工号</span><br>        <span class="hljs-type">int</span>[] codes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><br>        <span class="hljs-comment">// 2、提示用户录入5名员工的工号。</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; codes.length; i++) &#123;<br>            <span class="hljs-comment">// i = 0 1 2 3 4</span><br>            System.out.println(<span class="hljs-string">&quot;请您输入第&quot;</span> + (i + <span class="hljs-number">1</span>) +<span class="hljs-string">&quot;个员工的工号：&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            codes[i] = code;<br>        &#125;<br><br>        <span class="hljs-comment">// 3、打乱数组中的元素顺序。</span><br>        <span class="hljs-comment">// [12, 33, 54, 26, 8]</span><br>        <span class="hljs-comment">//  i       index</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; codes.length; i++) &#123;<br>            <span class="hljs-comment">// codes[i]</span><br>            <span class="hljs-comment">// 每遍历到一个数据，都随机一个数组索引范围内的值。</span><br>            <span class="hljs-comment">//然后让当前遍历的数据与该索引位置处的值交换。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> r.nextInt(codes.length); <span class="hljs-comment">// 0 - 4</span><br>            <span class="hljs-comment">// 定义一个临时变量记住index位置处的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> codes[index];<br>            <span class="hljs-comment">// 把i位置处的值赋值给index位置处</span><br>            codes[index] = codes[i];<br>            <span class="hljs-comment">// 把index位置原来的值赋值给i位置处</span><br>            codes[i] = temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 4、遍历数组中的工号输出即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; codes.length; i++) &#123;<br>            System.out.print(codes[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这有关数组的常见练习题我们就讲完了，待会我们在给同学们讲一个开发中用得比较多的工具叫做Debug调试。</p><h2 id="五、Debug调试工具"><a href="#五、Debug调试工具" class="headerlink" title="五、Debug调试工具"></a>五、Debug调试工具</h2><p>各位同学，为了让大家更好的理解代码的执行流程，这里给大家讲一个在开发中非常重要的工具——叫做Debug调试。 </p><p>通过Debug调试，我们可以查看代码的执行流程。当你代码中有Bug但是又发现不了的时候，你就可以用Debug调试工具，查看执行流程，逐步分析是哪一行出现了问题。</p><p>Debug调试工具的使用步骤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">第一步：打断点，如下图的红色小圆点<br>第二步：右键Debug方式启动程序，如下图右键菜单<br>  启动后，代码会停留在打断点的这一行<br>第三步：点击箭头按钮，一行一行往下执行<br></code></pre></td></tr></table></figure><p><img src="/assets/1661444896100.png" alt="1661444896100"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>01句子</title>
    <link href="/2023/04/07/01%E5%8F%A5%E5%AD%90/"/>
    <url>/2023/04/07/01%E5%8F%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h3><h4 id="仅为摘抄"><a href="#仅为摘抄" class="headerlink" title="仅为摘抄"></a>仅为摘抄</h4><p>01：愿你我皆良人捏</p>]]></content>
    
    
    
    <tags>
      
      <tag>句子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/05/%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/04/05/%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>个人</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
